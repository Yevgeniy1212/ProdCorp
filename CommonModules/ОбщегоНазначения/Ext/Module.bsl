
#Если Клиент Тогда 

Процедура ОбновитьПараметрыСеансаПользователя() Экспорт

	ТекстРезультата = "";
	
	ПолныеПрава.УстановитьИзменяемыеПараметрыСеансаПользователя(Истина, ТекстРезультата);
	
	// эту настройку необходимо обновлять только по вызову пользователя
	СохранитьЗначение("ИерархическийПросмотрФормы", Истина);
	ТекстРезультата = ТекстРезультата + " - сброшен признак поиска в иерархических справочниках" + Символы.ПС;
	
	ТекстРезультата = "Обновление системной информации завершено успешно!" + Символы.ПС + Символы.ПС + "Протокол обновления:" + Символы.ПС + " " + СокрЛП(ТекстРезультата);
	Предупреждение(ТекстРезультата);

КонецПроцедуры
// Отображает картинку в ФормеСписка
// 
Процедура РучнаяКорректировкаСписокПриПолученииДанных(ОформленияСтрок)  Экспорт
	
	Для Каждого Строка Из ОформленияСтрок Цикл
		
		//Строка.Ячейки.РучнаяКорректировка.Картинка = БиблиотекаКартинок.РучнаяКорректировка;
		//Строка.Ячейки.РучнаяКорректировка.ОтображатьКартинку = (Строка.ДанныеСтроки.РучнаяКорректировка = Истина);
				
	КонецЦикла
	
КонецПроцедуры // РучнаяКорректировкаСписокПриПолученииДанных()

// Открывает ОсновнуюФорму ручной корректировки
//
Процедура РучнаяКорректировкаОсновнаяФорма(ЭтоНовый,Ссылка,РазрешитьРедактированиеДвижений = Ложь, ВидРегламентнойОперации = Неопределено)  Экспорт
	
	Если НЕ ЭтоНовый Тогда
		ФормаНастройки = Обработки.КорректировкаДвижений.ПолучитьФорму("ОсновнаяФормаСписок", , Строка(Ссылка));
		
		//в случае когда просмотр движений вызывается из обработки "ЗакрытиеМесяца"
		ФормаНастройки.ВидРегламентнойОперации = ВидРегламентнойОперации;
		Если ФормаНастройки.Открыта() Тогда 
			ФормаНастройки.Активизировать();
		Иначе 
			ФормаНастройки.ДокументСсылка = Ссылка;
			ФормаНастройки.РазрешитьРедактированиеДвижений = РазрешитьРедактированиеДвижений;
			ФормаНастройки.Открыть();
		КонецЕсли;
	КонецЕсли;
 	
КонецПроцедуры // РучнаяКорректировкаОсновнаяФорма()

// Открывает ОсновнуюФорму ручной корректировки после записи
//
Процедура РучнаяКорректировкаОсновнаяФормаПослеЗаписи(Проведен,ОткрыватьНастройкуДвижений,Ссылка)  Экспорт
	
	Если Проведен И ОткрыватьНастройкуДвижений Тогда
		ФормаНастройки = Обработки.КорректировкаДвижений.ПолучитьФорму("ОсновнаяФормаСписок", , Строка(Ссылка));
		ФормаНастройки.ДокументСсылка = Ссылка;
		ФормаНастройки.РазрешитьРедактированиеДвижений = Ложь;
		ФормаНастройки.Открыть();
	КонецЕсли;
 	
КонецПроцедуры // РучнаяКорректировкаОсновнаяФормаПослеЗаписи()

// Процедура обрабатывает событие начала выбора из списка в поле периода
// Процедура исполняется только на клиенте
//
Процедура ПериодНачалоВыбораИзСписка(Элемент, СтандартнаяОбработка, Форма, ДатаВПериоде, Периодичность, НачальноеЗначение = Неопределено) Экспорт
	
	СтандартнаяОбработка = Ложь;
	
	Если НачальноеЗначение = Неопределено Тогда
		НачальноеЗначение = ДатаВПериоде;
	КонецЕсли;
	
	СписокВыбора = Новый СписокЗначений;
	НачалоТекущегоГода = НачалоГода(НачальноеЗначение);
	НачалоПрошлогоГода = НачалоГода(НачалоТекущегоГода - 1);
	СписокВыбора.Добавить(НачалоПрошлогоГода, (Формат(НачалоПрошлогоГода, "ДФ='yyyy'") + "..."));
	НачалоМесяцаЗаполнения = НачалоТекущегоГода;
	ЭлементПоУмолчанию = Неопределено;
	Пока Год(НачальноеЗначение) = Год(НачалоМесяцаЗаполнения) Цикл
		ДобавленныйЭлемент = СписокВыбора.Добавить(НачалоМесяцаЗаполнения, ПолучитьПериодСтрокой(НачалоМесяцаЗаполнения, ПолучитьИмяЭлементаПеречисленияПоЗначению(Периодичность)));
		Если НачальноеЗначение = НачалоМесяцаЗаполнения Тогда
			ЭлементПоУмолчанию = ДобавленныйЭлемент;
		КонецЕсли;
		НачалоМесяцаЗаполнения = ДобавитьИнтервал(НачалоМесяцаЗаполнения, Периодичность, 1);
	КонецЦикла;
	НачалоСледующегоГода = КонецГода(НачалоТекущегоГода) + 1;
	СписокВыбора.Добавить(НачалоСледующегоГода, (Формат(НачалоСледующегоГода, "ДФ='yyyy'") + "..."));
	
	ВыбранныйЭлемент = Форма.ВыбратьИзСписка(СписокВыбора, Элемент, ЭлементПоУмолчанию);
	
	Если ВыбранныйЭлемент = Неопределено Тогда
		Возврат;
	ИначеЕсли Год(ВыбранныйЭлемент.Значение) <> Год(НачальноеЗначение) Тогда
		ПериодНачалоВыбораИзСписка(Элемент, СтандартнаяОбработка, Форма, ДатаВПериоде, Периодичность, ВыбранныйЭлемент.Значение);
		Возврат;
	КонецЕсли;
	
	ДатаВПериоде = ВыбранныйЭлемент.Значение;
	Элемент.Значение  = ПолучитьПериодСтрокой(ДатаВПериоде, ПолучитьИмяЭлементаПеречисленияПоЗначению(Периодичность));
	
КонецПроцедуры

Процедура УстановитьИнтерфейс() Экспорт
	
	// если пользователю не задан интерфейс - установим интерфейс по умолчанию
	// с учетом использования управленческого учета
	ИнтерфейсПользователя = ПользователиИнформационнойБазы.ТекущийПользователь().ОсновнойИнтерфейс;
	Если ИнтерфейсПользователя = НеОпределено ИЛИ ИнтерфейсПользователя = Метаданные.Интерфейсы.Полный Тогда
		
		РаботаСДиалогами.ПереключитьПолныйИнтерфейс();
		
	КонецЕсли;
	
КонецПроцедуры

#КонецЕсли

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОРГАНИЗАЦИЯМ, КОНТРАГЕНТАМИ И ФИЗЛИЦАМИ
         
// Возвращает список узлов, при первом обращении создает список
//
Функция ЗначениеСпискаПрефиксовУзлов(СписокПрефиксовУзлов, Обновить=Ложь) Экспорт
	Если (СписокПрефиксовУзлов = Неопределено) Или Обновить Тогда
		СписокПрефиксовУзлов = ПолучитьСписокПрефиксовУзлов();
	КонецЕсли;
	Возврат СписокПрефиксовУзлов;
КонецФункции

// Формирует список префиксов узлов
//
Функция ПолучитьСписокПрефиксовУзлов()
	
	СписокПрефиксовУзлов = Новый СписокЗначений;
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ Различные
	               |	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	               |ИЗ
	               |	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
	
	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			СписокПрефиксовУзлов.Добавить(ВыборкаУзлов.Префикс);
		КонецЕсли;
	КонецЦикла;	
	
	Возврат СписокПрефиксовУзлов;
	
КонецФункции

// Формирует список головных организаций предприятия
//
Функция ПолучитьСписокГоловныхОрганизаций() Экспорт

	Запрос = Новый Запрос("ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка,
	|	Организации.Наименование КАК Наименование
	|ИЗ
	|	Справочник.Организации КАК Организации
	|
	|ГДЕ
	|	Организации.ГоловнаяОрганизация = &ПустаяОрганизация
	|	ИЛИ Организации.ГоловнаяОрганизация = Организации.Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	Наименование");

	Запрос.УстановитьПараметр("ПустаяОрганизация", Справочники.Организации.ПустаяСсылка());

	СписокОрганизаций = Новый СписокЗначений;
	Выборка = Запрос.Выполнить().Выбрать(); 

	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;

КонецФункции // ПолучитьСписокГоловныхОрганизаций()

// Формирует список обособленных структурных подразделений организации
//
Функция ПолучитьСписокОбособленныхПодразделенийОрганизации(Организация) Экспорт

	Запрос = Новый Запрос("ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка,
	|	Организации.Наименование
	|ИЗ
	|	Справочник.Организации КАК Организации
	|
	|ГДЕ
	|	Организации.ГоловнаяОрганизация = &Организация");
	Запрос.УстановитьПараметр("Организация", Организация);

	СписокОрганизаций = Новый СписокЗначений;
	Выборка = Запрос.Выполнить().Выбрать(); 

	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;

КонецФункции // ПолучитьСписокОбособленныхПодразделенийОрганизации()

// Формирует список структурных подразделений организации
//
Функция ПолучитьСписокСтруктурныхПодразделенийОрганизации(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	ПодразделенияОрганизаций.Ссылка,
	               |	ПодразделенияОрганизаций.Наименование
	               |ИЗ
	               |	Справочник.ПодразделенияОрганизаций КАК ПодразделенияОрганизаций
	               |ГДЕ
	               |	ПодразделенияОрганизаций.Владелец = &Организация
	               |	И ПодразделенияОрганизаций.ЯвляетсяСтруктурнымПодразделением = ИСТИНА
	               |	И ПодразделенияОрганизаций.ПометкаУдаления = ЛОЖЬ";
	Запрос.УстановитьПараметр("Организация", Организация);
	
	СписокОрганизаций = Новый СписокЗначений;
	Выборка = Запрос.Выполнить().Выбрать(); 

	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;
	
КонецФункции

// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является голвной
//
// Параметры
//  Организация – СправочникСсылка.Организации
//
// Возвращаемое значение:
//   СправочникСсылка.Организации
//
Функция ГоловнаяОрганизация(Организация) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация", Организация);
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ВЫБОР
	|		КОГДА Организации.ГоловнаяОрганизация = ЗНАЧЕНИЕ(Справочник.Организации.ПустаяСсылка)
	|			ТОГДА Организации.Ссылка
	|		ИНАЧЕ Организации.ГоловнаяОрганизация
	|	КОНЕЦ КАК ГоловнаяОрганизация
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация
	|";
	
	Выборка = Запрос.Выполнить().Выбрать();

	Если Выборка.Следующий() Тогда
		Возврат Выборка.ГоловнаяОрганизация;

	Иначе
		Возврат Организация;

	КонецЕсли;

КонецФункции // ГоловнаяОрганизация()

// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является головной
// Определение головной организации осуществляется в зависимости от настройки
// учетной политики по персоналу организаций "Вести учет по головной организации"
//
// Параметры
//  Организация – СправочникСсылка.Организации
//
// Возвращаемое значение:
//   СправочникСсылка.Организации
//
Функция ГоловнаяОрганизацияДляУчетаЗарплаты(Организация) Экспорт

	УчетнаяПолитикаПоПерсоналуОрганизации = глЗначениеПеременной("глУчетнаяПолитикаПоПерсоналуОрганизации");
	
	//Если УчетнаяПолитикаПоПерсоналуОрганизации[Организация].ВедениеУчетаПоГоловнойОрганизации Тогда
	//	Запрос = Новый Запрос;
	//	Запрос.УстановитьПараметр("Организация", Организация);
	//	Запрос.Текст = "
	//	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	//	|	ВЫБОР
	//	|		КОГДА Организации.ГоловнаяОрганизация = ЗНАЧЕНИЕ(Справочник.Организации.ПустаяСсылка)
	//	|			ТОГДА Организации.Ссылка
	//	|		ИНАЧЕ Организации.ГоловнаяОрганизация
	//	|	КОНЕЦ КАК ГоловнаяОрганизация
	//	|ИЗ
	//	|	Справочник.Организации КАК Организации
	//	|ГДЕ
	//	|	Организации.Ссылка = &Организация
	//	|";
	//	
	//	Выборка = Запрос.Выполнить().Выбрать();

	//	Если Выборка.Следующий() Тогда
	//		Возврат Выборка.ГоловнаяОрганизация;

	//	Иначе
	//		Возврат Организация;

	//	КонецЕсли;
	//Иначе
	//	Возврат Организация;
	//КонецЕсли;

	Возврат ГоловнаяОрганизация(Организация);
	
КонецФункции // ГоловнаяОрганизацияДляУчетаЗарплаты()

//  Функция формирует сведения об указанном ЮрФизЛице. К сведениям относятся -
// наименование, адрес, номер телефона, банковские реквизиты.
//
// Параметры: 
//  ЮрФизЛицо   - организация, контрагент или физическое лицо, о котором собираются сведения.
//  ДатаПериода - дата, на которую выбираются сведения о ЮрФизЛице.
//  ДляФизЛицаТолькоИнициалы - Для физ. лица выводить только инициалы имени и отчества.
//  БанковскийСчет - Банковский счет, если счет не основной.
//
// Возвращаемое значение:
//  Сведения - собранные сведения.
//
Функция СведенияОЮрФизЛице(ЮрФизЛицо, ДатаПериода = '20200101', ДляФизЛицаТолькоИнициалы = Истина, БанковскийСчет = Неопределено) Экспорт

	Сведения = Новый Структура("Представление, 
								|ПолноеНаименование, 
								|КодПоОКПО, 
								|РНН, 
								|БИН_ИИН,
								|КБЕ,  
								|Телефоны, 
								|ЮридическийАдрес, 
								|Банк, 
								|БИК, 
								|КоррСчет, 
								|НомерСчета, 
								|АдресБанка,
								|ДатаСвидетельстваПоНДС,
								|НомерСвидетельстваПоНДС,
								|СерияСвидетельстваПоНДС,
								|СвидетельствоПоНДС,
								|ЮрФизЛицо,
								|НомерРегистрацииВСтранеРезидентства,
								|СтранаРезидентстваУчастникТаможенногоСоюза");
	Запрос   = Новый Запрос;
	Данные   = Неопределено;

	Если ЮрФизЛицо = Неопределено ИЛИ ЮрФИзЛицо = NULL Тогда
		Возврат Сведения;
	ИначеЕсли ТипЗнч(ЮрФизЛицо) = Тип("Строка") Тогда
		Сведения.Вставить("Представление",      ЮрФизЛицо);
		Сведения.Вставить("ПолноеНаименование", ЮрФизЛицо);
		
		Возврат Сведения;
	КонецЕсли;

	Если БанковскийСчет = Неопределено ИЛИ БанковскийСчет.Пустая() Тогда
		ТекБанковскийСчет = ЮрФизЛицо.ОсновнойБанковскийСчет;
	Иначе
		ТекБанковскийСчет = БанковскийСчет;
	КонецЕсли;

	// Выберем основные сведения о контрагенте и банковском счете
	Если ТекБанковскийСчет = Неопределено ИЛИ ТекБанковскийСчет.БанкДляРасчетов.Пустая() Тогда
		ИмяРеквизитаБанка = "Банк";
	Иначе
		ИмяРеквизитаБанка = "БанкДляРасчетов";
	КонецЕсли;

	Если ТипЗнч(ЮрФизЛицо) = Тип("СправочникСсылка.Организации")  Тогда
		ИмяСправочника = "Организации";
		ИмяСправочникаПодразделенияОрганизаций = "Организации";
		ИмяРеквизитаБИН_ИИН = "ИдентификационныйНомер";
		ИмяРеквизитаНомерРегистрацииВСтранеРезидентства = "КодВСтранеРегистрации";
		ИмяРеквизитаСтранаРезидентстваУчастникТаможенногоСоюза = "СтранаРегистрации.УчастникТаможенногоСоюза";
		
		Запрос.УстановитьПараметр("ПарЮрФизЛицо", ЮрФизЛицо);

	ИначеЕсли ТипЗнч(ЮрФизЛицо) = Тип("СправочникСсылка.Контрагенты") Тогда
		ИмяСправочника = "Контрагенты";
		ИмяСправочникаПодразделенияОрганизаций = "Организации";
		ИмяРеквизитаБИН_ИИН = "ИдентификационныйКодЛичности";
		ИмяРеквизитаНомерРегистрацииВСтранеРезидентства = "НомерНалоговойРегистрацииВСтранеРезидентства";
		ИмяРеквизитаСтранаРезидентстваУчастникТаможенногоСоюза = "СтранаРезидентства.УчастникТаможенногоСоюза";
		
		Запрос.УстановитьПараметр("ПарЮрФизЛицо", ЮрФизЛицо);

	ИначеЕсли ТипЗнч(ЮрФизЛицо) = Тип("СправочникСсылка.ПодразделенияОрганизаций") Тогда
		ИмяСправочника = "Организации";
		ИмяСправочникаПодразделенияОрганизаций = "ПодразделенияОрганизаций";
		ИмяРеквизитаБИН_ИИН = "ИдентификационныйНомер";
		ИмяРеквизитаНомерРегистрацииВСтранеРезидентства = "КодВСтранеРегистрации";
		ИмяРеквизитаСтранаРезидентстваУчастникТаможенногоСоюза = "СтранаРегистрации.УчастникТаможенногоСоюза";
		
		Запрос.УстановитьПараметр("ПарСтруктурноеПодразделение", ЮрФизЛицо);
		Запрос.УстановитьПараметр("ПарЮрФизЛицо", ЮрФизЛицо.Владелец);
	Иначе
		Возврат Сведения;
	КонецЕсли;

	МетаданныеСправочника = Метаданные.Справочники[ИмяСправочника];

	Запрос.УстановитьПараметр("ПарБанковскийСчет", ТекБанковскийСчет);

	Если НЕ ЗначениеЗаполнено(ТекБанковскийСчет) Тогда
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	" + ИмяСправочникаПодразделенияОрганизаций + ".Представление           						 КАК Наименование,
		|	ВЫРАЗИТЬ(" + ИмяСправочникаПодразделенияОрганизаций + ".НаименованиеПолное КАК СТРОКА(1000)) КАК ПолноеНаименование,
		|	" + ИмяСправочникаПодразделенияОрганизаций + ".РНН                     						 КАК РНН,
		
		|	Организации." + ИмяРеквизитаНомерРегистрацииВСтранеРезидентства + "							КАК НомерРегистрацииВСтранеРезидентства,
		|	Организации." + ИмяРеквизитаСтранаРезидентстваУчастникТаможенногоСоюза + " 					КАК СтранаРезидентстваУчастникТаможенногоСоюза,
		|	Организации.КБЕ                     														КАК КБЕ,
		|	Организации.ЮрФизЛицо                     													КАК ЮрФизЛицо,
		|	" + ИмяСправочникаПодразделенияОрганизаций + "." + ИмяРеквизитаБИН_ИИН + "                  КАК БИН_ИИН,";
		Если МетаданныеСправочника.Реквизиты.Найти("ДатаСвидетельстваПоНДС") <> Неопределено Тогда
			Запрос.Текст = Запрос.Текст + "
			|	Организации.ДатаСвидетельстваПоНДС  КАК ДатаСвидетельстваПоНДС,
			|	Организации.НомерСвидетельстваПоНДС КАК НомерСвидетельстваПоНДС,
	        |	Организации.СерияСвидетельстваПоНДС КАК СерияСвидетельстваПоНДС,";
		КонецЕсли;
		
		Запрос.Текст = Запрос.Текст + "
		|	" + ИмяСправочникаПодразделенияОрганизаций + ".КодПоОКПО КАК КодПоОКПО,
        |	""""                                КАК НомерСчета,
		|	""""                                КАК Банк,
		|	""""                                КАК БИК,
		|	""""                                КАК БИКДоРеформыБанковскихСчетов,
		|	""""                                КАК КоррСчет,
		|	""""                                КАК АдресБанка
		|ИЗ
		|	Справочник." + ИмяСправочника + " КАК Организации " + ?(ИмяСправочникаПодразделенияОрганизаций = "ПодразделенияОрганизаций", 
																		", Справочник.ПодразделенияОрганизаций КАК ПодразделенияОрганизаций", "") + "
		|
		|ГДЕ
		|	Организации.Ссылка = &ПарЮрФизЛицо" + ?(ИмяСправочникаПодразделенияОрганизаций = "ПодразделенияОрганизаций", " И ПодразделенияОрганизаций.Ссылка = &ПарСтруктурноеПодразделение", "");
	Иначе
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	" + ИмяСправочникаПодразделенияОрганизаций + ".Представление           						 КАК Наименование,
		|	ВЫРАЗИТЬ(" + ИмяСправочникаПодразделенияОрганизаций + ".НаименованиеПолное КАК СТРОКА(1000)) КАК ПолноеНаименование,
		|	" + ИмяСправочникаПодразделенияОрганизаций + ".РНН                     						 КАК РНН,
		|	Организации.КБЕ                     														 КАК КБЕ,
		
		|	Организации." + ИмяРеквизитаНомерРегистрацииВСтранеРезидентства + "	КАК НомерРегистрацииВСтранеРезидентства,
		|	Организации." + ИмяРеквизитаСтранаРезидентстваУчастникТаможенногоСоюза + " КАК СтранаРезидентстваУчастникТаможенногоСоюза,
		|	" + ИмяСправочникаПодразделенияОрганизаций + "." + ИмяРеквизитаБИН_ИИН + "                  КАК БИН_ИИН,
		
		|	" + ИмяСправочникаПодразделенияОрганизаций + ".КодПоОКПО               						КАК КодПоОКПО,
		|	Организации.ЮрФизЛицо                     													КАК ЮрФизЛицо,";
		Если МетаданныеСправочника.Реквизиты.Найти("ДатаСвидетельстваПоНДС") <> Неопределено Тогда
			Запрос.Текст = Запрос.Текст + "
			|	Организации.ДатаСвидетельстваПоНДС  КАК ДатаСвидетельстваПоНДС,
			|	Организации.НомерСвидетельстваПоНДС КАК НОмерСвидетельстваПоНДС,
	        |	Организации.СерияСвидетельстваПоНДС КАК СерияСвидетельстваПоНДС,";
        КонецЕсли;
        Запрос.Текст = Запрос.Текст + "
       	|	БанковскиеСчета.НомерСчета                     	   КАК НомерСчета,
		|	БанковскиеСчета." + ИмяРеквизитаБанка + "          КАК Банк,
		|	БанковскиеСчета." + ИмяРеквизитаБанка + ".БИК      КАК БИК,
		|	БанковскиеСчета." + ИмяРеквизитаБанка + ".БИКДоРеформыБанковскихСчетов  КАК БИКДоРеформыБанковскихСчетов,
		|	БанковскиеСчета." + ИмяРеквизитаБанка + ".КоррСчет КАК КоррСчет,
		|	БанковскиеСчета." + ИмяРеквизитаБанка + ".Адрес    КАК АдресБанка
		|ИЗ
		|	Справочник." + ИмяСправочника + " КАК Организации,
		|	Справочник.БанковскиеСчета    КАК БанковскиеСчета" + ?(ИмяСправочникаПодразделенияОрганизаций = "ПодразделенияОрганизаций", 
																		", Справочник.ПодразделенияОрганизаций КАК ПодразделенияОрганизаций", "") + "
		|
		|ГДЕ
		|	Организации.Ссылка       = &ПарЮрФизЛицо
		|	И БанковскиеСчета.Ссылка = &ПарБанковскийСчет" + ?(ИмяСправочникаПодразделенияОрганизаций = "ПодразделенияОрганизаций", " И ПодразделенияОрганизаций.Ссылка = &ПарСтруктурноеПодразделение", "");;
	КонецЕсли;

	РезультатЗапроса = Запрос.Выполнить();
	Данные = РезультатЗапроса.Выбрать();
	Данные.Следующий();

	Сведения.Вставить("ПолноеНаименование", СокрЛП(Данные.ПолноеНаименование));

	Если Данные <> Неопределено Тогда
		Сведения.Вставить("Представление",    СокрЛП(Данные.Наименование));
		Сведения.Вставить("РНН",              Данные.РНН);
		Сведения.Вставить("БИН_ИИН",          Данные.БИН_ИИН);
		Сведения.Вставить("КБЕ",              Данные.КБЕ);
		Сведения.Вставить("ЮрФизЛицо",        Данные.ЮрФизЛицо);		
		Сведения.Вставить("КодПоОКПО", 		  Данные.КодПоОКПО);
		Сведения.Вставить("Телефоны",         УправлениеКонтактнойИнформацией.ПолучитьТелефонИзКонтактнойИнформации(ЮрФизЛицо));
		Сведения.Вставить("НомерСчета",       СокрЛП(Данные.НомерСчета));
		Сведения.Вставить("Банк",             Данные.Банк);
		Сведения.Вставить("НомерРегистрацииВСтранеРезидентства", Данные.НомерРегистрацииВСтранеРезидентства);
		Сведения.Вставить("СтранаРезидентстваУчастникТаможенногоСоюза", Данные.СтранаРезидентстваУчастникТаможенногоСоюза);		
		
		// С 07.06.2010 изменились коды банков.
		ДатаСведенийБИК = ?(ЗначениеЗаполнено(ДатаПериода), ДатаПериода, ТекущаяДата()); 
		Если ДатаСведенийБИК >= Дата(2010,06,07) Тогда
			Сведения.Вставить("БИК",              СокрЛП(Данные.БИК));
		Иначе	
			Сведения.Вставить("БИК",              СокрЛП(Данные.БИКДоРеформыБанковскихСчетов));
		КонецЕсли; 
			
		Сведения.Вставить("АдресБанка",       СокрЛП(Данные.АдресБанка));
		Сведения.Вставить("КоррСчет",         СокрЛП(Данные.КоррСчет));
		Сведения.Вставить("ЮридическийАдрес", УправлениеКонтактнойИнформацией.ПолучитьАдресИзКонтактнойИнформации(ЮрФизЛицо, "Юридический"));
		Сведения.Вставить("ФактическийАдрес", УправлениеКонтактнойИнформацией.ПолучитьАдресИзКонтактнойИнформации(ЮрФизЛицо, "Фактический"));
		Если РезультатЗапроса.Колонки.Найти("ДатаСвидетельстваПоНДС") <> Неопределено Тогда
			Сведения.Вставить("ДатаСвидетельстваПоНДС", Данные.ДатаСвидетельстваПоНДС);
			Сведения.Вставить("НомерСвидетельстваПоНДС", Данные.НомерСвидетельстваПоНДС);
			Сведения.Вставить("СерияСвидетельстаПоНДС", Данные.СерияСвидетельстваПоНДС);
	        Сведения.Вставить("СвидетельствоПоНДС", " серия " + Данные.СерияСвидетельстваПоНДС + ",  № " + Данные.НомерСвидетельстваПоНДС 
													 + ", от " + Формат(Данные.ДатаСвидетельстваПоНДС,"ДФ=dd.MM.yyyy"));
		КонецЕсли;
		Если НЕ ЗначениеЗаполнено(Сведения.ПолноеНаименование) Тогда
			Сведения.ПолноеНаименование = Сведения.Представление;
		КонецЕсли;
		
	КонецЕсли;

	Возврат Сведения;

КонецФункции // СведенияОЮрФизЛице()

// Извлекает сведения об организации по списку, переданному в параметре.
// 
// Параметры:
//  Показатели     - Список значений. Содержит в виде представлений перечень 
//                   сведений, которые надо получить. В первом элемент списка
//                   
// 
// Описание:
//  Функция умеет обрабатыать следующие мнемонические имена:
//  ФИОРук
//  РННРук
//  ФИОБух
//  РННБух
//
Функция ПолучитьСведенияОбОрганизации(Организация, ДатаЗначения, СписокПоказателей) Экспорт

	Перем ОргСведения;
	Перем Значение;

	// Структура, в которой будут возвращаться найденые значения
	ОргСведения = Новый Структура;
	
	ТекстЗапросаОтвЛица = "";
	ТекстЗапросаФИОФизЛиц = "";
	
	ТекстЗапросаОтвЛица = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	СтруктурнаяЕдиница,
	|	ОтветственноеЛицо,
	|	ФизическоеЛицо,
	|	Должность
	|ИЗ
	|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(
	|			&ДатаЗначения,
	|			СтруктурнаяЕдиница = &СтруктурнаяЕдиница
	|				И ОтветственноеЛицо = &ОтветственноеЛицо) КАК ОтветственныеЛицаОрганизацийСрезПоследних";
	
	
	ТекстЗапросаФИОФизЛиц = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ФизЛицо,
	|	Фамилия,
	|	Имя,
	|	Отчество,
	|	НеСклонятьФамилию
	|ИЗ
	|	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаЗначения, ФизЛицо = &ФизЛицо) КАК ФИОФизЛицСрезПоследних";

	
	Для каждого ЭлементСписка Из СписокПоказателей Цикл
		ИмяПоказателя = ЭлементСписка.Представление;
		Значение = Неопределено;

		Если Имяпоказателя = "ОКЭД" Тогда
			
			Значение = Организация.ОсновнойВидДеятельности.КодОКЭД;

		ИначеЕсли Имяпоказателя = "ПолноеНаименованиеОКЭД" Тогда
			
			Результат = Организация.ОсновнойВидДеятельности.ПолноеНаименование;
			Если НЕ ЗначениеЗаполнено(Результат) Тогда
				Результат = Организация.ОсновнойВидДеятельности.Наименование;
			КонецЕсли;
			Значение = Результат;

		ИначеЕсли ИмяПоказателя = "КодПоОКПО" Тогда
			
			Значение = Организация.КодПоОКПО;

		ИначеЕсли ИмяПоказателя = "АдрПочт" Тогда
			
			Данные = Новый Структура("Объект, Тип, Вид",Организация, Перечисления.ТипыКонтактнойИнформации.Адрес, Справочники.ВидыКонтактнойИнформации.АдресОрганизацииПочтовый);

			Результат = РегистрыСведений.КонтактнаяИнформация.Получить(Данные);

			Если Результат <> Неопределено Тогда
				Значение = Результат.Представление;
			Иначе
				Значение = ",,,,,,,,,";
			КонецЕсли;
			
			Если ПустаяСтрока(Значение) Тогда
				Значение = ",,,,,,,,,";
			КонецЕсли;
			
		ИначеЕсли ИмяПоказателя = "НаимЮЛПол" Тогда
			
			Значение = Организация.НаименованиеПолное;
			
		ИначеЕсли ИмяПоказателя = "РННЮЛ" Тогда
			
			Значение = Организация.РНН;
			
		ИначеЕсли ИмяПоказателя = "ИИН_БИН" Тогда
			
			Значение = Организация.ИдентификационныйНомер;

		ИначеЕсли ИмяПоказателя = "АдрЮР" Тогда
			
			Данные = Новый Структура("Объект, Тип, Вид", Организация, Перечисления.ТипыКонтактнойИнформации.Адрес, Справочники.ВидыКонтактнойИнформации.ЮрАдресОрганизации);

			Результат = РегистрыСведений.КонтактнаяИнформация.Получить(Данные);

			Если Результат <> Неопределено Тогда
				Значение = Результат.Представление;
			Иначе
				Значение = ",,,,,,,,,";
			КонецЕсли;
			
			Если ПустаяСтрока(Значение) Тогда
				Значение = ",,,,,,,,,";
			КонецЕсли;

		ИначеЕсли ИмяПоказателя = "АдрФакт" Тогда
			
			Данные = Новый Структура("Объект, Тип, Вид", Организация, Перечисления.ТипыКонтактнойИнформации.Адрес, Справочники.ВидыКонтактнойИнформации.ФактАдресОрганизации);

			Результат = РегистрыСведений.КонтактнаяИнформация.Получить(Данные);

			Если Результат <> Неопределено Тогда
				Значение = Результат.Представление;
			Иначе
				Значение = ",,,,,,,,,";
			КонецЕсли;
			
			Если ПустаяСтрока(Значение) Тогда
				Значение = ",,,,,,,,,";
			КонецЕсли;
	
		ИначеЕсли ИмяПоказателя = "ТелОрганизации" Тогда
			
			Данные = Новый Структура("Объект, Тип, Вид", Организация, Перечисления.ТипыКонтактнойИнформации.Телефон, Справочники.ВидыКонтактнойИнформации.ТелефонОрганизации);

			Результат = РегистрыСведений.КонтактнаяИнформация.Получить(Данные);

			Если Результат <> Неопределено Тогда
				Значение = Результат.Представление;
			Иначе
				Значение = ",,,,,,,,,";
			КонецЕсли;
			
			Если ПустаяСтрока(Значение) Тогда
				Значение = ",,,,,,,,,";
			КонецЕсли;

		ИначеЕсли ИмяПоказателя = "ФИОРук" ИЛИ ИмяПоказателя = "ФИОРукКраткое" Тогда
			
			Запрос = Новый Запрос;
			Запрос.УстановитьПараметр("ДатаЗначения", ДатаЗначения);
			Запрос.УстановитьПараметр("СтруктурнаяЕдиница",Организация);
			Запрос.УстановитьПараметр("ОтветственноеЛицо", Перечисления.ОтветственныеЛицаОрганизаций.Руководитель);
			Запрос.Текст = ТекстЗапросаОтвЛица;
			ОтвЛица = Запрос.Выполнить().Выгрузить();
			
			Результат = ОтвЛица.Найти(Перечисления.ОтветственныеЛицаОрганизаций.Руководитель);

			Если Результат <> Неопределено Тогда
				
				ЗапросФИОФизЛиц = Новый Запрос;
				ЗапросФИОФизЛиц.УстановитьПараметр("ДатаЗначения", ДатаЗначения);
				ЗапросФИОФизЛиц.УстановитьПараметр("ФизЛицо", Результат.ФизическоеЛицо);
				ЗапросФИОФизЛиц.Текст = ТекстЗапросаФИОФизЛиц;
				
				ФИОФизЛиц = ЗапросФИОФизЛиц.Выполнить().Выгрузить();
				
				Если ФИОФизЛиц.Количество() <> 0 Тогда
					ФИОФизЛиц = ФИОФизЛиц[0];
					Если ИмяПоказателя = "ФИОРук" Тогда
						Значение = ФИОФизЛиц.Фамилия + ?(НЕ ПустаяСтрока(ФИОФизЛиц.Имя), " " + ФИОФизЛиц.Имя, "") + ?(НЕ ПустаяСтрока(ФИОФизЛиц.Отчество), " " + ФИОФизЛиц.Отчество, "");
					Иначе // Краткое
						Значение = ФИОФизЛиц.Фамилия + ?(НЕ ПустаяСтрока(ФИОФизЛиц.Имя), " " + Лев(ФИОФизЛиц.Имя, 1) + ".", "") + ?(НЕ ПустаяСтрока(ФИОФизЛиц.Отчество), " " + Лев(ФИОФизЛиц.Отчество, 1) + ".", "");	
					КонецЕсли;
				Иначе
					Значение = Результат.ФизическоеЛицо.Наименование;
				КонецЕсли;
			КонецЕсли;

		ИначеЕсли ИмяПоказателя = "РННРук" Тогда

			Запрос = Новый Запрос;
			Запрос.УстановитьПараметр("ДатаЗначения", ДатаЗначения);
			Запрос.УстановитьПараметр("СтруктурнаяЕдиница",Организация);
			Запрос.УстановитьПараметр("ОтветственноеЛицо", Перечисления.ОтветственныеЛицаОрганизаций.Руководитель);
			Запрос.Текст = ТекстЗапросаОтвЛица;
			ОтвЛица = Запрос.Выполнить().Выгрузить();

			Результат = ОтвЛица.Найти(Перечисления.ОтветственныеЛицаОрганизаций.Руководитель);

			Если Результат <> Неопределено Тогда
				Значение = Результат.ФизическоеЛицо.РНН;
			КонецЕсли;

		ИначеЕсли ИмяПоказателя = "ФИОБух" ИЛИ ИмяПоказателя = "ФИОБухКраткое" Тогда
			
			Запрос = Новый Запрос;
			Запрос.УстановитьПараметр("ДатаЗначения", ДатаЗначения);
			Запрос.УстановитьПараметр("СтруктурнаяЕдиница",Организация);
			Запрос.УстановитьПараметр("ОтветственноеЛицо", Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер);
			Запрос.Текст = ТекстЗапросаОтвЛица;
			ОтвЛица = Запрос.Выполнить().Выгрузить();

			Результат = ОтвЛица.Найти(Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер);

			Если Результат <> Неопределено Тогда
				
				ЗапросФИОФизЛиц = Новый Запрос;
				ЗапросФИОФизЛиц.УстановитьПараметр("ДатаЗначения", ДатаЗначения);
				ЗапросФИОФизЛиц.УстановитьПараметр("ФизЛицо", Результат.ФизическоеЛицо);
				ЗапросФИОФизЛиц.Текст = ТекстЗапросаФИОФизЛиц;
				
				ФИОФизЛиц = ЗапросФИОФизЛиц.Выполнить().Выгрузить();
				
				Если ФИОФизЛиц.Количество() <> 0 Тогда
					ФИОФизЛиц = ФИОФизЛиц[0];
					Если ИмяПоказателя = "ФИОБух" Тогда
						Значение = ФИОФизЛиц.Фамилия + ?(НЕ ПустаяСтрока(ФИОФизЛиц.Имя), " " + ФИОФизЛиц.Имя, "") + ?(НЕ ПустаяСтрока(ФИОФизЛиц.Отчество), " " + ФИОФизЛиц.Отчество, "");
					Иначе // Краткое
						Значение = ФИОФизЛиц.Фамилия + ?(НЕ ПустаяСтрока(ФИОФизЛиц.Имя), " " + Лев(ФИОФизЛиц.Имя, 1) + ".", "") + ?(НЕ ПустаяСтрока(ФИОФизЛиц.Отчество), " " + Лев(ФИОФизЛиц.Отчество, 1) + ".", "");	
					КонецЕсли;
				Иначе
					Значение = Результат.ФизическоеЛицо.Наименование;
				КонецЕсли;
			КонецЕсли;

		ИначеЕсли ИмяПоказателя = "РННБух" Тогда
			
			Запрос = Новый Запрос;
			Запрос.УстановитьПараметр("ДатаЗначения", ДатаЗначения);
			Запрос.УстановитьПараметр("СтруктурнаяЕдиница",Организация);
			Запрос.УстановитьПараметр("ОтветственноеЛицо", Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер);
			Запрос.Текст = ТекстЗапросаОтвЛица;
			ОтвЛица = Запрос.Выполнить().Выгрузить();

			Результат = ОтвЛица.Найти(Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер);

			Если Результат <> Неопределено Тогда
				Значение = Результат.ФизическоеЛицо.РНН;
			КонецЕсли;


		Иначе
			Значение = Неопределено;
		КонецЕсли;

		ОргСведения.Вставить(ИмяПоказателя, Значение);

	КонецЦикла;

	Возврат ОргСведения;

КонецФункции // ПолучитьСведенияОбОрганизации()

Функция ПолучитьАдресныеСведенияОрганизации(Организация) Экспорт
	
	АдресныеСведения = Новый Структура;
	
	// Фактический адрес
	// Код по КАТО
	Запрос = Новый Запрос();
	Запрос.УстановитьПараметр("Организация", Организация);
	ПолеОрганизация = ?(ТипЗнч(Организация) = Тип("СправочникСсылка.Организации"), "Организации", "ФизическиеЛица");
	
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Организации.Ссылка,
		|	Организации.Наименование КАК ОрганизацияНаименование
		|ПОМЕСТИТЬ ВТ_Организация
		|ИЗ
		|	Справочник." + ПолеОрганизация + " КАК Организации
		|ГДЕ
		|	Организации.Ссылка = &Организация
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Организация.ОрганизацияНаименование КАК ОрганизацияНаименование,
		|	ВЫБОР
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ИнформАдресФизЛица.Ссылка ЕСТЬ NULL 
		|			ТОГДА ЮрАдресОрганизации.Представление
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ЮрАдресОрганизации.Ссылка ЕСТЬ NULL 
		|			ТОГДА ИнформАдресФизЛица.Представление
		|		ИНАЧЕ ФактАдресОрганизации.Представление
		|	КОНЕЦ КАК АдресПредставление,
		|	ВЫБОР
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ИнформАдресФизЛица.Ссылка ЕСТЬ NULL 
		|			ТОГДА ЮрАдресОрганизации.Область
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ЮрАдресОрганизации.Ссылка ЕСТЬ NULL 
		|			ТОГДА ИнформАдресФизЛица.Область
		|		ИНАЧЕ ФактАдресОрганизации.Область
		|	КОНЕЦ КАК Область,
		|	ВЫБОР
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ИнформАдресФизЛица.Ссылка ЕСТЬ NULL 
		|			ТОГДА ЮрАдресОрганизации.Район
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ЮрАдресОрганизации.Ссылка ЕСТЬ NULL 
		|			ТОГДА ИнформАдресФизЛица.Район
		|		ИНАЧЕ ФактАдресОрганизации.Район
		|	КОНЕЦ КАК Район,
		|	ВЫБОР
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ИнформАдресФизЛица.Ссылка ЕСТЬ NULL 
		|			ТОГДА ЮрАдресОрганизации.Город
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ЮрАдресОрганизации.Ссылка ЕСТЬ NULL 
		|			ТОГДА ИнформАдресФизЛица.Город
		|		ИНАЧЕ ФактАдресОрганизации.Город
		|	КОНЕЦ КАК Город,
		|	ВЫБОР
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ИнформАдресФизЛица.Ссылка ЕСТЬ NULL 
		|			ТОГДА ЮрАдресОрганизации.НаселенныйПункт
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ЮрАдресОрганизации.Ссылка ЕСТЬ NULL 
		|			ТОГДА ИнформАдресФизЛица.НаселенныйПункт
		|		ИНАЧЕ ФактАдресОрганизации.НаселенныйПункт
		|	КОНЕЦ КАК НаселенныйПункт,
		|	ВЫБОР
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ИнформАдресФизЛица.Ссылка ЕСТЬ NULL 
		|			ТОГДА ЮрАдресОрганизации.Улица
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ЮрАдресОрганизации.Ссылка ЕСТЬ NULL 
		|			ТОГДА ИнформАдресФизЛица.Улица
		|		ИНАЧЕ ФактАдресОрганизации.Улица
		|	КОНЕЦ КАК Улица,
		|	ВЫБОР
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ИнформАдресФизЛица.Ссылка ЕСТЬ NULL 
		|			ТОГДА ЮрАдресОрганизации.Дом
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ЮрАдресОрганизации.Ссылка ЕСТЬ NULL 
		|			ТОГДА ИнформАдресФизЛица.Дом
		|		ИНАЧЕ ФактАдресОрганизации.Дом
		|	КОНЕЦ КАК Дом,
		|	ВЫБОР
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ИнформАдресФизЛица.Ссылка ЕСТЬ NULL 
		|			ТОГДА ИСТИНА
		|		КОГДА ФактАдресОрганизации.Ссылка ЕСТЬ NULL 
		|				И ЮрАдресОрганизации.Ссылка ЕСТЬ NULL 
		|			ТОГДА ИСТИНА
		|		ИНАЧЕ ЛОЖЬ
		|	КОНЕЦ КАК ЮридическийАдрес
		|ИЗ
		|	ВТ_Организация КАК Организация
		|		ЛЕВОЕ СОЕДИНЕНИЕ (ВЫБРАТЬ
		|			КонтактнаяИнформация.Представление КАК Представление,
		|			КонтактнаяИнформация.Поле2 КАК Область,
		|			КонтактнаяИнформация.Поле3 КАК Район,
		|			КонтактнаяИнформация.Поле4 КАК Город,
		|			КонтактнаяИнформация.Поле5 КАК НаселенныйПункт,
		|			КонтактнаяИнформация.Поле6 КАК Улица,
		|			КонтактнаяИнформация.Поле7 КАК Дом,
		|			Организация.Ссылка КАК Ссылка
		|		ИЗ
		|			ВТ_Организация КАК Организация
		|				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.КонтактнаяИнформация КАК КонтактнаяИнформация
		|				ПО Организация.Ссылка = КонтактнаяИнформация.Объект
		|					И (КонтактнаяИнформация.Тип = ЗНАЧЕНИЕ(Перечисление.ТипыКонтактнойИнформации.Адрес))
		|					И (КонтактнаяИнформация.Вид = ЗНАЧЕНИЕ(Справочник.ВидыКонтактнойИнформации.ЮрАдресОрганизации))) КАК ЮрАдресОрганизации
		|		ПО Организация.Ссылка = ЮрАдресОрганизации.Ссылка
		|		ЛЕВОЕ СОЕДИНЕНИЕ (ВЫБРАТЬ
		|			КонтактнаяИнформация.Представление КАК Представление,
		|			КонтактнаяИнформация.Поле2 КАК Область,
		|			КонтактнаяИнформация.Поле3 КАК Район,
		|			КонтактнаяИнформация.Поле4 КАК Город,
		|			КонтактнаяИнформация.Поле5 КАК НаселенныйПункт,
		|			КонтактнаяИнформация.Поле6 КАК Улица,
		|			КонтактнаяИнформация.Поле7 КАК Дом,
		|			Организация.Ссылка КАК Ссылка
		|		ИЗ
		|			ВТ_Организация КАК Организация
		|				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.КонтактнаяИнформация КАК КонтактнаяИнформация
		|				ПО Организация.Ссылка = КонтактнаяИнформация.Объект
		|					И (КонтактнаяИнформация.Тип = ЗНАЧЕНИЕ(Перечисление.ТипыКонтактнойИнформации.Адрес))
		|					И (КонтактнаяИнформация.Вид = ЗНАЧЕНИЕ(Справочник.ВидыКонтактнойИнформации.ФактАдресОрганизации))) КАК ФактАдресОрганизации
		|		ПО Организация.Ссылка = ФактАдресОрганизации.Ссылка
		|		ЛЕВОЕ СОЕДИНЕНИЕ (ВЫБРАТЬ
		|			КонтактнаяИнформация.Представление КАК Представление,
		|			КонтактнаяИнформация.Поле2 КАК Область,
		|			КонтактнаяИнформация.Поле3 КАК Район,
		|			КонтактнаяИнформация.Поле4 КАК Город,
		|			КонтактнаяИнформация.Поле5 КАК НаселенныйПункт,
		|			КонтактнаяИнформация.Поле6 КАК Улица,
		|			КонтактнаяИнформация.Поле7 КАК Дом,
		|			Организация.Ссылка КАК Ссылка
		|		ИЗ
		|			ВТ_Организация КАК Организация
		|				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.КонтактнаяИнформация КАК КонтактнаяИнформация
		|				ПО Организация.Ссылка = КонтактнаяИнформация.Объект
		|					И (КонтактнаяИнформация.Тип = ЗНАЧЕНИЕ(Перечисление.ТипыКонтактнойИнформации.Адрес))
		|					И (КонтактнаяИнформация.Вид = ЗНАЧЕНИЕ(Справочник.ВидыКонтактнойИнформации.ИнформАдресФизЛица))) КАК ИнформАдресФизЛица
		|		ПО Организация.Ссылка = ИнформАдресФизЛица.Ссылка";
		
	Выборка = Запрос.Выполнить().Выбрать();
	
	АдресОрганизации = "";
	КодТерритории = "";
	ИнформАдрес = "";
	
	Если Выборка.Следующий() Тогда
		
		АдресОрганизации = СокрЛП(Выборка.Область) +  
										?(Выборка.Район <> "", ", " + СокрЛП(Выборка.Район), "") + 
										?(Выборка.Город <> "", ", " + СокрЛП(Выборка.Город), "") + 
										?(Выборка.НаселенныйПункт <> "", ", " + СокрЛП(Выборка.НаселенныйПункт), "");
										
		ИнформАдрес = СокрЛП(Выборка.Область) +  
										?(Выборка.Район <> "", ", " + СокрЛП(Выборка.Район), "") + 
										?(Выборка.Город <> "", ", " + СокрЛП(Выборка.Город), "") + 
										?(Выборка.НаселенныйПункт <> "", ", " + СокрЛП(Выборка.НаселенныйПункт), "") +
										?(Выборка.Улица <> "", ", " + СокрЛП(Выборка.Улица), "") + 
										?(Выборка.Дом <> "", ", " +   СокрЛП(Выборка.Дом), "");

		НаименованиеТерритории = ?(Выборка.НаселенныйПункт = "", СокрЛП(Выборка.Город), СокрЛП(Выборка.НаселенныйПункт));														
		ТипАдресногоЭлемента = ?(Выборка.НаселенныйПункт = "", 3, 5);

		// Если территория выбиралась из адресного классификатора, то сокращения предопределены
		НаименованиеТерритории = СокрЛП(СтрЗаменить(НаименованиеТерритории, ?(ТипАдресногоЭлемента = 3,"г.", "с."), ""));	
		
		// заменим спецсимволы
		НаименованиеТерритории = СтрЗаменить(НаименованиеТерритории, "~", "~~");
		НаименованиеТерритории = СтрЗаменить(НаименованиеТерритории, "%", "~%");
		НаименованиеТерритории = СтрЗаменить(НаименованиеТерритории, "_", "~_");
		НаименованиеТерритории = СтрЗаменить(НаименованиеТерритории, "[", "~[");
		НаименованиеТерритории = СтрЗаменить(НаименованиеТерритории, "-", "~-");
		НаименованиеТерритории = НаименованиеТерритории + "%";
		
		Запрос.УстановитьПараметр("Наименование", НаименованиеТерритории);
		Запрос.УстановитьПараметр("ТипАдресногоЭлемента", ТипАдресногоЭлемента);
		
		Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	АдресныйКлассификатор.Код,
		|	АдресныйКлассификатор.Наименование,
		|	АдресныйКлассификатор.АльтернативныеНазвания
		|ИЗ
		|	РегистрСведений.АдресныйКлассификатор КАК АдресныйКлассификатор
		|ГДЕ
		|	АдресныйКлассификатор.ТипАдресногоЭлемента = &ТипАдресногоЭлемента
		|	И АдресныйКлассификатор.Наименование ПОДОБНО &Наименование";
		
		ВыборкаКод = Запрос.Выполнить().Выбрать();
		Если ВыборкаКод.Следующий() Тогда
			КодТерритории = ВыборкаКод.Код;
		КонецЕсли;
		
	КонецЕсли;
	
	АдресныеСведения.Вставить("ИнформАдрес", ИнформАдрес); // Адрес для информирования физ. лица
	АдресныеСведения.Вставить("КодКато", Строка(КодТерритории)); // Код КАТО
	АдресныеСведения.Вставить("АдресОрганизации", АдресОрганизации); // Фактический адрес
	

	Возврат АдресныеСведения;
	
КонецФункции

// Возвращает структуру данных со сводным описанием контрагента
//
// Параметры: 
//  СписокСведений - список значений со значенийми параметров организации
//   СписокСведений формируется функцией СведенияОЮрФизЛице
//  Список         - список запрашиваемых параметров организаиии
//  СПрефиксом     - Признак выводить или нет префикс параметра организации
//
// Возвращаемое значение:
//  Строка - описатель организации / контрагента / физ.лица.
//
Функция ОписаниеОрганизации(СписокСведений, Список = "", СПрефиксом = Истина, Дата = Неопределено, КодЯзыка = "ru") Экспорт
	
	Если ПустаяСтрока(Список) Тогда
		Список = "ПолноеНаименование,ИдентификационныйНомер,ЮридическийАдрес,Телефоны,НомерСчета,Банк,БИК,КоррСчет";
	КонецЕсли; 
	
	ВыводитьРНН = Истина;
	
	Если Не Дата = Неопределено Тогда 
		ДатаПрекращенияВыводаРНН 	= Константы.ДатаПрекращенияВыводаРННВПервичныхДокументах.Получить();
		
		ВыводитьРНН = НЕ ЗначениеЗаполнено(ДатаПрекращенияВыводаРНН) ИЛИ Дата<ДатаПрекращенияВыводаРНН;
	КонецЕсли;
	
	Результат = "";

	СоответствиеПараметров = Новый Соответствие();
	СоответствиеПараметров.Вставить("ПолноеНаименование", " ");
	
	Если Найти(Список, "ИдентификационныйНомер") > 0 Тогда 
		Если ВыводитьРНН Тогда 
			Список = СтрЗаменить(Список, "ИдентификационныйНомер", "РНН");
		Иначе
			Список = СтрЗаменить(Список, "ИдентификационныйНомер", "БИН_ИИН");			
		КонецЕсли;		
	КонецЕсли;
	
	СоответствиеПараметров.Вставить("РНН",            	  "ru = "" РНН ""; kz = "" СТН """);
	СоответствиеПараметров.Вставить("БИН_ИИН",            "ru = "" БИН / ИИН ""; kz = "" БСН / ЖСН """);

	СоответствиеПараметров.Вставить("ЮридическийАдрес",   " ");
	СоответствиеПараметров.Вставить("Телефоны",           "ru = "" тел.: ""; kz = "" тел.: """);
	СоответствиеПараметров.Вставить("НомерСчета",         "ru = """"; kz = """"");
	СоответствиеПараметров.Вставить("Банк",               "ru = "" в банке ""; kz = "" банктегі """);
	СоответствиеПараметров.Вставить("БИК",                "ru = "" БИК ""; kz = "" БСК """);
	СоответствиеПараметров.Вставить("КоррСчет",           "ru = "" к/с ""; kz = "" к/ш """);
	СоответствиеПараметров.Вставить("КодПоОКПО",          "ru = "" Код по ОКПО ""; kz = "" ҚҰЖЖ бойынша коды """);
	СоответствиеПараметров.Вставить("НомерРегистрацииВСтранеРезидентства", "ru = "" ИНН/УНП ""; kz = "" ИНН/УНП """); // Учетные данные контрагентов из РФ и РБ

	ЧислоПараметров = СтрЧислоВхождений(Список, ",");

	Для Счетчик = 1 по ЧислоПараметров Цикл

		ПозЗапятой = Найти(Список, ",");

		Если ПозЗапятой > 0  Тогда
			ИмяПараметра = Лев(Список, ПозЗапятой - 1);
			Список = Сред(Список, ПозЗапятой + 1, СтрДлина(Список));

			Попытка
				СтрокаДополнения = "";
				СписокСведений.Свойство(ИмяПараметра, СтрокаДополнения);

				Если ПустаяСтрока(СтрокаДополнения) Тогда
					Продолжить;
				КонецЕсли;

				Префикс = СоответствиеПараметров[ИмяПараметра];
				Если Не ПустаяСтрока(Результат)  Тогда
					Результат = Результат + ",";
				КонецЕсли; 

				Если ИмяПараметра = "Банк" И КодЯзыка = "kz" Тогда 
					Результат = Результат + " " + СтрокаДополнения + ?(СПрефиксом = Истина, НСтр(Префикс, КодЯзыка), "");
				Иначе 
					Результат = Результат + ?(СПрефиксом = Истина, НСтр(Префикс, КодЯзыка), "") + СтрокаДополнения;
				КонецЕсли;

			Исключение

				Сообщить("Не удалось определить значение параметра организации: " + ИмяПараметра, СтатусСообщения.Внимание);

			КонецПопытки;

		КонецЕсли; 

	КонецЦикла;

	Возврат Результат;
	
КонецФункции // ОписаниеОрганизации()

//Функция возвращает информацию об ответственных лицах организации и их должностях 
//
Функция ОтветственныеЛицаОрганизаций(Организация, ДатаСреза, Исполнитель = Неопределено, Результат = Неопределено) Экспорт

	Результат = Новый Структура("Руководитель, 
								|РуководительФИзЛицо,
								|РуководительДолжность, 
								|РуководительДолжностьСсылка,
								|ГлавныйБухгалтер, 
								|ГлавныйБухгалтерФИзЛицо,
								|ГлавныйБухгалтерДолжность, 
								|ГлавныйБухгалтерДолжностьСсылка,
								|ГлавныйБухгалтерДляПодписиБанковскихДокументов,
								|ГлавныйБухгалтерДляПодписиБанковскихДокументовДолжность,
								|УполномоченныйПодписыватьСчетаФактурыЗаГлавногоБухгалтера,
								|УполномоченныйПодписыватьСчетаФактурыЗаГлавногоБухгалтераДолжность,
								|УполномоченныйПодписыватьСчетаФактурыЗаРуководителя,
								|УполномоченныйПодписыватьСчетаФактурыЗаРуководителяДолжность,
								|Кассир, 
								|КассирФИзЛицо,								
								|КассирДолжность, 
								|КассирДолжностьСсылка,
								|Исполнитель, 
								|ИсполнительДолжность, 
								|ОтветственныйЗаРегистры,
								|ОтветственныйЗаРегистрыДолжность,
								|РуководительКадровойСлужбы,
								|РуководительКадровойСлужбыДолжность,
								|РуководительКадровойСлужбыДолжностьСсылка,
								|РуководительКадровойСлужбыФизЛицо");

	Если Организация <> Неопределено Тогда

		ЗапросПоЛицам = Новый Запрос();
		ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
		ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
		ЗапросПоЛицам.Текст = "
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ОтветственныеЛицаОрганизацииСрезПоследних.ОтветственноеЛицо,
		|	ОтветственныеЛицаОрганизацииСрезПоследних.Должность.Наименование КАК Должность,
		|	ОтветственныеЛицаОрганизацииСрезПоследних.Должность КАК ДолжностьСсылка,
		|   ОтветственныеЛицаОрганизацииСрезПоследних.ФизическоеЛицо КАК ФизЛицо,
		|	ВЫБОР 
		|		КОГДА (ФИОФизЛицСрезПоследних.ФизЛицо) ЕСТЬ NULL  
		|			ТОГДА ОтветственныеЛицаОрганизацииСрезПоследних.ФизическоеЛицо.Наименование 
		|		ИНАЧЕ ФИОФизЛицСрезПоследних.Фамилия + ВЫБОР 
		|													КОГДА ПОДСТРОКА(ФИОФизЛицСрезПоследних.Имя, 1, 1) <> """" 
		|														ТОГДА "" "" + ПОДСТРОКА(ФИОФизЛицСрезПоследних.Имя, 1, 1) + ""."" 
		|													ИНАЧЕ """" 
		|												КОНЕЦ + ВЫБОР 
		|															КОГДА ПОДСТРОКА(ФИОФизЛицСрезПоследних.Отчество, 1, 1) <> """" 
		|																ТОГДА "" "" + ПОДСТРОКА(ФИОФизЛицСрезПоследних.Отчество, 1, 1) + ""."" 
		|															ИНАЧЕ """" 
		|														КОНЕЦ 
		|	КОНЕЦ КАК ФИОПолное
		|ИЗ
		|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(
		|					&ДатаСреза, 
		|					СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизацииСрезПоследних
		|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
		|		ПО ОтветственныеЛицаОрганизацииСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо";
		Выборка = ЗапросПоЛицам.Выполнить().Выбрать();

		Пока Выборка.Следующий() Цикл

			Если Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда
				Результат.Руководитель            		= Выборка.ФИОПолное;
				Результат.РуководительФизЛицо     		= Выборка.ФизЛицо;
				Результат.РуководительДолжность   		= Выборка.Должность;
				Результат.РуководительДолжностьСсылка   = Выборка.ДолжностьСсылка;
			ИначеЕсли Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда
				Результат.ГлавныйБухгалтер        			= Выборка.ФИОПолное;
				Результат.ГлавныйБухгалтерФизЛицо    		= Выборка.ФизЛицо;
				Результат.ГлавныйБухгалтерДолжность 		= Выборка.Должность;
				Результат.ГлавныйБухгалтерДолжностьСсылка   = Выборка.ДолжностьСсылка;
			ИначеЕсли Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтерДляПодписиБанковскихДокументов Тогда
				Результат.ГлавныйБухгалтерДляПодписиБанковскихДокументов		  = Выборка.ФИОПолное;
				Результат.ГлавныйБухгалтерДляПодписиБанковскихДокументовДолжность = Выборка.Должность;
			ИначеЕсли Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Кассир Тогда
				Результат.Кассир                  = Выборка.ФИОПолное;
				Результат.КассирФизЛицо 		  = Выборка.ФизЛицо;
				Результат.КассирДолжность         = Выборка.Должность;
				Результат.КассирДолжностьСсылка   = Выборка.ДолжностьСсылка;
			ИначеЕсли Метаданные.Перечисления.ОтветственныеЛицаОрганизаций.ЗначенияПеречисления.Найти("ОтветственныйЗаНалоговыеРегистры") <> Неопределено
						И Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ОтветственныйЗаНалоговыеРегистры Тогда
				Результат.ОтветственныйЗаРегистры = Выборка.ФИОПолное;
				Результат.ОтветственныйЗаРегистрыДолжность = Выборка.Должность;
			ИначеЕсли Метаданные.Перечисления.ОтветственныеЛицаОрганизаций.ЗначенияПеречисления.Найти("РуководительКадровойСлужбы") <> Неопределено
						И Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.РуководительКадровойСлужбы Тогда
				Результат.РуководительКадровойСлужбы 				= Выборка.ФИОПолное;
				Результат.РуководительКадровойСлужбыДолжность 		= Выборка.Должность;
				Результат.РуководительКадровойСлужбыДолжностьСсылка	= Выборка.ДолжностьСсылка;
				Результат.РуководительКадровойСлужбыФизЛицо			= Выборка.ФизЛицо;
			ИначеЕсли Метаданные.Перечисления.ОтветственныеЛицаОрганизаций.ЗначенияПеречисления.Найти("УполномоченныйПодписыватьСчетаФактурыЗаГлавногоБухгалтера") <> Неопределено 
						И Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.УполномоченныйПодписыватьСчетаФактурыЗаГлавногоБухгалтера Тогда
				Результат.УполномоченныйПодписыватьСчетаФактурыЗаГлавногоБухгалтера        	 = Выборка.ФИОПолное;
				Результат.УполномоченныйПодписыватьСчетаФактурыЗаГлавногоБухгалтераДолжность = Выборка.Должность;
			ИначеЕсли Метаданные.Перечисления.ОтветственныеЛицаОрганизаций.ЗначенияПеречисления.Найти("УполномоченныйПодписыватьСчетаФактурыЗаРуководителя") <> Неопределено
						И Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.УполномоченныйПодписыватьСчетаФактурыЗаРуководителя Тогда
				Результат.УполномоченныйПодписыватьСчетаФактурыЗаРуководителя        	 = Выборка.ФИОПолное;
				Результат.УполномоченныйПодписыватьСчетаФактурыЗаРуководителяДолжность   = Выборка.Должность;
			КонецЕсли;

		КонецЦикла;

		Если Исполнитель <> Неопределено И Метаданные.РегистрыСведений.Найти("РаботникиОрганизаций") <> Неопределено тогда

			ЗапросПоИсполнителям = Новый Запрос();
			ЗапросПоИсполнителям.УстановитьПараметр("Организация",         ?(ТипЗнч(Организация) = Тип("СправочникСсылка.ПодразделенияОрганизаций"), Организация.Владелец, Организация));
			ЗапросПоИсполнителям.УстановитьПараметр("ГоловнаяОрганизация", ГоловнаяОрганизацияДляУчетаЗарплаты(?(ТипЗнч(Организация) = Тип("СправочникСсылка.ПодразделенияОрганизаций"), Организация.Владелец, Организация)));
			ЗапросПоИсполнителям.УстановитьПараметр("ДатаСреза",           ДатаСреза);
			ЗапросПоИсполнителям.УстановитьПараметр("Исполнитель",         Исполнитель);
			ЗапросПоИсполнителям.УстановитьПараметр("ВнутреннееСовместительство", Перечисления.ВидыЗанятостиВОрганизации.ВнутреннееСовместительство);
			ЗапросПоИсполнителям.Текст = 
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	РаботникиОрганизацииСрезПоследних.Должность.Наименование КАК Должность,
			|	ВЫБОР 
			|		КОГДА (ФИОФизЛицСрезПоследних.ФизЛицо) ЕСТЬ NULL  
			|			ТОГДА РаботникиОрганизацииСрезПоследних.Сотрудник.Физлицо.Наименование 
			|		ИНАЧЕ ФИОФизЛицСрезПоследних.Фамилия + ВЫБОР 
			|													КОГДА ПОДСТРОКА(ФИОФизЛицСрезПоследних.Имя, 1, 1) <> """" 
			|														ТОГДА "" "" + ПОДСТРОКА(ФИОФизЛицСрезПоследних.Имя, 1, 1) + ""."" 
			|													ИНАЧЕ """" 
			|												КОНЕЦ + ВЫБОР 
			|															КОГДА ПОДСТРОКА(ФИОФизЛицСрезПоследних.Отчество, 1, 1) <> """" 
			|																ТОГДА "" "" + ПОДСТРОКА(ФИОФизЛицСрезПоследних.Отчество, 1, 1) + ""."" 
			|															ИНАЧЕ """" 
			|														КОНЕЦ 
			|	КОНЕЦ КАК ФИОПолное
			|ИЗ
			|	РегистрСведений.РаботникиОрганизаций.СрезПоследних(
			|					&ДатаСреза, 
			|					Организация = &ГоловнаяОрганизация 
			|					И Сотрудник.ФизЛицо = &Исполнитель 
			|					И Сотрудник.ВидЗанятости <> &ВнутреннееСовместительство) КАК РаботникиОрганизацииСрезПоследних
			|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(
			|					&ДатаСреза, 
			|					ФизЛицо = &Исполнитель) КАК ФИОФизЛицСрезПоследних
			|		ПО РаботникиОрганизацииСрезПоследних.Сотрудник.Физлицо = ФИОФизЛицСрезПоследних.ФизЛицо
			|
			|ГДЕ
			|	РаботникиОрганизацииСрезПоследних.ПодразделениеОрганизации.Владелец = &Организация
			|УПОРЯДОЧИТЬ ПО
			|	РаботникиОрганизацииСрезПоследних.Период УБЫВ
			|";
			ВыборкаИсполнителей = ЗапросПоИсполнителям.Выполнить().Выбрать();

			Если ВыборкаИсполнителей.Следующий() Тогда
				Результат.ИсполнительДолжность = ВыборкаИсполнителей.Должность;
				Результат.Исполнитель          = ВыборкаИсполнителей.ФиоПолное;
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	Возврат Результат;

КонецФункции // ОтветственныеЛицаОрганизации()

// Возвращает список строк с описание гос.органов, выдающих документы, удостоверяющие личность
//
Функция ПолучитьСписокПоУмолчаниюГосОргановВыдающихДокументыУдостоверяющиеЛичность() Экспорт

	Список = Новый СписокЗначений;
	Список.Добавить("МВД РЕСПУБЛИКИ КАЗАХСТАН");
	Список.Добавить("МИНИСТЕРСТВО ЮСТИЦИИ РЕСПУБЛИКИ КАЗАХСТАН");
	Возврат Список;

КонецФункции // ПолучитьСписокГосОргановВыдающихДокументыУдостоверяющиеЛичность()

// Функция собирает паспортные данные физ. лица на указанную дату
//
// Параметры: 
//  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
//  ДатаПериода - дата получения сведений
//
// Возвращаемое значение:
//  Структура с паспортными данными.
//
Функция ПаспортныеДанные(ФизЛицо, ДатаПериода) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);
	Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);

	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид КАК Вид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия КАК Серия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер КАК Номер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи КАК ДатаВыдачи,
	|	ВЫРАЗИТЬ(ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан КАК СТРОКА(1000)) КАК Выдан
	|ИЗ
	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|ГДЕ
	|	ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо = &ПарФизЛицо";
	Шапка = Запрос.Выполнить().Выбрать();
	Шапка.Следующий();

	Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");

	Результат.Вид        = Шапка.Вид;
	Результат.Серия      = Шапка.Серия;
	Результат.Номер      = Шапка.Номер;
	Результат.ДатаВыдачи = Шапка.ДатаВыдачи;
	Результат.Выдан      = Шапка.Выдан;

	Возврат Результат;

КонецФункции // ПаспортныеДанные()

// Процедура возвращает паспортные данные физлица в виде строки
//
// Параметры: 
//  ФизЛицо - ссылка на элемент справочника "Физические лица",по которму необходимо
//            получить паспортные данные.
//
// Возвращаемое значение:
//  Строка с данными об удостоверении личности физичского лица
//
Функция ПолучитьПаспортныеДанныеСтрокой(ФизЛицо) Экспорт

	СтруктураПаспортныхДанных = РегистрыСведений.ПаспортныеДанныеФизЛиц.ПолучитьПоследнее(ПолучитьРабочуюДату(), Новый Структура("ФизЛицо",ФизЛицо));

	ВидДокумента       = СтруктураПаспортныхДанных.ДокументВид;
	Серия              = СтруктураПаспортныхДанных.ДокументСерия;
	Номер              = СтруктураПаспортныхДанных.ДокументНомер;
	ДатаВыдачи         = СтруктураПаспортныхДанных.ДокументДатаВыдачи;
	КемВыдан           = СтруктураПаспортныхДанных.ДокументКемВыдан;

	Если НЕ (НЕ ЗначениеЗаполнено(ДатаВыдачи)
		   И НЕ ЗначениеЗаполнено(ВидДокумента)
		   И НЕ ЗначениеЗаполнено(Серия + Номер + КемВыдан)) Тогда

		Возврат ?(ВидДокумента.Пустая(),"","" + ВидДокумента + ", ") 
				+ ?(ЗначениеЗаполнено(Серия), "Серия: "   + Серия + ", ","") + "№ " + Номер 
				+ ", Выдан: " + Формат(ДатаВыдачи,"ДФ='дд ММММ гггг'") + " года, " 
				+ КемВыдан;

	Иначе

		Возврат "Отсутствуют данные об удостоверении личности."

	КонецЕсли;

КонецФункции // ПолучитьПаспорныеДанныеСтрокой()

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	
	
	МассивТиповСсылок = Новый Массив;
	МассивТиповСсылок.Добавить(Тип("СправочникСсылка.ФизическиеЛица"));
	МассивТиповСсылок.Добавить(Тип("СправочникСсылка.СотрудникиОрганизаций"));

	СписокТиповСсылок	= Новый ОписаниеТипов(МассивТиповСсылок);
	
	МассивТиповОбъектов = Новый Массив;
	МассивТиповОбъектов.Добавить(Тип("СправочникОбъект.ФизическиеЛица"));
	МассивТиповОбъектов.Добавить(Тип("СправочникОбъект.СотрудникиОрганизаций"));

	СписокТиповОбъектов	= Новый ОписаниеТипов(МассивТиповОбъектов);
	
	Если ТипОбъекта = Тип("Строка") Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
	ИначеЕсли ТипОбъекта <> Тип("Неопределено") И (СписокТиповСсылок.СодержитТип(ТипОбъекта) Или СписокТиповОбъектов.СодержитТип(ТипОбъекта)) Тогда 
		Если СписокТиповСсылок.СодержитТип(ТипОбъекта) Тогда
			Попытка
			   Наименование = ПолучитьЗначениеРеквизита(Объект, "Наименование");
			Исключение
			   НаименованиеОбъекта = "";
			КонецПопытки;
		Иначе
			Попытка
			   НаименованиеОбъекта = Объект.Наименование	
			Исключение
			   НаименованиеОбъекта = "";
			КонецПопытки;
		КонецЕсли;

		// Избавление от возможных выражений в скобках, например (осн.), (вн. совм.).
		НачальнаяПозиция	= Найти(Наименование,"(");
		КонечнаяПозиция		= Найти(Наименование,")");
		ДлинаСтроки			= СтрДлина(Наименование);
		Если НачальнаяПозиция > 0 Тогда
			СтрокаДляОбработки = Лев(Наименование, НачальнаяПозиция - 1) + ?(КонечнаяПозиция > 0,Прав(Наименование, ДлинаСтроки - КонечнаяПозиция),"")
		Иначе
			СтрокаДляОбработки = Наименование;
		КонецЕсли; 

		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(СтрокаДляОбработки)," ");
	Иначе

		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"")

	КонецЕсли;

	КоличествоПодстрок = ФИО.Количество();
	Фамилия  = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя      = ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество = ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"");

КонецФункции // ФамилияИнициалыФизЛица()

// Функция формирует фамилию и инициалы
//
// Параметры
//  Фамилия  - фамилия физ. лица.
//  Имя      - имя физ. лица.
//  Отчество - отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия, имя, отчество одной строкой.
//
Функция ПолучитьФамилиюИмяОтчество(Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + 
			?(НЕ ПустаяСтрока(Отчество) , 
			Лев(Отчество,1)+".", ""), ""), "");

КонецФункции // ПолучитьФамилиюИмяОтчество()

// Функция выделяет первое слово в предложении.
//
Функция ВыделитьСлово(ИсходнаяСтрока, СчетчикВызова) Экспорт
	
	Буфер = СокрЛ(ИсходнаяСтрока);
	ПозицияПослПробела = Найти(Буфер, " ");

	Если (ПозицияПослПробела = 0)
		 Или (СчетчикВызова >= 3) Тогда
		ИсходнаяСтрока = "";
		Возврат Буфер;
	КонецЕсли;
	
	ВыделенноеСлово = СокрЛП(Лев(Буфер, ПозицияПослПробела));
	ИсходнаяСтрока = Сред(ИсходнаяСтрока, ПозицияПослПробела + 1);
	
	Возврат ВыделенноеСлово;
	
КонецФункции // ВыделитьСлово()

// Функция определяет пол физлица по его отчеству. 
//
Функция УстановитьПол(ОтчествоРаботника) Экспорт

	Если Прав(ОтчествоРаботника, 2) = "ич" Тогда
	
		Возврат Перечисления.ПолФизическихЛиц.Мужской
	
	ИначеЕсли Прав(ОтчествоРаботника, 2) = "на" Тогда
	
		Возврат Перечисления.ПолФизическихЛиц.Женский
	
	КонецЕсли; 

	Возврат Перечисления.ПолФизическихЛиц.ПустаяСсылка();

КонецФункции // УстановитьПол()	

// Формирует список значений, описывающий государственные праздники РК
//
// Параметры
//  КалендарныйГод - число - год, за который возвращается список праздников
//
// Возвращаемое значение:
//   список значений, содержащий строки-месяцедни праздников
//
Функция ПолучитьСписокПраздниковРК(КалендарныйГод) Экспорт

	СписокПраздников = Новый СписокЗначений();
	
	//Закон Республики Казахстан от 13 декабря 2001 года N 267-II О праздниках в Республике Казахстан 
	СписокПраздников.Добавить("0101", "Новый год");
	СписокПраздников.Добавить("0102", "Новый год");
	СписокПраздников.Добавить("0308", "Международный женский день");
	Если КалендарныйГод > 2009 Тогда
		// Законом РК № 152-IV ЗРК от 22 апреля 2009 года увеличена продолжительность Наурыза
	    СписокПраздников.Добавить("0321", "Наурыз мейрамы");
		СписокПраздников.Добавить("0322", "Наурыз мейрамы");
		СписокПраздников.Добавить("0323", "Наурыз мейрамы");
	Иначе
		СписокПраздников.Добавить("0322", "Наурыз мейрамы");	
	КонецЕсли;
	
	СписокПраздников.Добавить("0501", "Праздник единства народа Казахстана");
	СписокПраздников.Добавить("0509", "День Победы");
	СписокПраздников.Добавить("0830", "День Конституции Республики Казахстан");	
	Если КалендарныйГод <= 2008 
		ИЛИ КалендарныйГод >= 2022 Тогда
		// Законом РК № 152-IV ЗРК от 22 апреля 2009 года исключен День Республики
		СписокПраздников.Добавить("1025", "День Республики");	
	КонецЕсли;
	СписокПраздников.Добавить("1216", "День независимости");		
	Если КалендарныйГод < 2022 Тогда
		СписокПраздников.Добавить("1217", "День независимости");			
	КонецЕсли;			
	
	Если КалендарныйГод >= 2006 Тогда
		// В соответствии с изменениями, внесенными в Закон о Труде 04.01.2006
		СписокПраздников.Добавить("0107", "!Православное Рождество");
		
		// Первый день Курбан-айта является плавающей датой
		Если КалендарныйГод = 2006 Тогда
			СписокПраздников.Добавить("0110", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2007 Тогда
			СписокПраздников.Добавить("1220", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2008 Тогда
			СписокПраздников.Добавить("1208", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2009 Тогда
			СписокПраздников.Добавить("1127", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2010 Тогда
			СписокПраздников.Добавить("1116", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2011 Тогда
			СписокПраздников.Добавить("1106", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2012 Тогда
			СписокПраздников.Добавить("1026", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2013 Тогда
			СписокПраздников.Добавить("1015", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2014 Тогда
			СписокПраздников.Добавить("1004", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2015 Тогда
			СписокПраздников.Добавить("0924", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2016 Тогда
			СписокПраздников.Добавить("0912", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2017 Тогда
			СписокПраздников.Добавить("0901", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2018 Тогда
			СписокПраздников.Добавить("0821", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2019 Тогда
			СписокПраздников.Добавить("0811", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2020 Тогда
			СписокПраздников.Добавить("0731", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2021 Тогда
			СписокПраздников.Добавить("0720", "!Первый день Курбан-айта");
   		ИначеЕсли КалендарныйГод = 2022 Тогда
			СписокПраздников.Добавить("0709", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2023 Тогда
			СписокПраздников.Добавить("0628", "!Первый день Курбан-айта");
		ИначеЕсли КалендарныйГод = 2024 Тогда
			СписокПраздников.Добавить("0617", "!Первый день Курбан-айта");
		КонецЕсли;
	КонецЕсли;
	
	Если КалендарныйГод >= 2008 Тогда
		СписокПраздников.Добавить("0706", "День Столицы");
	КонецЕсли;
	
	Если КалендарныйГод >= 2012 
		И КалендарныйГод < 2022 Тогда
		СписокПраздников.Добавить("1201", "День Первого Президента Республики Казахстан");
	КонецЕсли;
	
	Если КалендарныйГод >= 2013 Тогда
		СписокПраздников.Добавить("0507", "День защитника Отечества");
	КонецЕсли;

	Возврат СписокПраздников

КонецФункции // ПолучитьСписокПраздниковРК()

// Возвращает договор контрагента, если организация, указанная
// в данном договоре доступна пользователю
Функция ДоступныйДоговорКонтрагента(ДоговорСсылка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДоговорСсылка", ДоговорСсылка);
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ДоговорыКонтрагентов.Ссылка КАК Договор,
	|	ДоговорыКонтрагентов.Организация
	|ИЗ
	|	Справочник.ДоговорыКонтрагентов КАК ДоговорыКонтрагентов
	|ГДЕ
	|	ДоговорыКонтрагентов.Ссылка = &ДоговорСсылка";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		ДоговорКонтрагента = Выборка.Договор;
		
	Иначе
		ДоговорКонтрагента = Справочники.ДоговорыКонтрагентов.ПустаяСсылка();
	КонецЕсли;
	
	Возврат ДоговорКонтрагента;
	
КонецФункции // ДоступныйДоговорКонтрагента()

// Функция возвращает основной договор контрагента, если он доступен для чтения
//
Функция ПолучитьОсновнойДоговорКонтрагента(Контрагент) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	ДоговорыКонтрагентов.Ссылка КАК ДоступныйДоговорКонтрагента
	|ИЗ
	|	Справочник.ДоговорыКонтрагентов КАК ДоговорыКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновнойДоговорКонтрагента = ДоговорыКонтрагентов.Ссылка
	|ГДЕ
	|	ДоговорыКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновнойДоговорКонтрагента ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ДоступныйДоговорКонтрагента;		
	Иначе
		Возврат Справочники.ДоговорыКонтрагентов.ПустаяСсылка();		
	КонецЕсли;	
		
КонецФункции // ПолучитьОсновнойДоговорКонтрагента()

// Функция определяет принадлежность структурных единиц одной организации
//
// Параметры:
//      СписокСтруктурныхЕдиниц - список значений.
//
// Возвращаемое значение:
//     Булево - истина, если все структурные единицы принадлежат одной организации
//              ложь, если структурные елиницы принадлежат разным организациям
Функция ПроверитьПринадлежностьСтруктурныхЕдиницОднойОрганизации(СписокСтруктурныхЕдиниц) Экспорт
	
	Если ТипЗнч(СписокСтруктурныхЕдиниц) <> Тип("СписокЗначений") Тогда
		СписокСтруктурныхЕдиниц = Новый СписокЗначений();
	КонецЕсли;	
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Организации.ГоловнаяОрганизация) КАК КоличествоОрг
	               |ИЗ
	               |	Справочник.Организации КАК Организации
	               |ГДЕ
	               |	Организации.Ссылка В(&СписокСтруктурныхЕдиниц)";
				   
	Запрос.УстановитьПараметр("СписокСтруктурныхЕдиниц",СписокСтруктурныхЕдиниц);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		КолВо = Выборка.КоличествоОрг;
		Если КолВо = 1 Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
	Иначе
		Возврат Ложь;
	КонецЕсли;		
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТРУКТУРНЫМ ПОДРАЗДЕЛЕНИЕМ

// Функция определяет необходимость отображать структурные подразделения
//
// Возвращаемое значение:
//     Булево - истина, если необходимо отображать структурные подразделения
//              ложь, если нет необходимости отображать структурные подразделения
Функция ПолучитьПризнакОтображенияСтруктурныхПодразделений() Экспорт
	
	ОтображениеСтруктурныхПодразделений = Константы.ПоддержкаРаботыСоСтруктурнымиПодразделениями.Получить();
	
	Возврат ОтображениеСтруктурныхПодразделений;
	
КонецФункции

// Функция определяет реквизиты организации или структурного подразделения
// 
Функция ПолучитьСтруктурнуюЕдиницу(Организация, СтруктурноеПодразделение, КадровыйДокумент = Ложь) Экспорт
	
	ВозвращаемаяОрганизация = Организация;
	Если КадровыйДокумент Тогда
		
		УчетнаяПолитикаОрганизаций = глЗначениеПеременной("глУчетнаяПолитикаПоПерсоналуОрганизации");
		Если Организация <> Организация.ГоловнаяОрганизация И УчетнаяПолитикаОрганизаций[Организация].ВедениеУчетаПоГоловнойОрганизации Тогда
			ВозвращаемаяОрганизация = Организация.ГоловнаяОрганизация;
			УчетПоГоловнойОрганизации = Истина;
		Иначе
			УчетПоГоловнойОрганизации = УчетнаяПолитикаОрганизаций[ВозвращаемаяОрганизация].ВедениеУчетаПоГоловнойОрганизации;
		КонецЕсли;

	Иначе
		УчетПоГоловнойОрганизации = Ложь;
	КонецЕсли;
	
	Если СтруктурноеПодразделение <> Справочники.ПодразделенияОрганизаций.ПустаяСсылка() Тогда
		Если УчетПоГоловнойОрганизации Тогда
			Возврат ВозвращаемаяОрганизация;
		//Иначе
		//	Если СтруктурноеПодразделение.УказыватьРеквизитыГоловнойОрганизации Тогда
		//		Возврат ВозвращаемаяОрганизация;
		//	Иначе
		//		Возврат СтруктурноеПодразделение;
		//	КонецЕсли;
		КонецЕсли;
	Иначе
		Возврат ВозвращаемаяОрганизация;
	КонецЕсли;
		
КонецФункции // ПолучитьСтруктурнуюЕдиницу()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ВАЛЮТАМИ

// Эта функция пересчитывает сумму из валюты ВалютаНач по курсу ПоКурсуНач 
// в валюту ВалютаКон по курсу ПоКурсуКон
//
// Параметры:      
//	Сумма          - сумма, которую следует пересчитать;
//	ВалютаНач      - ссылка на элемент справочника Валют;
//                   определяет валюты из которой надо пересчитвать;
//	ВалютаКон      - ссылка на элемент справочника Валют;
//                   определяет валюты в которую надо пересчитвать;
// 	ПоКурсуНач     - курс из которого надо пересчитать;
// 	ПоКурсуКон     - курс в который надо пересчитать;
// 	ПоКратностьНач - кратность из которого надо пересчитать (по умолчанию = 1);
// 	ПоКратностьКон - кратность в который надо пересчитать  (по умолчанию = 1);
//
// Возвращаемое значение: 
//  Сумма, пересчитанная в другую валюту
//
Функция ПересчитатьИзВалютыВВалюту(Сумма, ВалютаНач, ВалютаКон, ПоКурсуНач, ПоКурсуКон, 
								   ПоКратностьНач = 1, ПоКратностьКон = 1 ) Экспорт

	Если (ВалютаНач = ВалютаКон) Тогда

		// Считаем, что пересчет не нужен.
		Возврат Сумма;

	КонецЕсли;

	Если (ПоКурсуНач     = ПоКурсуКон) 
	   И (ПоКратностьНач = ПоКратностьКон) Тогда

		// ну, тут и считать нечего...
		Возврат Сумма;

	КонецЕсли;
	
	// Проверка установки значений
	ПризнакОшибки = Ложь;
	Если ПоКурсуНач     = 0  Тогда
		СообщитьОбОшибке("При пересчете валютных сумм обнаружен нулевой курс валюты: " + СокрЛП(ВалютаНач));
		ПризнакОшибки = Истина;
	КонецЕсли;
	
	Если ПоКурсуКон     = 0  Тогда
		СообщитьОбОшибке("При пересчете валютных сумм обнаружен нулевой курс валюты: " + СокрЛП(ВалютаКон));
		ПризнакОшибки = Истина;
	КонецЕсли;
	
	Если ПоКратностьНач = 0  Тогда
		СообщитьОбОшибке("При пересчете валютных сумм обнаружена нулевая кратность валюты: " + СокрЛП(ВалютаНач));
		ПризнакОшибки = Истина;
	КонецЕсли;
	
	Если ПоКратностьКон = 0  Тогда
		СообщитьОбОшибке("При пересчете валютных сумм обнаружена нулевая кратность валюты: " + СокрЛП(ВалютаКон));
		ПризнакОшибки = Истина;
	КонецЕсли;
	
	Если ПризнакОшибки Тогда
		Возврат 0;          
	КонецЕсли;

	Возврат Окр((Сумма * ПоКурсуНач * ПоКратностьКон) / (ПоКурсуКон * ПоКратностьНач), 2);

КонецФункции // ПересчитатьИзВалютыВВалюту()

// Возвращает курс валюты на дату
//
// Параметры:
//  Валюта     - Валюта (элемент справочника "Валюты")
//  ДатаКурса  - Дата, на которую следует получить курс
//
// Возвращаемое значение: 
//  Структура, содержащая:
//   Курс      - курс валюты
//   Кратность - кратность валюты
//
Функция ПолучитьКурсВалюты(Валюта, ДатаКурса) Экспорт

	Структура = РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ДатаКурса, Новый Структура("Валюта", Валюта));
	Возврат Структура;
	
КонецФункции // ПолучитьКурсВалюты()

// Определяет курс документа, который равен либо курсу документа (если в документе он существует),
// либо курсу взаиморасчетов, либо 1.
//
// Параметры: 
//  ДокументОбъект                 - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - курс документа.
//
Функция КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	// Если валюта документа совпадает с валютой регл. учета, то курс 1.
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
		
		Если ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета Тогда
		
			// Если есть реквизит КурсДокумента - его и вернем
			Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КурсДокумента;
			КонецЕсли;

			// Если нет КурсДокумента и валюта документа не совпадает с валютой регл. учета, 
			// то такой документ может быть выписан только в валюте взаиморасчетов,
			// если есть реквизит КурсВзаиморасчетов - его и вернем.
			Если ЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КурсВзаиморасчетов;
			КонецЕсли;

			// Если нет КурсВзаиморасчетов и валюта документа не совпадает с валютой регл. учета, 
			// то КурсВзаиморасчетов долежн быть в табличной части документа или может вообще отсутсвовать.
			// Тогда возьмем курс из справочника на дату документа.
			Возврат ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента,ДокументОбъект.Дата).Курс;

		КонецЕсли;
		
	КонецЕсли;

	Возврат 1;

КонецФункции // КурсДокумента()

// Определяет кратность документа, которая равен либо кратности документа (если в документе она существует),
// либо кратности взаиморасчетов, либо 1.
//
// Параметры: 
//  ДокументОбъект - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - кратность валюты в документе.
//
Функция КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда

		// Если валюта документа совпадает с валютой регл. учета, то кратность 1.
		Если ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета Тогда

			// Если есть реквизит КратностьДокумента - его и вернем
			Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КратностьДокумента;
			КонецЕсли;

			// Если нет КратностьДокумента и валюта документа не совпадает с валютой регл. учета, 
			// то такой документ может быть выписан только в валюте взаиморасчетов,
			// если есть реквизит КратностьВзаиморасчетов - его и вернем.
			Если ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КратностьВзаиморасчетов;
			КонецЕсли;

			// Если нет КратностьВзаиморасчетов и валюта документа не совпадает с валютой регл. учета, 
			// то КратностьВзаиморасчетов должна быть в табличной части документа или может вообще отсутсвовать.
			// Тогда возьмем Кратность из справочника на дату документа.
			Возврат ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента,ДокументОбъект.Дата).Кратность;

		КонецЕсли;
	
	КонецЕсли;

	Возврат 1;

КонецФункции // КратностьДокумента()

// Проверяет наличие установленного курса и кратности валюты на 1 января 1980 года.
// В случае отсутствия устанавливает курс и кратность равными единице.
//
// Параметры:
//  Валюта - ссылка на элемент справочника Валют
//
Процедура ПроверитьКорректностьКурсаНа01_01_1980(Валюта) Экспорт

	ДатаКурса = Дата(1980, 1, 1);
	СтруктураКурса = ПолучитьКурсВалюты(Валюта, ДатаКурса);

	Если (СтруктураКурса.Курс = 0) Или (СтруктураКурса.Кратность = 0) Тогда

		// установим курс и кратность = 1 на 01.01.1980, чтобы не было ошибок при создании документов

		РегистрКурсыВалют = РегистрыСведений.КурсыВалют.СоздатьНаборЗаписей();
		РегистрКурсыВалют.Отбор.Валюта.Установить(Валюта, Истина);
		РегистрКурсыВалют.Отбор.Период.Установить(ДатаКурса, Истина);

		НоваяЗапись = РегистрКурсыВалют.Добавить();
		НоваяЗапись.Период    = ДатаКурса;
		НоваяЗапись.Валюта    = Валюта;
		НоваяЗапись.Курс      = 1;
		НоваяЗапись.Кратность = 1;
		
		РегистрКурсыВалют.ОбменДанными.Загрузка = Истина; // чтобы не проверять дату запрета редактирования
		РегистрКурсыВалют.Записать();
		
		Если Метаданные.РегистрыСведений.Найти("КурсыВалютДляРасчетовСПерсоналом") <> Неопределено Тогда
			РегистрКурсыВалют = РегистрыСведений["КурсыВалютДляРасчетовСПерсоналом"].СоздатьНаборЗаписей();
			РегистрКурсыВалют.Отбор.Валюта.Установить(Валюта, Истина);
			РегистрКурсыВалют.Отбор.Период.Установить(ДатаКурса, Истина);

			НоваяЗапись = РегистрКурсыВалют.Добавить();
			НоваяЗапись.Период    = ДатаКурса;
			НоваяЗапись.Валюта    = Валюта;
			НоваяЗапись.Курс      = 1;
			НоваяЗапись.Кратность = 1;
			
			РегистрКурсыВалют.ОбменДанными.Загрузка = Истина; // чтобы не проверять дату запрета редактирования
			РегистрКурсыВалют.Записать();
		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // ПроверитьКорректностьКурсаНа01_01_1980()

// Процедура заполняет переданные переменные названиями целой и дробной части валюты для 
// соответствующей суммы
//
// Параметры:
//  ВалютаИлиПараметрыПрописи - значение типа СправочникСсылка.Валюты или строка с параметрами прописи
//  Сумма - число
//  НазваниеВалютыЦелойЧасти - строка с названием валюты для целой части (выходной параметр)
//  НазваниеВалютыДробнойЧасти - строка с названием валюты для дробной части (выходной параметр)
//
// Возвращаемое значение:
//	нет
//
Процедура ПолучитьНазваниеЦелойИДробнойЧастиВалюты(ВалютаИлиПараметрыПрописи, Сумма, НазваниеВалютыЦелойЧасти, НазваниеВалютыДробнойЧасти) Экспорт
	
	НазваниеВалютыЦелойЧасти = "";
	НазваниеВалютыДробнойЧасти = "";

	Если ТипЗнч(ВалютаИлиПараметрыПрописи) = Тип("Строка") Тогда
		СтрокаПараметров = СтрЗаменить(ВалютаИлиПараметрыПрописи, ",", Символы.ПС);	
	ИначеЕсли ТипЗнч(ВалютаИлиПараметрыПрописи) = Тип("СправочникСсылка.Валюты") Тогда
		СтрокаПараметров = СтрЗаменить(ВалютаИлиПараметрыПрописи.ПараметрыПрописиНаРусском, ",", Символы.ПС);	
	Иначе
		Возврат;
	КонецЕсли;
	ЦелаяЧасть = Цел(Сумма);
	ДробнаяЧасть = (Сумма - ЦелаяЧасть) * 100;
	
	Если ЦелаяЧасть = 1 Тогда
		НазваниеВалютыЦелойЧасти = СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 1));
	ИначеЕсли ЦелаяЧасть >= 2 И ЦелаяЧасть <= 4 Тогда
		НазваниеВалютыЦелойЧасти = СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 2));
	Иначе
		НазваниеВалютыЦелойЧасти = СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 3));
	КонецЕсли;
	
	Если ДробнаяЧасть = 1 Тогда
		НазваниеВалютыДробнойЧасти = СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 5));
	ИначеЕсли ДробнаяЧасть >= 2 И ДробнаяЧасть <= 4 Тогда
		НазваниеВалютыДробнойЧасти = СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 6));
	Иначе
		НазваниеВалютыДробнойЧасти = СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 7));
	КонецЕсли;
	
КонецПроцедуры // ПолучитьНазваниеЦелойИДробнойЧастиВалюты()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРА КОНСТАНТ

// Записывает набор констант, сравнивая его с эталонным набором
// Записываются только те константы, которые были изменены относительно эталонного набора
//
// Параметры: 
//  НаборКонстант  - Набор констант
//  ЭталонныйНабор - Эталонный набор констант
//  Модифицированность - Устанавливается в истину, если операция выполнена успешно
//
// Возвращаемое значение:
//  Истина - операция выполнена, ложь - иначе.
//
Функция ЗаписатьНаборКонстант(НаборКонстант, ЭталонныйНабор, Модифицированность = Истина) Экспорт
	
	ЗаписываемыеКонстанты = "";
	Для каждого Константа Из Метаданные.Константы Цикл
		
		ИмяКонстанты = Константа.Имя;
		
		ЗначениеНабора    = ЗначениеВСтрокуВнутр(НаборКонстант[ИмяКонстанты]);
		ЭталонноеЗначение = ЗначениеВСтрокуВнутр(ЭталонныйНабор[ИмяКонстанты]);
		
		Если Не ЗначениеНабора = ЭталонноеЗначение Тогда
			
			ТекущееЗначение   = ЗначениеВСтрокуВнутр(Константы[ИмяКонстанты].Получить());
			
			Если Не ЗначениеНабора = ТекущееЗначение Тогда
				ЗаписываемыеКонстанты = ЗаписываемыеКонстанты + ?(ПустаяСтрока(ЗаписываемыеКонстанты), "", ", ") + ИмяКонстанты;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(ЗаписываемыеКонстанты) Тогда
		
		ЗаписываемыйНабор = Константы.СоздатьНабор(ЗаписываемыеКонстанты);
		ЗаполнитьЗначенияСвойств(ЗаписываемыйНабор, НаборКонстант, ЗаписываемыеКонстанты);
		
		Попытка
			ЗаписываемыйНабор.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
		
		НаборКонстант.Прочитать();
		ЗаполнитьЗначенияСвойств(ЭталонныйНабор, НаборКонстант);
		
	КонецЕсли; 
	
	Модифицированность = Ложь;
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Процедура устанавливает новое значение для переданного реквизита.
// Если новое значение совпадает со старым, то флаг модифицированности не взводится.
//
// Параметры
//  Реквизит  – Произвольный – Реквизит, для которого надо установить новое значение
//  Значение  – Произвольный – Новое значение для реквизита
//
Процедура УстановитьЗначение(Реквизит, Значение) Экспорт

	Если Реквизит <> Значение Тогда
		Реквизит = Значение;
	КонецЕсли;

КонецПроцедуры // УстановитьЗначение(Реквизит, Значение)

// Проверяет указанный Реквизит на пустое значение.
// Значение Реквизита сравнивается с пустым значением соответствующего Реквизиту типа.
// Реквизит типа Строка считается пустым, если в нем не содержится значащих символов.
Функция ПустоеЗначение(Реквизит) Экспорт

	Если Реквизит = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;

	Если ТипЗнч(Реквизит) = Тип("Строка") Тогда
		Возврат ПустаяСтрока(Реквизит);
	ИначеЕсли ТипЗнч(Реквизит) = Тип("Число") Тогда
		Если Реквизит = 0 Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
	ИначеЕсли ТипЗнч(Реквизит) = Тип("Дата") Тогда
		Если Реквизит = Дата('00010101') Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;

КонецФункции // ПустоеЗначение()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ МЕХАНИЗМА СВОЙСТВ И КАТЕГОРИЙ ОБЪЕКТОВ

//Функция возвращает список доступных назначений для "Свойств и категорий объектов" 
//по переданной ссылке
// Параметры:
//Ссылка - Ссылка на справочник или документ
//
// Возвращаемое значение:
// Список значений: доступные назначения для свойств и категорий
Функция ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(Ссылка) Экспорт

	Результат = Новый СписокЗначений;
	
	Запрос = Новый Запрос;
	
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Метаданные.Справочники.Найти("ХарактеристикиНоменклатуры") <> Неопределено Тогда
		ЭтоХарактеристика = (ТипСсылки = Тип("СправочникСсылка.ХарактеристикиНоменклатуры"));
		Запрос.УстановитьПараметр("НазначениеХарактеристика", ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры);
	Иначе
		ЭтоХарактеристика = Ложь;
	КонецЕсли;
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Назначения.Ссылка КАК Ссылка,
	|	Назначения.ТипЗначения КАК ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
	|ГДЕ
	|	НЕ Назначения.ПометкаУдаления
	|	И НЕ Назначения.ЭтоГруппа
	|";

	Если ЭтоХарактеристика Тогда
		ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка = &НазначениеХарактеристика
		|";
	ИначеЕсли Метаданные.Справочники.Найти("ХарактеристикиНоменклатуры") <> Неопределено Тогда
		ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка <> &НазначениеХарактеристика
		|";
	КонецЕсли;

	Запрос.Текст = ТекстЗапроса;

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ЭтоХарактеристика Или Выборка.ТипЗначения.СодержитТип(ТипСсылки) Тогда
			Результат.Добавить(Выборка.Ссылка);
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции // ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ СТРОК

// Стандартная для данной конфигурации функция форматирования прописи количества
//
// Параметры: 
//  Количество - число, которое мы хотим форматировать
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление количества.
//
Функция КоличествоПрописью(Количество) Экспорт

	ЦелаяЧасть   = Цел(Количество);
	ДробнаяЧасть = Окр(Количество - ЦелаяЧасть, 3);

	Если ДробнаяЧасть = Окр(ДробнаяЧасть,0) Тогда
		ПараметрыПрописи = ", , , , , , , , 0";
	ИначеЕсли ДробнаяЧасть = Окр(ДробнаяЧасть, 1) Тогда
		ПараметрыПрописи = "целая, целых, целых, ж, десятая, десятых, десятых, м, 1";
	ИначеЕсли ДробнаяЧасть = Окр(ДробнаяЧасть, 2) Тогда
		ПараметрыПрописи = "целая, целых, целых, ж, сотая, сотых, сотых, м, 2";
	Иначе
		ПараметрыПрописи = "целая, целых, целых, ж, тысячная, тысячных, тысячных, м, 3";
	КонецЕсли;

	Возврат ЧислоПрописью(Количество, ,ПараметрыПрописи);

КонецФункции // КоличествоПрописью()

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "", ЧРД = "", ВалютаПрописью = Ложь) Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(НЕ ЗначениеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(НЕ ЗначениеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ)+
					?(НЕ ЗначениеЗаполнено(ЧРД),"", ";" + "ЧРД=" + ЧРД);
					
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если ЗначениеЗаполнено(Валюта) Тогда
		Если ВалютаПрописью и НЕ СокрЛП(Валюта.ПараметрыПрописиНаРусском) = "" Тогда 
			СтрокаПараметров = СтрЗаменить(Валюта.ПараметрыПрописиНаРусском, ",", Символы.ПС);
			НовыеПараметрыПрописи = СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 1))+","+
									СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 2))+","+
									СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 3))+","+
									СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 4))+","+
									СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 5))+","+
									СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 6))+","+
									СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 7))+","+
									СокрЛП(СтрПолучитьСтроку(СтрокаПараметров, 8))+","+ 0;
	
	
			ЗначимаяЧасть = ЧислоПрописью(Цел(Сумма),"ru_RU; НП = Ложь; ДП = Ложь", НовыеПараметрыПрописи);
    		ЧисловаяЧасть = ЧислоПрописью(Цел(Сумма),"ru_RU; НП = Ложь; ДП = Ложь", ",,,,,,,,0");
            РезультирующаяСтрока = СтрЗаменить(ЗначимаяЧасть, ЧисловаяЧасть, РезультирующаяСтрока + " ");
		Иначе			
			РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
		КонецЕсли;	
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта) Экспорт

	Если Валюта.ПараметрыПрописиНаРусском = "" Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма, "L=ru_RU", Валюта.ПараметрыПрописиНаРусском);
	КонецЕсли;

КонецФункции // СформироватьСуммуПрописью()

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, ЦелоеЧисло) Экспорт

	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции

Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	СписокКодовЧисел = Новый СписокЗначений;

	Для Индекс = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(Индекс);
	КонецЦикла;

	СтрокаПроверки = СокрЛП(СтрокаПроверки);

	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Истина;
	Иначе

		Для Индекс = 1 По СтрДлина(СтрокаПроверки) Цикл
			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, Индекс, 1))) = Неопределено Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;

	Возврат Ложь;

КонецФункции // ЕстьНеЦифры()

// Функция преобразует ФИО из именительного падежа в дательный
// Параметры: 
//  СтруктураФИО - тип,Структура, ключи которой должны быть:
//		Фамилия  - значение должна соответствовать фамилии,
//		Имя      - значение должна соответствовать имени,
//		Отчество - значение должна соответствовать отчеству,
//  НеСклонятьФамилию - признак, типа Булево, по котрому опредеяем нужно склонять фамилию или нет
// Возвращаемое значение:
//	ФИО1 - Полное имя в формате "Фамилия Имя Отчество" в дательном падеже
// 
Функция ПреобразоватьФИОВДательныйПадеж(СтруктураФИО, НеСклонятьФамилию = Ложь, Пол = Неопределено) Экспорт 
	Перем Фамилия, Имя, Отчество;
	
	Фамилия ="";
	Имя = "";
	Отчество = ""; 
	ФИО = "";
	     	
	Если ТипЗнч(СтруктураФИО) = Тип("Структура") Тогда
		СтруктураФИО.Свойство("Фамилия", Фамилия);
		СтруктураФИО.Свойство("Имя", Имя);
		СтруктураФИО.Свойство("Отчество",Отчество);
	Иначе
		Возврат "";
	КонецЕсли;
		
	ОбщДлина = СтрДлина(Фамилия) + СтрДлина(Имя)+ СтрДлина(Отчество);
	            		
	//Проверим фио на пустоту
	Если ОбщДлина = 0 Тогда
		Фио1 = "";
		Возврат ФИО1;
	КонецЕсли;	

	ФИО = НРег(Фамилия + " " + Имя + " " + Отчество);
	
	// поделим на фамилию, имя и очество
	// позиция первого пробела
	ПервПроб = Найти(ФИО," ");
	Если ПервПроб = 0 Тогда
		Фамилия = СокрЛ(ФИО);
	Иначе
		Фамилия = Лев(ФИО,ПервПроб);
		ИО = Сред(ФИО,ПервПроб+1);
		ИО = СокрЛП(ИО);
		// позиция второго пробела
		ВтПроб = Найти(ИО," ");
		Если ВтПроб = 0 Тогда
			Имя = СокрЛП(ИО);
		Иначе
			Имя = СокрЛ(Лев(ИО,ВтПроб-1));
			Отчество = СокрЛ((Сред(ИО,ВтПроб+1)));
		КонецЕсли;
	КонецЕсли;    
	
	//определяем род  
	ДлинаОтчества = СтрДлина(СокрЛП(Отчество));
	ПослСимвОтч   = Сред(Отчество,ДлинаОтчества,1);
	
	//определим пол
	Если Пол <> Неопределено И ДлинаОтчества = 0 Или ПослСимвОтч = "." Тогда 
		МужскойПол = Перечисления.ПолФизическихЛиц.Мужской;
		Если Пол = МужскойПол Тогда 
			Мужской = 1;
		Иначе 
			Мужской = 0;
		КонецЕсли;
	Иначе 
		Если ПослСимвОтч = "ч" ИЛИ Найти("ұлы, улы", Прав(Отчество, 3)) > 0 Тогда
			Мужской = 1;
		Иначе 
			Мужской = 0;
		КонецЕсли;
	КонецЕсли;
	
	
	Если Мужской = 1 Тогда   		
		//Проверим фамилию на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Фамилия,".") <> 0 Тогда
			Фамилия1 = СокрЛП(Фамилия);
		Иначе
			Если НеСклонятьФамилию Тогда
				Фамилия1 = СокрЛП(Фамилия);
			Иначе
				//фамилия
				ДлинаФам = СтрДлина(СокрЛП(Фамилия));
				ПослСимвФам = Сред(Фамилия,ДлинаФам,1);
				Если (ПослСимвФам = "о") ИЛИ (ПослСимвФам = "и") ИЛИ (ПослСимвФам = "х") ИЛИ (ПослСимвФам = "я") ИЛИ (ПослСимвФам = "а") Тогда
					//в этом случае не скланяеться  	
					Фамилия1 = Фамилия;
				ИначеЕсли (ПослСимвФам = "й") Тогда 
					Если Сред(Фамилия, ДлинаФам-1, 1) = "е" Тогда
						//для фамилий типа МАРЦЕФЕЙ
						Фамилия1 = Фамилия;    
					Иначе
						//обрезаем 2 символа и прибавляем "ому"	
						ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам-2);
						Фамилия1 = ФамилияОбрезанная + "ому";
					КонецЕсли;
				Иначе  
					//прибавляем "у"	
					Фамилия1 = СокрЛП(Фамилия) + "у";
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
		
		//имя 
		//Проверим имя на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Имя,".") <> 0 Тогда
			Имя1 = СокрЛП(Имя);
		Иначе
			ДлинаИмени = СтрДлина(СокрЛП(Имя));
			//проверем составное ли имя:
			НомерПозиции =Найти(Имя,"-");
			КоличествоИмен = 1;
			Имя1="";
			Если  НомерПозиции > 0 Тогда
				//это составное имя
				СтруктураИмен = Новый Структура;
				Имя_1 = СокрЛП(Сред(Имя,1,НомерПозиции-1));		
				Имя_2 = СокрЛП(Сред(Имя,НомерПозиции+1,ДлинаИмени));
				СтруктураИмен.Вставить("Имя_1", Имя_1);
				СтруктураИмен.Вставить("Имя_2", Имя_2);
				КоличествоИмен = 2;
			КонецЕсли;
			
			Для НомерИмени =1 По КоличествоИмен  Цикл
				Если КоличествоИмен = 1 Тогда
					Имя = Имя;
					СоеденительнаяИмен = "";
				Иначе
					ИмяКлюча = "Имя_" + Строка(НомерИмени);
					СоеденительнаяИмен = "-";
					СтруктураИмен.Свойство(ИмяКлюча, Имя);
				КонецЕсли;
				ДлинаИмени = СтрДлина(СокрЛП(Имя));
				Если ДлинаИмени <> 0 Тогда 			
					
					ПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени, 1);
					
					Если (ПослСимвИмени = "й") ИЛИ (ПослСимвИмени = "ь") Тогда 
						//обрезаем 1 символ и прибавляем "ю"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени-1));
						Имя1 = Имя1 + Врег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2)  + "ю";
					ИначеЕсли (ПослСимвИмени = "я") ИЛИ (ПослСимвИмени = "а") Тогда 
						//обрезаем 1 символ и прибавляем "е"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени-1));
						Имя1 = Имя1 + Врег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2)  + "е";
					Иначе
						//прибавляем "у"
						Имя = СокрЛП(Имя); 
						Имя1 = Имя1 + Врег(Лев(Имя,1)) + Сред(Имя,2)  + "у";
					КонецЕсли;
				КонецЕсли;
				Если НомерИмени  = 1 Тогда
					Имя1= Имя1 +  СоеденительнаяИмен;
				КонецЕсли;  				
			КонецЦикла;  		 		
		КонецЕсли;
		
		//отчество  
		//Проверим отчество на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Отчество,".") <> 0 Тогда
			Отчество1 = СокрЛП(Отчество);
		Иначе 
			//прибавляем "у"	
			Если Найти("ұлы, улы", Прав(Отчество,3)) = 0 Тогда
				Отчество1 = СокрЛП(Отчество) + "у";
			Иначе
				Отчество1 = Отчество;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли Мужской = 0 Тогда
		//Проверим фамилию на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Фамилия,".") <> 0 Тогда
			Фамилия1 = СокрЛП(Фамилия);
		Иначе
			Если НеСклонятьФамилию Тогда
				Фамилия1 = СокрЛП(Фамилия);
			Иначе  			
				//фамилия
				ДлинаФам = СтрДлина(СокрЛП(Фамилия));
				ПослСимвФам = Сред(Фамилия,ДлинаФам,1);
				Если (ПослСимвФам = "о") ИЛИ (ПослСимвФам = "и") ИЛИ (ПослСимвФам = "х") ИЛИ (ПослСимвФам = "ч") ИЛИ (ПослСимвФам = "б") 
					ИЛИ  (ПослСимвФам = "в") ИЛИ (ПослСимвФам = "г") ИЛИ (ПослСимвФам = "д") ИЛИ (ПослСимвФам = "ж") ИЛИ (ПослСимвФам = "з")
					ИЛИ  (ПослСимвФам = "п") ИЛИ (ПослСимвФам = "н") ИЛИ (ПослСимвФам = "м") ИЛИ (ПослСимвФам = "л") ИЛИ (ПослСимвФам = "к")
					ИЛИ  (ПослСимвФам = "р") ИЛИ (ПослСимвФам = "с") ИЛИ (ПослСимвФам = "т") ИЛИ (ПослСимвФам = "ф") ИЛИ (ПослСимвФам = "ц")
					ИЛИ  (ПослСимвФам = "ь") ИЛИ (ПослСимвФам = "щ") ИЛИ (ПослСимвФам = "ш")   Тогда
					//в этом случае не склоняется  	
					Фамилия1 = СокрЛП(Фамилия);
				ИначеЕсли (ПослСимвФам = "я") Тогда 
					//обрезаем 2 символа и прибавляем "ой"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 2);
					Фамилия1 = СокрЛП(ФамилияОбрезанная) + "ой";
				Иначе  
					//обрезаем 1 символа и прибавляем "ой"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 1);
					Фамилия1 = СокрЛП(ФамилияОбрезанная) + "ой";
				КонецЕсли; 
			КонецЕсли;   		
		КонецЕсли;
				
		//имя    	
		//Проверим имя на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Имя,".") <> 0 Тогда
			Имя1 = СокрЛП(Имя);
		Иначе 	
			НомерПозиции =Найти(Имя,"-");
			ДлинаИмени = СтрДлина(СокрЛП(Имя));
			КоличествоИмен = 1;
			Имя1="";
			Если  НомерПозиции > 0 Тогда
				//это составное имя, например  Мария-Тереза
				СтруктураИмен = Новый Структура;
				Имя_1 = СокрЛП(Сред(Имя,1,НомерПозиции-1));		
				Имя_2 = СокрЛП(Сред(Имя,НомерПозиции+1,ДлинаИмени));
				СтруктураИмен.Вставить("Имя_1", Имя_1);
				СтруктураИмен.Вставить("Имя_2", Имя_2);
				КоличествоИмен = 2;
			КонецЕсли;
			
			Для НомерИмени =1 По КоличествоИмен  Цикл
				Если КоличествоИмен = 1 Тогда
					Имя = Имя;
					СоеденительнаяИмен = "";
				Иначе
					ИмяКлюча = "Имя_" + Строка(НомерИмени);
					СоеденительнаяИмен = "-";
					СтруктураИмен.Свойство(ИмяКлюча, Имя);
				КонецЕсли;
				ДлинаИмени = СтрДлина(СокрЛП(Имя));
				
				Если ДлинаИмени <> 0 Тогда  
					
					ПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени, 1);
					ПредПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени - 1, 1);
					Если (ПослСимвИмени = "а") ИЛИ (ПослСимвИмени = "я") Тогда
						//в этом случае разбиваем на два
						Если (ПредПослСимвИмени = "и") Тогда
							//обрезаем 1 символ и прибавляем "и"	
							ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
							Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
						Иначе
							//обрезаем 1 символ и прибавляем "е"	
							ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
							Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "е";
						КонецЕсли; 
					ИначеЕсли (ПослСимвИмени = "ь") Тогда 
						//обрезаем 1 символ и прибавляем "и"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
					Иначе  
						//не изменяется	
						Имя = СокрЛП(Имя);
						Имя1 = Имя1 + Врег(Лев(Имя,1)) + Сред(Имя,2);
					КонецЕсли;
				КонецЕсли;
				Если НомерИмени = 1 Тогда
					Имя1 = Имя1 + СоеденительнаяИмен;
				КонецЕсли;     			
			КонецЦикла;
		КонецЕсли;
	
		
		//Проверим отчество на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Отчество,".") <> 0 Тогда
			Отчество1 = СокрЛП(Отчество);
		Иначе 
			//отчество 
			//обрезаем 1 символа и прибавляем "е"	
			Если СтрДлина(СокрЛП(Отчество)) > 0 И Найти("кызы, қызы", Прав(Отчество, 4)) = 0 Тогда
				ОтчествоОбрезанное = Сред(Отчество, 1, ДлинаОтчества-1);
				Отчество1 = СокрЛП(ОтчествоОбрезанное) + "е";
			Иначе
				Отчество1 = Отчество;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;	
	
	ФИО1 = ВРег(Лев(Фамилия1,1)) + Сред(Фамилия1, 2)+ " " +
		   ВРег(Лев(Имя1,1)) + Сред(Имя1, 2) + " " +
		   ВРег(Лев(Отчество1,1)) + Сред(Отчество1, 2); 

	Возврат ФИО1;

КонецФункции //ПреобразоватьФИОВДательныйПадеж

// Функция преобразует ФИО из именительного падежа в родительный
// Параметры: 
//  СтруктураФИО - тип,Структура, ключи которой должны быть:
//		Фамилия  - значение должна соответствовать фамилии,
//		Имя      - значение должна соответствовать имени,
//		Отчество - значение должна соответствовать отчеству,
// Возвращаемое значение:  
//	ФИО1 - Полное имя в формате "Фамилия Имя Отчество" в родительном падеже
//
Функция ПреобразоватьФИОВРодительныйПадеж(СтруктураФИО, НеСклонятьФамилию = Ложь) Экспорт 
	Перем Фамилия, Имя, Отчество;
	
	Фамилия ="";
	Имя = "";
	Отчество = ""; 
	ФИО = "";
	
	
	Если ТипЗнч(СтруктураФИО) = Тип("Структура") Тогда
		СтруктураФИО.Свойство("Фамилия", Фамилия);
		СтруктураФИО.Свойство("Имя", Имя);
		СтруктураФИО.Свойство("Отчество",Отчество);
	Иначе
		Возврат "";
	КонецЕсли;
		
	ОбщДлина = СтрДлина(Фамилия) + СтрДлина(Имя)+ СтрДлина(Отчество);
	
	//Проверим фио на пустоту
	Если ОбщДлина = 0 Тогда
		Фио1 = "";
		Возврат ФИО1;
	КонецЕсли;	
	
	ФИО  	 = НРег(Фамилия + " " + Имя + " " + Отчество);
	
	//поделим на фамилию, имя и очество
	// позиция первого пробела
	ПервПроб = Найти(ФИО," ");
	Если ПервПроб = 0 Тогда
		Фамилия = СокрЛ(ФИО);
	Иначе
		Фамилия = Лев(ФИО,ПервПроб);
		ИО = Сред(ФИО,ПервПроб+1);
		ИО = СокрЛП(ИО);
		// позиция второго пробела
		ВтПроб = Найти(ИО," ");
		Если ВтПроб = 0 Тогда
			Имя = СокрЛП(ИО);
		Иначе
			Имя = СокрЛ(Лев(ИО,ВтПроб-1));
			Отчество = СокрЛ((Сред(ИО,ВтПроб+1)));
		КонецЕсли;
	КонецЕсли;    
	
	//Проверим остаток на вхождение точки т.е. на сокрашенния, 
	//если есть то дальше скланяем только фамилию
	Если Найти(ИО,".") <> 0 И Не НеСклонятьФамилию Тогда
		ДлинаФам = СтрДлина(СокрЛП(Фамилия));
		ПослСимвФам = Сред(Фамилия, ДлинаФам, 1);
		
		Если (ПослСимвФам = "а") или (ПослСимвФам = "я") Тогда  
			//женский род
			Если (ПослСимвФам = "о") или (ПослСимвФам = "и") или (ПослСимвФам = "х") или (ПослСимвФам = "ч") или (ПослСимвФам = "б") 
				или  (ПослСимвФам = "в") или (ПослСимвФам = "г") или (ПослСимвФам = "д") или (ПослСимвФам = "ж") или (ПослСимвФам = "з")
				или  (ПослСимвФам = "п") или (ПослСимвФам = "н") или (ПослСимвФам = "м") или (ПослСимвФам = "л") или (ПослСимвФам = "к")
				или  (ПослСимвФам = "р") или (ПослСимвФам = "с") или (ПослСимвФам = "т") или (ПослСимвФам = "ф") или (ПослСимвФам = "ц")
				или  (ПослСимвФам = "ь") или (ПослСимвФам = "щ") или (ПослСимвФам = "ш")   Тогда
				//в этом случае не склоняется  	
				Фамилия1 = СокрЛП(Фамилия);
			ИначеЕсли (ПослСимвФам = "я") Тогда 
				//обрезаем 2 символа и прибовляем "ой"	
				ФамилияОбрезанная = Сред(Фамилия,1,ДлинаФам-2);
				Фамилия1 = СокрЛП(ФамилияОбрезанная)+"ой";
			Иначе  
				//обрезаем 1 символа и прибавляем "ой"	
				ФамилияОбрезанная = Сред(Фамилия,1,ДлинаФам-1);
				Фамилия1 = СокрЛП(ФамилияОбрезанная)+"ой";
			КонецЕсли; 
		Иначе  
			Если (ПослСимвФам = "о") или (ПослСимвФам = "и") или (ПослСимвФам = "х") или (ПослСимвФам = "я") или (ПослСимвФам = "а") Тогда
				//в этом случае не склоняется  	
				Фамилия1 = Фамилия;
			ИначеЕсли (ПослСимвФам = "й") Тогда 
				//обрезаем 2 символа и прибавляем "ого"	
				ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам-2);
				Фамилия1 = ФамилияОбрезанная + "ого";
			Иначе  
				//прибавляем "а"	
				Фамилия1 = СокрЛП(Фамилия) + "а";
			КонецЕсли; 
		КонецЕсли;
		Фио1 = Фамилия1 + " " + ИО;
		Возврат ФИО1;
	ИначеЕсли Найти(ИО,".") <> 0 И НеСклонятьФамилию Тогда
		Возврат Фамилия + " " + ИО;
	КонецЕсли;	         
	
	//иначе если точек нет определяем род по отчеству  
	ДлинаОтчества = СтрДлина(СокрЛП(Отчество));
	ПослСимвОтч = Сред(Отчество, ДлинаОтчества, 1);
	Если ПослСимвОтч = "ч" Или Найти("ұлы, улы", Прав(Отчество, 3)) > 0 Тогда
		Мужской = 1;
	Иначе 
		Мужской = 0;
	КонецЕсли;
	
	Если Мужской = 1 Тогда
		Если НеСклонятьФамилию Тогда
			Фамилия1 = СокрЛП(Фамилия);
		Иначе
			
			//фамилия
			ДлинаФам = СтрДлина(СокрЛП(Фамилия));
			Если ДлинаФам <> 0 Тогда  
				ПослСимвФам = Сред(Фамилия, ДлинаФам, 1);
				Если (ПослСимвФам = "о") или (ПослСимвФам = "и") или (ПослСимвФам = "х") или (ПослСимвФам = "я") или (ПослСимвФам = "а") Тогда
					//в этом случае не склоняется  	
					Фамилия1 = Фамилия;
				ИначеЕсли (ПослСимвФам = "й") Тогда 
					//обрезаем 2 символа и прибавляем "ого"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 2);
					Фамилия1 = ФамилияОбрезанная + "ого";
				Иначе  
					//прибавляем "а"	
					Фамилия1 = СокрЛП(Фамилия) + "а";
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;   		
		//имя 
		
		ДлинаИмени = СтрДлина(СокрЛП(Имя));
		//проверем составное ли имя:
		НомерПозиции =Найти(Имя,"-");
		КоличествоИмен = 1;
		Имя1="";
		Если  НомерПозиции > 0 Тогда
			//это составное имя
			СтруктураИмен = Новый Структура;
			Имя_1 = СокрЛП(Сред(Имя,1,НомерПозиции-1));		
			Имя_2 = СокрЛП(Сред(Имя,НомерПозиции+1,ДлинаИмени));
			СтруктураИмен.Вставить("Имя_1", Имя_1);
			СтруктураИмен.Вставить("Имя_2", Имя_2);
			КоличествоИмен = 2;
		КонецЕсли;
		
		Для НомерИмени =1 По КоличествоИмен  Цикл
			Если КоличествоИмен = 1 Тогда
				Имя = Имя;
				СоеденительнаяИмен = "";
			Иначе
				ИмяКлюча = "Имя_" + Строка(НомерИмени);
				СоеденительнаяИмен = "-";
				СтруктураИмен.Свойство(ИмяКлюча, Имя);
			КонецЕсли;
			ДлинаИмени = СтрДлина(СокрЛП(Имя));
			
			Если ДлинаИмени <> 0 Тогда  
				ПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени, 1);
				Если (ПослСимвИмени = "й") или (ПослСимвИмени = "ь") Тогда 
					//обрезаем 1 символ и прибавляем "я"	
					ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени-1));
					Имя1 = Имя1 + Врег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2)  + "я";
				ИначеЕсли (ПослСимвИмени = "я") Тогда 
					//обрезаем 1 символ и прибавляем "и"	
					ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени-1));
					Имя1 = Имя1 + Врег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2)  + "и";	
				Иначе  
					//прибавляем "а"
					Имя = СокрЛП(Имя); 
					Имя1 = Имя1 + Врег(Лев(Имя,1)) + Сред(Имя,2)  + "а";
				КонецЕсли;  
			КонецЕсли;
			Если НомерИмени  = 1 Тогда
				Имя1= Имя1 +  СоеденительнаяИмен;
			КонецЕсли;  			
		КонецЦикла;
		
		//отчество   
		Если ДлинаОтчества <> 0 И Найти("ұлы, улы", Прав(Отчество,3)) = 0 Тогда  
			//прибавляем "а"	
			Отчество1 = СокрЛП(Отчество) + "а";
		Иначе
			Отчество1 = СокрЛП(Отчество);
		КонецЕсли;
		
	ИначеЕсли Мужской = 0 Тогда 
		//фамилия
		ДлинаФам = СтрДлина(СокрЛП(Фамилия)); 
		Если ДлинаФам <> 0 Тогда  
			Если НеСклонятьФамилию Тогда
				Фамилия1 = СокрЛП(Фамилия);
			Иначе
				
				ПослСимвФам = Сред(Фамилия,ДлинаФам,1);
				Если (ПослСимвФам = "о") или (ПослСимвФам = "и") или (ПослСимвФам = "х") или (ПослСимвФам = "ч") или (ПослСимвФам = "б") 
					или  (ПослСимвФам = "в") или (ПослСимвФам = "г") или (ПослСимвФам = "д") или (ПослСимвФам = "ж") или (ПослСимвФам = "з")
					или  (ПослСимвФам = "п") или (ПослСимвФам = "н") или (ПослСимвФам = "м") или (ПослСимвФам = "л") или (ПослСимвФам = "к")
					или  (ПослСимвФам = "р") или (ПослСимвФам = "с") или (ПослСимвФам = "т") или (ПослСимвФам = "ф") или (ПослСимвФам = "ц")
					или  (ПослСимвФам = "ь") или (ПослСимвФам = "щ") или (ПослСимвФам = "ш")   Тогда
					//в этом случае не склоняется  	
					Фамилия1 = СокрЛП(Фамилия);
				ИначеЕсли (ПослСимвФам = "я") Тогда 
					//обрезаем 2 символа и прибавляем "ой"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 2);
					Фамилия1 = СокрЛП(ФамилияОбрезанная) + "ой";
				Иначе  
					//обрезаем 1 символа и прибавляем "ой"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 1);
					Фамилия1 = СокрЛП(ФамилияОбрезанная) + "ой";
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;  		
		//имя 
		
		//проверем составное ли имя:
		НомерПозиции =Найти(Имя,"-");
		ДлинаИмени = СтрДлина(СокрЛП(Имя));
		КоличествоИмен = 1;
		Имя1="";
		Если  НомерПозиции > 0 Тогда
			//это составное имя, например  Мария-Тереза
			СтруктураИмен = Новый Структура;
			Имя_1 = СокрЛП(Сред(Имя,1,НомерПозиции-1));		
			Имя_2 = СокрЛП(Сред(Имя,НомерПозиции+1,ДлинаИмени));
			СтруктураИмен.Вставить("Имя_1", Имя_1);
			СтруктураИмен.Вставить("Имя_2", Имя_2);
			КоличествоИмен = 2;
		КонецЕсли;
		
		Для НомерИмени =1 По КоличествоИмен  Цикл
			Если КоличествоИмен = 1 Тогда
				Имя = Имя;
				СоеденительнаяИмен = "";
			Иначе
				ИмяКлюча = "Имя_" + Строка(НомерИмени);
				СоеденительнаяИмен = "-";
				СтруктураИмен.Свойство(ИмяКлюча, Имя);
			КонецЕсли;
			ДлинаИмени = СтрДлина(СокрЛП(Имя));
			
			Если ДлинаИмени <> 0 Тогда  
				ПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени, 1);
				ПредПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени-1, 1);
				
				Если (ПослСимвИмени = "а")  Тогда
					//в этом случае разбиваем на два
					Если (ПредПослСимвИмени = "и") или (ПредПослСимвИмени = "г") Тогда
						//обрезаем 1 символ и прибавляем "и"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
					Иначе
						//обрезаем 1 символ и прибавляем "ы"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "ы";
					КонецЕсли;
				ИначеЕсли (ПослСимвИмени = "я")  Тогда
					//в этом случае разбиваем на два
					Если (ПредПослСимвИмени = "и") Тогда
						//обрезаем 1 символ и прибавляем "и"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
					Иначе
						//обрезаем 1 символ и прибавляем "и"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
					КонецЕсли; 
				ИначеЕсли (ПослСимвФам = "ь") Тогда 
					//обрезаем 1 символ и прибавляем "и"	
					ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
				Иначе  
					//не изменяется	
					Имя = СокрЛП(Имя);
					Имя1 = Имя1 + Врег(Лев(Имя,1)) + Сред(Имя,2) ; 										
				КонецЕсли;
				Если  НомерИмени = 1 Тогда
					Имя1 = Имя1 + СоеденительнаяИмен;
				КонецЕсли;	
				
			КонецЕсли;
		КонецЦикла;
		
		//отчество  
		Если ДлинаОтчества<>0 И Найти("кызы, қызы", Прав(Отчество, 4)) = 0 Тогда  
			//обрезаем 1 символа и прибавляем "ы"	
			ОтчествоОбрезанное = Сред(Отчество, 1, ДлинаОтчества - 1);
			Отчество1 = СокрЛП(ОтчествоОбрезанное) + "ы";
		Иначе
			Отчество1 = СокрЛП(Отчество);
		КонецЕсли;	
	КонецЕсли;
	
	ФИО1 = ВРег(Лев(Фамилия1,1)) + Сред(Фамилия1, 2)+ " " +
	ВРег(Лев(Имя1,1)) + Сред(Имя1, 2) + " " +
	ВРег(Лев(Отчество1,1)) + Сред(Отчество1, 2); 
	
	Возврат ФИО1;
	
КонецФункции //ПреобразоватьФИОВРодительныйПадеж()

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт

	МассивСтрок = Новый Массив();

	Если Разделитель = " " Тогда

		Стр = СокрЛП(Стр);

		Пока 1 = 1 Цикл

			Поз = Найти(Стр,Разделитель);

			Если Поз = 0 Тогда

				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;

			КонецЕсли;

			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));

		КонецЦикла;

	Иначе

		ДлинаРазделителя = СтрДлина(Разделитель);

		Пока 1 = 1 Цикл

			Поз = Найти(Стр,Разделитель);
			Если Поз = 0 Тогда

				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;

			КонецЕсли;

			МассивСтрок.Добавить(Лев(Стр,Поз-1));

			Стр = Сред(Стр,Поз + ДлинаРазделителя);

		КонецЦикла;

	КонецЕсли;

КонецФункции // РазложитьСтрокуВМассивПодстрок()

// Дополняет строку указанным символом до указанной длины
//
// Параметры: 
//  Стр            - Дополняемая строка
//  Длина          - Требуемая длина результирующей строки
//  Чем            - Символ, которым дополняется строка
//
// Возвращаемое значение:
//  Строка дополненная указанным символом до указанной длины
//
Функция ДополнитьСтроку(Знач Стр, Длина, Чем=" ", Режим = 0) Экспорт
	
	СимволовДополнить = Длина -  СтрДлина(Стр);
	Добавок = "";
	Для Н=1 по СимволовДополнить Цикл
		Добавок =	Добавок + Чем;
	КонецЦикла;
	Возврат ?(Режим=0, Добавок + Стр, Стр + Добавок);
	
КонецФункции // ДополнитьСтроку()

//Выполняет в строке ГДЕ замену символов ЧТО на соответствующие по номерам символы из строки НаЧто
Функция ЗаменитьОдниСимволыДругими(Что,Где,НаЧто) Экспорт
	Рез = Где;
	Для Сч=1 По СтрДлина(Что) Цикл
		Рез = СтрЗаменить(Рез,Сред(Что,Сч,1),Сред(НаЧто,Сч,1));
	КонецЦикла;
	Возврат Рез;
КонецФункции // ЗаменитьОдниСимволыДругими 

Процедура ОтрицательныеЯчейкиОперацииКрасным(Элемент, ОформлениеСтроки, ДанныеСтроки, ВидУчета) Экспорт
	Если (ДанныеСтроки.Сумма <> Null) И (ДанныеСтроки.Сумма < 0) Тогда
		ОформлениеСтроки.Ячейки.Сумма.ЦветТекста = webЦвета.Красный;
	КонецЕсли;
	Если ВидУчета = "БУ" Тогда
		Если (ДанныеСтроки.ВалютнаяСуммаДт <> Null) И (ДанныеСтроки.ВалютнаяСуммаДт < 0) Тогда
			ОформлениеСтроки.Ячейки.ВалютнаяСуммаДт.ЦветТекста = webЦвета.Красный;
		КонецЕсли;
		Если (ДанныеСтроки.ВалютнаяСуммаКт <> Null) И (ДанныеСтроки.ВалютнаяСуммаКт < 0) Тогда
			ОформлениеСтроки.Ячейки.ВалютнаяСуммаКт.ЦветТекста = webЦвета.Красный;
		КонецЕсли;	
		Если (ДанныеСтроки.КоличествоДт <> Null) И (ДанныеСтроки.КоличествоДт < 0) Тогда
			ОформлениеСтроки.Ячейки.КоличествоДт.ЦветТекста = webЦвета.Красный;
		КонецЕсли;
		Если (ДанныеСтроки.КоличествоКт <> Null) И (ДанныеСтроки.КоличествоКт < 0) Тогда
			ОформлениеСтроки.Ячейки.КоличествоКт.ЦветТекста = webЦвета.Красный;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// функция из исходной строки формирует строку для поиска данных в запросе
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");

	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция преобразовывает строковое значение в дату
//
Функция ПолучитьДатуИзСтроки(Источник) Экспорт
	
	ПустаяДата = ПустоеЗначениеТипа(Тип("Дата"));
	
	Буфер = Источник;
	
	ПозицияТочки = Найти(Буфер, ".");
	
	Если ПозицияТочки = 0 Тогда
		Возврат ПустаяДата;
	КонецЕсли;
	
	ЧислоДаты = Лев(Буфер, ПозицияТочки - 1);
	Буфер = Сред(Буфер, ПозицияТочки + 1);
	
	ПозицияТочки = Найти(Буфер, ".");
	
	Если ПозицияТочки = 0 Тогда
		Возврат ПустаяДата;
	КонецЕсли;
	
	МесяцДаты = Лев(Буфер, ПозицияТочки - 1);
	ГодДаты = Сред(Буфер, ПозицияТочки + 1);
	
	Попытка 
		ПолученнаяДата = Дата(Число(ГодДаты), Число(МесяцДаты), Число(ЧислоДаты));;
	Исключение
		ПолученнаяДата = ПустаяДата;		
	КонецПопытки;
	
	Возврат ПолученнаяДата;
	
КонецФункции // ПолучитьДатуИзСтроки()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ДАТ

// Процедура вычисляет количество лет, месяцев и дней между двумя датами
//
// Параметры
//  Дата1	– дата, первая дата (более поздняя, часто текущая, стаж определяется по состоянию на эту дату)
//  Дата2	– дата, вторая дата (ранняя дата, с нее начинается "течение" стажа)
//  Лет		– Число, в этот параметр будет записано кол-во лет между двумя датами (Дата1-Дата2)
//  Месяцев	– Число, в этот параметр будет записано кол-во месяцев между двумя датами (Дата1-Дата2)
//  Дней	– Число, в этот параметр будет записано кол-во дней между двумя датами (Дата1-Дата2)
//
Процедура РазобратьРазностьДат(Дата1, Дата2, Лет = 0, Месяцев = 0, Дней = 0) Экспорт
	
	Лет		= 0;
	Месяцев	= 0;
	Дней	= 0;
	Если Дата1 > Дата2 Тогда
		
		ВременнаяДата = Дата1;
		Если День(ВременнаяДата) < День(Дата2) Тогда
			Дней = (ВременнаяДата - ДобавитьМесяц(ВременнаяДата,-1))/86400;
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-1);
		КонецЕсли;
		Если Месяц(ВременнаяДата) < Месяц(Дата2) Тогда
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-12);
			Месяцев = 12;
		КонецЕсли;
		Лет		= Макс(			 Год(ВременнаяДата)		- Год(Дата2),	0);
		Месяцев	= Макс(Месяцев	+ Месяц(ВременнаяДата)	- Месяц(Дата2),	0);
		Дней	= Макс(Дней		+ День(ВременнаяДата)	- День(Дата2),	0);
		
		// скорректируем отображаемое значение, если "вмешалось" разное количество дней в месяцах
		Если Дата2 <> (ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) Тогда
			Дней = Дней + (День(КонецМесяца(Дата2)) - День(НачалоМесяца(Дата2))) - (День(КонецМесяца(ДобавитьМесяц(Дата1,-1))) - День(НачалоМесяца(ДобавитьМесяц(Дата1,-1))));
		КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры	// РазобратьРазностьДат

//функция получает рабочую дату
//
Функция ПолучитьРабочуюДату() Экспорт 
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда 
		Дата = РабочаяДата; 
	#Иначе 
		Дата = ТекущаяДата(); 
	#КонецЕсли 
	
	Возврат Дата;
	
КонецФункции // ПолучитьРабочуюДату() 

// функция возвращает текстовое представление периода
//
Функция ПолучитьПредставлениеПериода(ДатаНачала, ДатаОкончания) Экспорт
	
	ТекстПериод = "";
	
	Если ЗначениеЗаполнено(ДатаОкончания) Тогда 
		Если ДатаОкончания >= ДатаНачала Тогда
			ТекстПериод = ПредставлениеПериода(НачалоДня(ДатаНачала), КонецДня(ДатаОкончания), "ФП");
		Иначе
			ТекстПериод = "";
		КонецЕсли;
	ИначеЕсли ЗначениеЗаполнено(ДатаНачала) И Не ЗначениеЗаполнено(ДатаОкончания) Тогда
		ТекстПериод = ПредставлениеПериода(НачалоДня(ДатаНачала), КонецДня(Дата(3999, 11, 11)), "ФП");
		ТекстПериод = СтрЗаменить(ТекстПериод, Сред(ТекстПериод, Найти(ТекстПериод, " - ")), " - ...");
	КонецЕсли;
	
	Возврат ТекстПериод;
	
КонецФункции // ПолучитьПредставлениеПериода

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

// Округляет число по заданному порядку. Если задан метод "ОкруглятьВБольшуюСторону",
// то число 123.37 при порядке округление 0.5 превратиться в 123.50, а число 0.1 
// при порядке округления 5 станет равным 5.
//
// Параметры:
//  Число                    - исходное число
//  ПорядокОкругления        - элемент перечисления Порядки окгугления: 
//                             "шаг" округления (0.01 (арифметическое), 0.01, 0.05, 0.1, 0.5, 1, 5, 10, 50, 100)
//	МетодОкругления			 - значение перечисления МетодыОкругления или булево (Истина = ВсегдаВБольшуюСторону, Ложь = ПоАрифметическимПравилам)
//  						   если Истина, то при порядке округления "5" 0.01 будет округлена до 5, 
//                             Ложь - округление по арифметическим правилам
//
// Возвращаемое значение:
//  Округленное по заданному порядку значение
//
Функция ОкруглитьЧисло(ЧислоДляОкругления, Знач ПорядокОкругления, Знач МетодОкругления) Экспорт

	Перем Результат;

	// Преобразуем порядок округления числа.
	// Если передали пустое значение порядка, то округлим до копеек. 
	Если НЕ ЗначениеЗаполнено(ПорядокОкругления) Тогда
		ПорядокОкругления = Перечисления.ПорядкиОкругления.Окр0_01; 
	КонецЕсли;

	Если Не ЗначениеЗаполнено(МетодОкругления) Тогда
		МетодОкругления = Перечисления.МетодыОкругления.ПоАрифметическимПравилам;
	КонецЕсли;

	Если ТипЗнч(МетодОкругления) = Тип("Булево") Тогда
		// в типах цен метод округления задается как булево (Истина - в большую сторону, Ложь - по арифметрическим правилам)
		Если МетодОкругления Тогда
			МетодОкругления = Перечисления.МетодыОкругления.ВсегдаВБольшуюСторону;
		Иначе
			МетодОкругления = Перечисления.МетодыОкругления.ПоАрифметическимПравилам;
		КонецЕсли;
	КонецЕсли;

	Порядок = Число(Строка(ПорядокОкругления));

	// вычислим количество интервалов, входящих в число
	КоличествоИнтервал = ЧислоДляОкругления / Порядок;

	// вычислим целое количество интервалов.
	КоличествоЦелыхИнтервалов = Цел(КоличествоИнтервал);

	Если КоличествоИнтервал = КоличествоЦелыхИнтервалов Тогда
		
		// Числа поделились нацело. Округлять не нужно.
		Результат = ЧислоДляОкругления;
	Иначе
		Если МетодОкругления = Перечисления.МетодыОкругления.ВсегдаВБольшуюСторону Тогда

			// При порядке округления "0.05" 0.371 должно округлитья до 0.4
			Результат = Порядок * (КоличествоЦелыхИнтервалов + 1);
			
		ИначеЕсли МетодОкругления = Перечисления.МетодыОкругления.ВсегдаВМеньшуюСторону Тогда
			
			// При порядке округления "0.05" 0.371 и 0.376 должно округлиться до 0.35
			Результат = Порядок * КоличествоЦелыхИнтервалов;
			
		Иначе

			// При порядке округления "0.05" 0.371 должно округлитья до 0.35,
			// а 0.376 до 0.4
			Результат = Порядок * Окр(КоличествоИнтервал,0,РежимОкругления.Окр15как20);
		КонецЕсли;

	КонецЕсли;

	Возврат Результат;

КонецФункции // ОкруглитьЧисло()

// возвращает "количество полных и неполных тенге"
// Параметры:
//	Сумма - число
// Возвращаемое значение:
//  число, равное ближайшему целому "сверху"
Функция ЦелМаксимальное(Сумма) Экспорт
	
	Возврат ?(Цел(Сумма) = Сумма, Сумма, Цел(Сумма) + 1);
	
КонецФункции // ЦелМаксимальное()

// Преобразует шестнадцатиричное число в десятичное
// 
// Параметры:
//	Источник - строка с шестнадцатиричным числом
//
// Возвращаемое значение:
//	Число - десятичное число
//
Функция ШестнадцатиричноеВДесятичное(Источник) Экспорт
	
	Результат = 0;
	
	Для Поз = 1 По СтрДлина(Источник) Цикл
		ТекКод = КодСимвола(Источник, Поз);
		
		Если ТекКод >= КодСимвола("0") И ТекКод <= КодСимвола("9") Тогда
			ТекКод = ТекКод - КодСимвола("0");
		ИначеЕсли ТекКод >= КодСимвола("a") И ТекКод <= КодСимвола("f") Тогда
			ТекКод = ТекКод +10 - КодСимвола("a");
		ИначеЕсли ТекКод >= КодСимвола("A") И ТекКод <= КодСимвола("F") Тогда
			ТекКод = ТекКод +10 - КодСимвола("A");
		КонецЕсли;
		
		Результат = Результат * 16 + ТекКод;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ШестнадцатиричноеВДесятичное()

// Преобразует десятичное число в шестнадцатиричное
// 
// Параметры:
//	Источник - число (десятичное) от 0 до 255
//
// Возвращаемое значение:
//	Строка - десятичное число
//
Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШестнадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВторойСимвол	= Источник % 16;
	
	Возврат Сред(ШестнадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШестнадцатиричныеСимволы, ВторойСимвол, 1);
	
КонецФункции // ДесятичноеВШестнадцатиричное()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность,РазрядностьДробнойЧасти=0) Экспорт

	Массив = Новый Массив;

	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);

	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла() 

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции // ПолучитьОписаниеТиповДаты() 

// Служебная функция - возвращает принадлежность объекта метаданных определенному классу
// 
// Параметры:
//	Класс  - класс
//	Объект - объект метаданных
// 
Функция ПринадлежностьКлассуМетаданных(Класс, Объект) Экспорт
	
	Для Каждого МДОбъект Из Метаданные[Класс] Цикл
		Если МДОбъект = Объект Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции // ПринадлежностьКлассуМетаданных()

// Проверяет указанное ОписаниеТипов на наличие только примитивных типов.
Функция СодержитТолькоПримитивныеТипы(ПроверяемоеОписаниеТипов) Экспорт

	Если ПроверяемоеОписаниеТипов = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	МассивПримитивныхТипов 		= Новый Массив(4);
	МассивПримитивныхТипов[0]	= Тип("Строка");
	МассивПримитивныхТипов[1] 	= Тип("Число");
	МассивПримитивныхТипов[2]   = Тип("Дата");
	МассивПримитивныхТипов[3] 	= Тип("Булево");
	
	ОбщееКоличествоТипов = ПроверяемоеОписаниеТипов.Типы().Количество();
	
	Для Каждого ПроверяемыйПримитивныйТип Из МассивПримитивныхТипов Цикл
		Если ПроверяемоеОписаниеТипов.СодержитТип(ПроверяемыйПримитивныйТип) Тогда
			ОбщееКоличествоТипов = ОбщееКоличествоТипов - 1;
			
			Если ОбщееКоличествоТипов = 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Возврат ОбщееКоличествоТипов = 0;

КонецФункции // СодержитТолькоПримитивныеТипы()

// Проверить, что значение имеет ссылочный тип данных.
//
// Параметры:
//  Значение       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Булево       - Истина, если тип значения ссылочный.
//
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Задачи.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ ОПРЕДЕЛЕНИЯ ТИПА ОБЪЕКТА МЕТАДАННЫХ

// ссылочные типы данных
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаДокументы();
	
КонецФункции

Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаСправочники();
	
КонецФункции

Функция ЭтоПланОбмена(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыОбмена();
	
КонецФункции

Функция ЭтоПланВидовХарактеристик(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовХарактеристик();
	
КонецФункции

Функция ЭтоБизнесПроцесс(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаБизнесПроцессы();
	
КонецФункции

Функция ЭтоЗадача(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЗадачи();
	
КонецФункции

Функция ЭтоПланСчетов(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыСчетов();
	
КонецФункции

Функция ЭтоПланВидовРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовРасчета();
	
КонецФункции

// регистры
Функция ЭтоРегистрСведений(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыСведений();
	
КонецФункции

Функция ЭтоРегистрНакопления(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыНакопления();
	
КонецФункции

Функция ЭтоРегистрБухгалтерии(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыБухгалтерии();
	
КонецФункции

Функция ЭтоРегистрРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыРасчета();
	
КонецФункции

// константы
Функция ЭтоКонстанта(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаКонстанты();
	
КонецФункции

// общие
Функция ЭтоРегистр(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаРегистрыСведений()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыНакопления()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыБухгалтерии()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыРасчета();
	
КонецФункции

Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаДокументы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаБизнесПроцессы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаЗадачи()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета();
	
КонецФункции
	
	
// Возвращает имя базового типа по переданному значению объекта метаданных
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
		
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаКонстанты();
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по ссылке на объект
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции
	
	
////////////////////////////////////////////////////////////////////////////////
// КОНСТАНТЫ

Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции


// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	Для Каждого Элемент Из МассивИсточник Цикл
		
		Если МассивПриемник.Найти(Элемент) = Неопределено Тогда
			
			МассивПриемник.Добавить(Элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Получить значение одного реквизита по ссылке.
// Например, для элемента справочника нужно получить наименование,
// в этом случае в качестве ИмяРеквизита нужно передать "Наименование".
//
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
	
	Возврат Результат[ИмяРеквизита];
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтправителя");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресCервераSMTP");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_ПортSMTP");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра

	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
	КонецЕсли; 
	
	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;
	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
		
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
		Если СтрокаРаздела = Неопределено Тогда
			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Попытка
			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли; 
		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;
		МассивЗначений.Добавить("");
		
		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
		
	КонецЦикла;
	
	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
	
КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8" + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если НЕ ЗначениеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
		
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ПРОВЕРКИ КОРРЕКТНОСТИ ЗАПОЛНЕНИЯ ДАННЫХ

// Проверяет соответствие РНН требованиям
// Параметры:
//		РНН - строка - проверяемый регистрационный номер налогоплательщика
//		
Функция РННСоответствуетТребованиям(Знач РНН, ВыводитьСообщение = Истина) Экспорт

	РНН		 = СокрЛП(РНН);
	ДлинаРНН = СтрДлина(РНН);
	
	//Проверка на длину РНН
	Если ДлинаРНН < 12 Тогда
		Если ВыводитьСообщение Тогда
			Сообщить("Количество знаков в РНН меньше 12!");
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	// В РНН имеются символы, отличные от цифр (0..9)
	РННБезНулей = СтрЗаменить(РНН,"0","1");
	Попытка
	    ЧислоРНН = Число(РННБезНулей);
		Если ЧислоРНН <> Цел(ЧислоРНН) Тогда // Есть символ "." или ","
			Если ВыводитьСообщение Тогда
				Сообщить("РНН содержит символы отличные от цифр!");
			КонецЕсли;
			Возврат Ложь;
		КонецЕсли;
	Исключение
		Если ВыводитьСообщение Тогда
			Сообщить("РНН содержит символы отличные от цифр!");
		КонецЕсли;
		Возврат Ложь;
	КонецПопытки; 
		
	// Проверка на одинаковость всех цифр
	Если СтрЧислоВхождений(РНН, Лев(РНН, 1)) = 12 Тогда 
		Если ВыводитьСообщение Тогда
			Сообщить("Цифра " + Лев(РНН, 1) + " повторяется 12 раз!");
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	// Проверка РНН на корректность   
	ПодстрокаРНН11 	 = Лев(РНН, 11);	// копируем первые 11 символов
	КонтрольнаяСумма = Прав(РНН, 1);	// контрольная сумма РНН
	
	Для СчетчикЦикла1 = 1 По 10 Цикл
		
		СуммаПроизведений = 0;
		Вес = СчетчикЦикла1 - 1;
		
		// Накапливаем сумму произведений
		Для СчетчикЦикла2 = 1 По 11 Цикл
			
			Вес = Вес + 1;
			
			Если Вес = 11 Тогда 
				Вес = 1; //сбросили вес на единицу
			КонецЕсли;
			
			СуммаПроизведений =  СуммаПроизведений + Вес * Число(Сред(ПодстрокаРНН11, СчетчикЦикла2, 1));
			
		КонецЦикла;
		
		//Рассчитываем коэфиициент для проверка РНН 
		Коэффициент = СуммаПроизведений - Цел((СуммаПроизведений) / 11) * 11;
		
		Если Коэффициент < 10 Тогда 
			
			Если Коэффициент <> Число(КонтрольнаяСумма) Тогда // Проверка равенства полученного коэффициента Контрольной сумме
				Если ВыводитьСообщение Тогда
					Сообщить("Введенный РНН не корректен!");
				КонецЕсли;
				Возврат Ложь;
			КонецЕсли; 
			
			Прервать;
			
		КонецЕсли;        			
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // РННСоответствуетТребованиям()

// Проверяет соответствие БИН или ИИН требованиям
// Параметры:
//		ИдентификационныйНомер - строка - проверяемый БИН или ИИН налогоплательщика
//		
Функция БИНИИНСоответствуетТребованиям(Знач ИИН_БИН, ВыводитьСообщение = Истина) Экспорт

	ИИН_БИН	     = СокрЛП(ИИН_БИН);
	ДлинаИИН_БИН = СтрДлина(ИИН_БИН);
	
	//Проверка на длину ИИН/БИН
	Если ДлинаИИН_БИН < 12 Тогда
		
		Если ВыводитьСообщение Тогда
			Сообщить("Количество знаков в ИИН/БИН меньше 12!");
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецЕсли;

	// В ИИН/БИН имеются символы, отличные от цифр (0..9)
	ИИН_БИНБезНулей = СтрЗаменить(ИИН_БИН, "0", "1");
	
	Попытка
	    ЧислоИИН_БИН = Число(ИИН_БИНБезНулей);
		
		Если ЧислоИИН_БИН <> Цел(ЧислоИИН_БИН) Тогда // Есть символ "." или ","
			Если ВыводитьСообщение Тогда
				Сообщить("ИИН/БИН содержит символы отличные от цифр!");
			КонецЕсли;
			Возврат Ложь;
		КонецЕсли;		

	Исключение
		
		Если ВыводитьСообщение Тогда
			Сообщить("ИИН/БИН содержит символы отличные от цифр!");
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецПопытки; 

	// Проверка на одинаковость всех цифр
	Если СтрЧислоВхождений(ИИН_БИН, Лев(ИИН_БИН, 1)) = 12 Тогда
		
		Если ВыводитьСообщение Тогда
			Сообщить("Цифра " + Лев(ИИН_БИН, 1) + " повторяется 12 раз!");
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецЕсли;

	// а12=(а1*b1+а2*b2+а3*b3+а4*b4+а5*b5+а6*b6+а7*b7+а8*b8+а9*b9+a10*b10+a11*b11) mod 11
	ПодстрокаИН11 		= Лев(ИИН_БИН, 11);	// копируем первые 11 символов
	КонтрольноеЗначение = Прав(ИИН_БИН, 1);	// контрольная сумма ИИН/БИН
	         
	//разряд ИИН:  1 2 3 4 5 6 7 8 9 10 11
	//вес разряда: 1 2 3 4 5 6 7 8 9 10 11.

	СуммаРазрядов = 1 * Сред(ИИН_БИН, 1, 1) + 2 * Сред(ИИН_БИН, 2, 1) + 3 * Сред(ИИН_БИН, 3, 1) + 4 * Сред(ИИН_БИН, 4, 1) + 5 * Сред(ИИН_БИН, 5, 1) + 6 * Сред(ИИН_БИН, 6, 1)
					+ 7 * Сред(ИИН_БИН, 7, 1)+ 8 * Сред(ИИН_БИН, 8, 1) + 9 * Сред(ИИН_БИН, 9, 1) + 10 * Сред(ИИН_БИН, 10, 1) + 11 * Сред(ИИН_БИН, 11, 1);
					
	ВычисленноеКонтрольноеЗначение = СуммаРазрядов - Цел(СуммаРазрядов / 11) * 11; // mod - остаток от деления Суммы разрядов на 11.
	
	Если ВычисленноеКонтрольноеЗначение = 10 Тогда
		//разряд ИИН:  1 2 3 4 5 6 7 8 9 10 11 
		//вес разряда: 3 4 5 6 7 8 9 10 11 1 2.

		СуммаРазрядов = 3 * Сред(ИИН_БИН, 1, 1) + 4 * Сред(ИИН_БИН, 2, 1) + 5 * Сред(ИИН_БИН, 3, 1) + 6 * Сред(ИИН_БИН, 4, 1) + 7 * Сред(ИИН_БИН, 5, 1) + 8 * Сред(ИИН_БИН, 6, 1)
						+ 9 * Сред(ИИН_БИН, 7, 1) + 10 * Сред(ИИН_БИН, 8, 1) + 11 * Сред(ИИН_БИН, 9, 1) + 1*Сред(ИИН_БИН, 10, 1) + 2 * Сред(ИИН_БИН, 11, 1);
		ВычисленноеКонтрольноеЗначение = СуммаРазрядов - Цел(СуммаРазрядов / 11) * 11;   
		
	КонецЕсли;
	
	Если ВычисленноеКонтрольноеЗначение <> Число(КонтрольноеЗначение) Тогда
		
		Если ВыводитьСообщение Тогда
			Сообщить("Введенный ИИН/БИН не корректен!");
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецЕсли;	
	
	Возврат Истина;
	
КонецФункции // РННСоответствуетТребованиям()

// Проверяет соответствие СИК требованиям
// Параметры:
//		СИК - строка - проверяемый социальный индивидуальный код
//		
Функция СИКСоответствуетТребованиям(Знач СИК, ВыводитьСообщение = Истина) Экспорт

	СИК		 = СокрЛП(СИК);
	ДлинаСИК = СтрДлина(СИК);
	
	//Проверка на длину СИК
	Если ДлинаСИК < 16 Тогда
		Если ВыводитьСообщение Тогда
			Сообщить("Количество знаков в СИК меньше 16!");
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	// Проверка на одинаковость всех цифр
	Если СтрЧислоВхождений(СИК, Лев(СИК, 1)) = 16 Тогда 
		Если ВыводитьСообщение Тогда
			Сообщить("Цифра " + Лев(СИК, 1) + " повторяется 16 раз!");
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;

	// Проверка на наличие символов, отличных от букв латинского алфавита
	Для Н = 1 По ДлинаСИК Цикл
		Если Найти("ABCDEFGHIJKLMNPQRSTUVWXYZ0123456789", Сред(СИК, Н, 1)) = 0 Тогда
			Если ВыводитьСообщение Тогда
				Сообщить("Недопустимый символ " + Сред(СИК, Н, 1) + " (позиция " + Н + ")");
			КонецЕсли;
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;

КонецФункции // ПолучитьСписокЭлементовПеречисления()

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Возвращает сокращенный уникальный идентификатор текущей конфигурации
//
Функция ИДКонфигурации() Экспорт
	МетаданныеИмя = Метаданные.Имя;
		
	Если МетаданныеИмя = "БухгалтерияДляКазахстана" ИЛИ МетаданныеИмя = "БухгалтерияДляКазахстанаБазовая" Тогда
		Возврат "БК";
	ИначеЕсли МетаданныеИмя = "ЗарплатаИУправлениеПерсоналомДляКазахстана" Тогда
		Возврат "ЗУПК";
	ИначеЕсли МетаданныеИмя = "УправлениеТорговлейДляКазахстана" ИЛИ МетаданныеИмя = "УправлениеТорговлейДляКазахстанаБазовая" Тогда
		Возврат "УТК";
	ИначеЕсли МетаданныеИмя = "УправлениеТорговымПредприятиемДляКазахстана" Тогда
		Возврат "УТПК";
	ИначеЕсли МетаданныеИмя = "УправлениеПроизводственнымПредприятиемДляКазахстана" Тогда
		Возврат "УППК";
	ИначеЕсли МетаданныеИмя = "КомплексноеУправлениеФинансамиИБюджетированиеДляКазахстана" Тогда
		Возврат "УФИБК";
	Иначе
		Возврат МетаданныеИмя;
	КонецЕсли;
	
КонецФункции

// Получаем из полного номера версии конфигурации номер релиза без номера сборки.
//
// Параметры
//  НомерВерсии  – Строка – полный номер версии
//
// Возвращаемое значение:
//  Строка – номер релиза без номера сборки
//
Функция ПолучитьНомерРелиза(НомерВерсии) Экспорт

	КоличествоТочек = 0;
	ДлинаОписанияНомераРелиза = 0;

	Для х = 1 По СтрДлина(НомерВерсии) Цикл

		Если Сред(НомерВерсии, х, 1) = "." Тогда
			КоличествоТочек = КоличествоТочек + 1;
		КонецЕсли;

		Если КоличествоТочек = 3 Тогда
			ДлинаОписанияНомераРелиза = х - 1;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Возврат Лев(НомерВерсии, ДлинаОписанияНомераРелиза);

КонецФункции // ПолучитьНомерРелиза()

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Булево: Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Возврат НЕ (МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;

	Иначе
		Возврат НЕ (ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

	КонецЕсли;

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Позволяет определить есть ли среди реквизитов шапки отчета
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита     - строковое имя искомого реквизита, 
//  МетаданныеОтчета - метаданные отчета, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОтчета(ИмяРеквизита, МетаданныеОтчета) Экспорт

	Если МетаданныеОтчета.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьРеквизитОтчета()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьТабЧастьДокумента()

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	Возврат Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;

КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

// Функция возвращает Истина, если в указанном объекте (плане/справочнике) существует 
// предопределенный элемент с заданным именем (план видов расчета, план видов характеристик, 
// план счетов, справочник)
//
// Параметры:
//	МетаданныеОбъекта - метаданные объекта, в котором искать
//	ИмяПредопределенного - строка с именем предопределенного вида для поиска
//
// Возвращаемое значение:
//	Истина, если предопределенный элемент есть, иначе Ложь
//
Функция ЕстьПредопределенныйЭлемент(ИмяПредопределенного, МетаданныеОбъекта) Экспорт

	ИмяОбъекта = ВРег(МетаданныеОбъекта.Имя);
	Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
		ВидОбъекта = "ПланВидовРасчета";
		МенеджерОбъекта = ПланыВидовРасчета[ИмяОбъекта];
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
		ВидОбъекта = "ПланВидовХарактеристик";
		МенеджерОбъекта = ПланыВидовХарактеристик[ИмяОбъекта];
	ИначеЕсли Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
		ВидОбъекта = "ПланСчетов";
		МенеджерОбъекта = ПланыСчетов[ИмяОбъекта];
	ИначеЕсли Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
		ВидОбъекта = "Справочник";
		МенеджерОбъекта = Справочники[ИмяОбъекта];
	Иначе
		Возврат Ложь;
	КонецЕсли;
		
	// составим запрос для выбора всех предопределенных элементов объекта
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ОбъектМетаданных.Ссылка
	|ИЗ
	|	" + ВидОбъекта + "." + ИмяОбъекта + " КАК ОбъектМетаданных
	|ГДЕ
	|	ОбъектМетаданных.Предопределенный
	|";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ИмяОчередногоПредопределенного = ВРег(МенеджерОбъекта.ПолучитьИмяПредопределенного(Выборка.Ссылка));
		Если ВРег(ИмяПредопределенного) = ИмяОчередногоПредопределенного Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;

	Возврат Ложь;

КонецФункции // ЕстьПредопределенныйЭлемент

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Процедура удаления существующих движений документа при перепроведении (отмене проведения)
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, РучнаяКорректировка = Ложь) Экспорт
	
	// получение списка регистров, по которым существуют движения
	ТаблицаДвижений = ПолныеПрава.ОпределитьНаличиеДвиженийПоРегистратору(ДокументОбъект.Ссылка);
	ТаблицаДвижений.Колонки.Добавить("НаборЗаписей");
		
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		// имя регистра передается как значение, полученное с помощью
		// функции ПолноеИмя() метаданных регистра
		ПозицияТочки = Найти(СтрокаДвижения.Имя, ".");
		ТипРегистра = Лев(СтрокаДвижения.Имя, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(СтрокаДвижения.Имя, ПозицияТочки + 1));
		
		Если РучнаяКорректировка Тогда
			Набор = ДокументОбъект.Движения[ИмяРегистра];
			Набор.Прочитать();
			Набор.УстановитьАктивность(Ложь);
			
		Иначе
			ЕСли ТипРегистра = "РегистрНакопления" Тогда
				МетаданныеНабора = Метаданные.РегистрыНакопления[ИмяРегистра];
				Набор = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
				
			ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
				МетаданныеНабора = Метаданные.РегистрыБухгалтерии[ИмяРегистра];
				Набор = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
				
			ИначеЕсли ТипРегистра = "РегистрСведений" Тогда
				МетаданныеНабора = Метаданные.РегистрыСведений[ИмяРегистра];
				Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
				
			ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
				МетаданныеНабора = Метаданные.РегистрыРасчета[ИмяРегистра];
				Набор = РегистрыРасчета[ИмяРегистра].СоздатьНаборЗаписей();
				
			КонецЕсли;
			
			Если НЕ ПравоДоступа("Изменение", МетаданныеНабора) Тогда
				// отсутствуют права на всю таблицу регистра
				СообщитьОбОшибке("Нарушение прав доступа", Отказ, СтрокаДвижения.Имя);
				Возврат;
			КонецЕсли;
			
			Набор.Отбор.Регистратор.Установить(ДокументОбъект.Ссылка);			
			// набор не записывается сразу, чтобы не откатывать транзакцию, если впоследствии
			// выяснится, что на один из регистров не хватает прав.
		КонецЕсли;
		
		СтрокаДвижения.НаборЗаписей = Набор;		
		
	КонецЦикла;	
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл		
		Попытка
			СтрокаДвижения.НаборЗаписей.Записать();
		Исключение
			// возможно «сработал» RLS или механизм даты запрета изменения
			СообщитьОбОшибке(ОписаниеОшибки(), Отказ, СтрокаДвижения.Имя);
			ВызватьИсключение "Операция не выполнена";
		КонецПопытки;
	КонецЦикла;
	
	Если (НЕ Отказ) И (НЕ РучнаяКорректировка) Тогда
		Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
			Если Движение.Количество() > 0 Тогда
				Движение.Очистить();
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Удаление записей регистрации из всех последовательностей
	УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);

КонецПроцедуры

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений   - набор движений регистра. 
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено, ЗаполнитьПериод = истина) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	//
	КолонкиТаблицы = ТаблицаДвижений.Колонки;
	
	//
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	ИзмеренияСостТипаСтр = "";
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаИзм.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаИзм.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРек.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРек.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРек.Имя;
			КонецЕсли; 
			
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРес.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРес.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРес.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	
	Если ИзмеренияСостТипаСтр <> "" Тогда
		ИзмеренияСостТипаСтр = Сред(ИзмеренияСостТипаСтр, 3);
	КонецЕсли;
	
	ТипЧисло = Тип("Число");
	ТипСтрока = Тип("Строка");
	ТипДата = Тип("Дата");
	
	ЕстьПериод = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;

	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		Движение = НаборДвижений.Добавить();
		ЗаполнитьЗначенияСвойств(Движение, СтрокаДвижения, ,ИзмеренияСостТипаСтр);
		
		Если ВидДвижения <> Неопределено Тогда
			Движение.ВидДвижения = ВидДвижения;
		КонецЕсли;
		
		Если НЕ ЗаполнитьПериод И ЕстьПериод И НЕ СтрокаДвижения.Период = '00010101000000' Тогда
			Движение.Период = СтрокаДвижения.Период;
		Иначе
			Движение.Период = НаборДвижений.мПериод;
		КонецЕсли; 
		Движение.Активность = Истина;
		
		Для Каждого КлючИЗначение ИЗ ИзмеренияСостТипа Цикл
			ЗначениеВКолонке = СтрокаДвижения[КлючИЗначение.Ключ];
			
			Если ЗначениеВКолонке = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗначенияВКолонке = ТипЗнч(ЗначениеВКолонке);
			
			Если ТипЗначенияВКолонке = ТипЧисло Тогда
				Если ЗначениеВКолонке = 0 Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипСтрока Тогда
				Если ЗначениеВКолонке = "" Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипДата Тогда
				Если ЗначениеВКолонке = '00010101000000' Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ЗначениеВКолонке.Пустая() Тогда
				Продолжить;
			КонецЕсли;
			
			Движение[КлючИЗначение.Ключ] = ЗначениеВКолонке;
			
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Процедура включения активности движений при проведении документа, движения которого
// заданы вручную
Процедура ВключитьАктивностьПоРегистратору(ДокументОбъект, Отказ) Экспорт
	
	// получение списка регистров, по которым существуют движения
	ТаблицаДвижений = ПолныеПрава.ОпределитьНаличиеДвиженийПоРегистратору(ДокументОбъект.Ссылка);
	ТаблицаДвижений.Колонки.Добавить("НаборЗаписей");
		
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		// имя регистра передается как значение, полученное с помощью
		// функции ПолноеИмя() метаданных регистра
		ПозицияТочки = Найти(СтрокаДвижения.Имя, ".");
		ТипРегистра = Лев(СтрокаДвижения.Имя, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(СтрокаДвижения.Имя, ПозицияТочки + 1));
		
		Набор = ДокументОбъект.Движения[ИмяРегистра];
		Набор.Прочитать();
		Набор.УстановитьАктивность(Истина);
			
		СтрокаДвижения.НаборЗаписей = Набор;		
		
	КонецЦикла;	
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл		
		Попытка
			СтрокаДвижения.НаборЗаписей.Записать();
		Исключение
			// возможно «сработал» RLS или механизм даты запрета изменения
			СообщитьОбОшибке(ОписаниеОшибки(), Отказ, СтрокаДвижения.Имя);
			ВызватьИсключение "Операция не выполнена";
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	ВалютаРегламентированногоУчета = Константы.ВалютаРегламентированногоУчета.Получить();

	//Первоначальные данные о документе
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата",   ДокументОбъект.Дата);
	СтруктураШапкиДокумента.Вставить("Номер",  ДокументОбъект.Номер);

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  МетаданныеДокумента.Имя);
	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
    
	Для каждого Реквизит из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
		Если Реквизит.Имя = "Организация" Тогда
			СтруктураШапкиДокумента.Вставить("ГоловнаяОрганизация", ГоловнаяОрганизация(ДокументОбъект[Реквизит.Имя]));
		КонецЕсли;	
	КонецЦикла;

	//Отображение данных о валютах
	СтруктураШапкиДокумента.Вставить("ВалютаРегламентированногоУчета", ВалютаРегламентированногоУчета);	

	Если СтруктураШапкиДокумента.Свойство("ВалютаДокумента") Тогда
		СтруктураШапкиДокумента.Вставить("КурсДокумента",      КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
		СтруктураШапкиДокумента.Вставить("КратностьДокумента", КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));

	КонецЕсли;
	
	//Отображение обязательных данных о договоре
	Если СтруктураШапкиДокумента.Свойство("ДоговорКонтрагента") Тогда

		Если ТипЗнч(СтруктураШапкиДокумента.ДоговорКонтрагента) = Тип("СправочникСсылка.ДоговорыКонтрагентов") тогда

			СтруктураШапкиДокумента.Вставить("ВедениеВзаиморасчетов",    СтруктураШапкиДокумента.ДоговорКонтрагента.ВедениеВзаиморасчетов);
			СтруктураШапкиДокумента.Вставить("ВалютаВзаиморасчетов",     СтруктураШапкиДокумента.ДоговорКонтрагента.ВалютаВзаиморасчетов);

		КонецЕсли;

	КонецЕсли;

	Возврат СтруктураШапкиДокумента;

КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Формирует структуру дерева значений, содержащего имена полей, которые
// нужно заполнить в запросе по шапке документа.
//
// Параметры: 
//  Нет.
//
// Возвращаемое значение:
//  Дерево значений.
//
Функция СформироватьДеревоПолейЗапросаПоШапке()  Экспорт

	ДеревоПолейЗапросаПоШапке = Новый ДеревоЗначений;
	ОписаниеТиповСтрока       = ПолучитьОписаниеТиповСтроки(100);

	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Объект"   , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Поле"     , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Псевдоним", ОписаниеТиповСтрока);

	Возврат ДеревоПолейЗапросаПоШапке;

КонецФункции // СформироватьДеревоПолейЗапросаПоШапке()

// Вставляет строку в дерево полей запроса по шапке, если ее там еще нет,
// если есть, то ничего не делает.
//
// Параметры:
//  ДеревоПолейЗапросаПоШапке - дерево значений, содержащего имена полей, 
//                              которые нужно заполнить в запросе по шапке документа, 
//  ИмяОбъекта                - строка, имя объекта (справочник, регистр и т.д.), 
//  ИмяПоля                   - строка, имя поля объекта,
//  ИмяПсевдонима             - строка, имя псевдонима в запросе поля объекта (необязательный).
//
Процедура ДобавитьСтрокуВДеревоПолейЗапросаПоШапке(ДеревоПолейЗапросаПоШапке, ИмяОбъекта, ИмяПоля, ИмяПсевдонима = Неопределено) Экспорт

	// Поищем нужную строку.
	// Вначале ищем объект.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти(ИмяОбъекта, "Объект");

	Если СтрокаОбъекта = Неопределено Тогда // нужно добавить.

		СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Добавить();

		СтрокаОбъекта.Объект    = ИмяОбъекта;
		СтрокаОбъекта.Поле      = ИмяПоля;
		СтрокаОбъекта.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем поле.
	СтрокаПоля = СтрокаОбъекта.Строки. Найти(ИмяПоля,"Поле");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем псевдоним.
	СтрокаПоля = СтрокаОбъекта.Строки.Найти( ИмяПсевдонима, "Псевдоним");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

КонецПроцедуры // ДобавитьСтрокуВДеревоПолейЗапросаПоШапке()

// Формирует структуру дерева значений, содержащего имена полей, которые
// нужно заполнить в запросе по шапке документа.
//
// Параметры: 
//  Нет.
//
// Возвращаемое значение:
//  Дерево значений.
//
Функция СформироватьТаблицуУчастниковСовместнойДеятельности(УчастникиСовместнойДеятельности)  Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	УчастникиСовместнойДеятельности.НомерСтроки,
		|	УчастникиСовместнойДеятельности.УчастникСовместнойДеятельности,
		|	УчастникиСовместнойДеятельности.ДоляУчастия
		|ПОМЕСТИТЬ ВТ_УчастникиСовместнойДеятельности
		|ИЗ
		|	&УчастникиСовместнойДеятельности КАК УчастникиСовместнойДеятельности
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	СУММА(ВТ_УчастникиСовместнойДеятельности.ДоляУчастия) КАК СуммаДолейУчастия
		|ПОМЕСТИТЬ ВТ_Суммы
		|ИЗ
		|	ВТ_УчастникиСовместнойДеятельности КАК ВТ_УчастникиСовместнойДеятельности
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВТ_УчастникиСовместнойДеятельности.НомерСтроки КАК НомерСтроки,
		|	ВТ_УчастникиСовместнойДеятельности.УчастникСовместнойДеятельности,
		|	ВТ_УчастникиСовместнойДеятельности.ДоляУчастия,
		|	ВТ_Суммы.СуммаДолейУчастия
		|ИЗ
		|	ВТ_УчастникиСовместнойДеятельности КАК ВТ_УчастникиСовместнойДеятельности,
		|	ВТ_Суммы КАК ВТ_Суммы
		|
		|УПОРЯДОЧИТЬ ПО
		|	НомерСтроки";
    Запрос.УстановитьПараметр("УчастникиСовместнойДеятельности", УчастникиСовместнойДеятельности);
	Результат = Запрос.Выполнить();

	Если НЕ Результат.Пустой() Тогда 
		Возврат Результат.Выгрузить();
	Иначе 
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // СформироватьДеревоПолейЗапросаПоШапке()

// Проверка ручной корректировки
//
Функция РучнаяКорректировкаОбработкаПроведения(РучнаяКорректировка, Отказ, Заголовок, ЭтотОбъект)  Экспорт
	
	Если РучнаяКорректировка Тогда
		ВключитьАктивностьПоРегистратору(ЭтотОбъект, Отказ);
		ТекстСообщения = "Движения документа отредактированы вручную и не могут быть автоматически актуализированы.";
		СообщитьОбОшибке(ТекстСообщения, , Заголовок);
		Возврат Истина;
	Иначе
		УдалитьДвиженияРегистратора(ЭтотОбъект, Отказ);
		Возврат Ложь;
	КонецЕсли;
 	
КонецФункции // РучнаяКорректировкаОбработкаПроведения()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ ДОКУМЕНТАМИ

// Возвращает значение дополнительного префикса номера документа
//
// Параметры:
//  Документ - (ДокументОбъект), документ, чей дополнительный префикс надо получить для печати.
//
// Возвращаемое значение.
//  Строка - дополнительный префикс документа для печати
//
Функция ПолучитьДополнительныйПрефиксНомераДокумента(Документ)
	
	// КУФИБ - начало
	
	Если ТипЗнч(Документ)=Тип("Структура") Тогда
		Возврат "";
	КонецЕсли;
	
	// КУФИБ - конец
	
	
	МассивТиповПодпискаКассы = Метаданные.ПодпискиНаСобытия.ПриУстановкеНовогоНомераДокументаПрефиксКассы.Источник.Типы();
	
	Если МассивТиповПодпискаКассы.Найти(Тип("ДокументОбъект." + Документ.Метаданные().Имя)) <> Неопределено Тогда 
		Если ЗначениеЗаполнено(Документ.Касса) Тогда 
			Возврат Документ.Касса.Префикс;
		Иначе 
			Возврат "";
		КонецЕсли;
	КонецЕсли;
	
	МассивТиповПодпискаСклады = Метаданные.ПодпискиНаСобытия.ПриУстановкеНовогоНомераДокументаПрефиксСклады.Источник.Типы();
	
	Если МассивТиповПодпискаСклады.Найти(Тип("ДокументОбъект." + Документ.Метаданные().Имя)) <> Неопределено Тогда 
		
		МетаданныеДокумента = Документ.Метаданные();
		
		Если ЕстьРеквизитДокумента("Склад", МетаданныеДокумента) Тогда 
			Если ЗначениеЗаполнено(Документ.Склад) Тогда 
				Возврат Документ.Склад.Префикс;
			Иначе 
				Возврат "";
			КонецЕсли;
		ИначеЕсли ЕстьРеквизитДокумента("СкладОтправитель", МетаданныеДокумента) Тогда 
			Если ЗначениеЗаполнено(Документ.СкладОтправитель) Тогда 
				Возврат Документ.СкладОтправитель.Префикс;
			Иначе 
				Возврат "";
			КонецЕсли;
		ИначеЕсли ЕстьРеквизитДокумента("СкладОрдер", МетаданныеДокумента) Тогда 
			Если ЗначениеЗаполнено(Документ.СкладОрдер) Тогда
				Если ТипЗнч(Документ.СкладОрдер) = Тип("СправочникСсылка.Склады") Тогда 
		 			Возврат Документ.СкладОрдер.Префикс;
				Иначе 
					Возврат Документ.СкладОрдер.Склад.Префикс;
				КонецЕсли;
			Иначе 
				Возврат "";
			КонецЕсли;
		КонецЕсли;			
	КонецЕсли;
	
	МассивТиповПодпискаСчета = Метаданные.ПодпискиНаСобытия.ПриУстановкеНовогоНомераДокументаПрефиксБанковскиеСчета.Источник.Типы();
	
	Если МассивТиповПодпискаСчета.Найти(Тип("ДокументОбъект." + Документ.Метаданные().Имя)) <> Неопределено Тогда 
		Если ЗначениеЗаполнено(Документ.СчетОрганизации) Тогда 
			Возврат Документ.СчетОрганизации.Префикс;
		Иначе 
			Возврат "";
		КонецЕсли;
	КонецЕсли;
	
	Возврат "";
	
	
КонецФункции
     
     
// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ, глСписокПрефиксовУзлов = Неопределено, ПредставлениеНомераДокумента = Неопределено) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Если НЕ ТипЗнч(Документ)=Тип("Структура") Тогда
		ОбъектИмя = Документ.Метаданные().Имя;
	КонецЕсли;
	
	Если  ТипЗнч(Документ)=Тип("Структура") ИЛИ Метаданные.Документы.Найти(ОбъектИмя) <> Неопределено Тогда
		Номер = СокрЛП(Документ.Номер);
		
		// Если номер документа по стандарту БСП 8.2, сформируем номер через стандартную процедуру БСП.
		Если ПолучитьФункциональнуюОпцию("ИспользоватьОбменДанными") = Истина Тогда
			
			Если Сред(Номер, 5, 1) = "-" Тогда
				Номер = ПрефиксацияОбъектовКлиентСервер.ПолучитьНомерНаПечать(Номер,
				Ложь, // УдалитьПрефиксИнформационнойБазы
				Истина // УдалитьПользовательскийПрефикс
				);
				Возврат Номер;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПредставлениеНомераДокумента = Неопределено Тогда
			ПредставлениеНомераДокумента = Константы.ПредставлениеНомераДокументов.Получить();
			// для печати счетов-фактур используется отдельная настройка

















			Попытка
				Если ТипЗнч(Документ) = Тип("ДокументСсылка.СчетФактураВыданный")
					ИЛИ ТипЗнч(Документ) = Тип("ДокументОбъект.СчетФактураВыданный") Тогда
					ПредставлениеНомераДокумента = Константы.ПредставлениеНомераСчетаФактуры.Получить();
				КонецЕсли;			
			Исключение			
			КонецПопытки;		
		КонецЕсли;	
		
		Если (ПредставлениеНомераДокумента <> Перечисления.ВидыПредставленийНомеровДокументов.ПустаяСсылка()) И (ПредставлениеНомераДокумента <> 
			 Перечисления.ВидыПредставленийНомеровДокументов.ПрефиксИНули) Тогда
			 
			Попытка
				ПрефиксОрганизации = СокрЛП(Документ.Организация.Префикс); 
			Исключение
				Попытка
					ПрефиксОрганизации = СокрЛП(Документ.ДокументОснование.Организация.Префикс); 
				Исключение
					ПрефиксОрганизации = "";
				КонецПопытки;
			КонецПопытки;
			СписокПрефиксовУзлов = ?(глСписокПрефиксовУзлов<>Неопределено, глСписокПрефиксовУзлов, Новый Структура);
			ДополнительныйПрефикс = ПолучитьДополнительныйПрефиксНомераДокумента(Документ);
			
			ПолныйПрефиксНайден = Ложь;
			
			//в номере может быть префикс любого узла
			Для Каждого ЭлементСпискаПрефиксовУзлов Из СписокПрефиксовУзлов Цикл
				ПрефиксУзла = СокрЛП(ЭлементСпискаПрефиксовУзлов.Значение);
				ПолныйПрефикс = ПрефиксУзла + ПрефиксОрганизации + ДополнительныйПрефикс;













				ПозицияПолногоПрефикса = Найти(Номер, ПолныйПрефикс);
				Если ПозицияПолногоПрефикса = 1 Тогда
					Номер = Прав(Номер, СтрДлина(Номер) - СтрДлина(ПолныйПрефикс));
					ПолныйПрефиксНайден = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;	
			
			//так же возможно в номере нет префикса узла
			Если Не ПолныйПрефиксНайден Тогда
				ПолныйПрефикс = ПрефиксОрганизации + ДополнительныйПрефикс;
				Если Не ПустаяСтрока(ПолныйПрефикс) Тогда 
					ПозицияПолногоПрефикса = Найти(Номер, ПолныйПрефикс);
					Если ПозицияПолногоПрефикса = 1 Тогда
						Номер = Прав(Номер, СтрДлина(Номер) - СтрДлина(ПолныйПрефикс));
						ПолныйПрефиксНайден = Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			//возможно в номере есть только префикс организации
			Если Не ПолныйПрефиксНайден Тогда
				ПолныйПрефикс = ПрефиксОрганизации;
				Если Не ПустаяСтрока(ПолныйПрефикс) Тогда 
					ПозицияПолногоПрефикса = Найти(Номер, ПолныйПрефикс);
					Если ПозицияПолногоПрефикса = 1 Тогда
						Номер = Прав(Номер, СтрДлина(Номер) - СтрДлина(ПолныйПрефикс));
						ПолныйПрефиксНайден = Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Пока Лев(Номер, 1) = "0" Цикл
				Номер = Прав(Номер, СтрДлина(Номер) - 1);
			КонецЦикла;
			
			Если ПредставлениеНомераДокумента = Перечисления.ВидыПредставленийНомеровДокументов.ПрефиксБезНулей Тогда
				Если ПолныйПрефиксНайден Тогда
					Номер = ПолныйПрефикс + Номер;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Метаданные.Справочники.Найти(ОбъектИмя) <> Неопределено Тогда
		
		Номер = Документ.Наименование;


		
	Иначе 
		
		Номер = 0;
		

	КонецЕсли;
	
	Возврат Номер;
	
КонецФункции // ПолучитьНомерНаПечать()


// Функция производит поиск документа заданного вида, имеющего значение реквизита "ДокументОснование", равное
// переданной ссылке.
//
// Параметры:
//  ДокументСсылка  - ссылка на документ, для которого надо найти подчиненный документ,
//  ВидСчетаФактуры - строка, вид документа, по умолчанию "СчетФактураВыданный"
//
// Возвращаемое значение:
//  Если нашли, то возвращаем ссылку, не нашли - Неопределено
//
Функция НайтиПодчиненныйДокумент(ДокументСсылка, ВидДокумента = "СчетФактураВыданный") Экспорт

	НайденныйДокумент = Неопределено;
	
	Если ЗначениеЗаполнено(ДокументСсылка) Тогда 
		Запрос = Новый Запрос;
		
		// Установим параметры запроса
		Запрос.УстановитьПараметр("ДокументСсылка", ДокументСсылка);
		
		Если ВидДокумента = "СчетФактураВыданный"  ИЛИ ВидДокумента = "СчетФактураПолученный" Тогда
			// исключаем из данных неактуальные (аннулированные и отозванные СФ)
			Запрос.Текст = 
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	ТЧ_Документов.Ссылка
			|ПОМЕСТИТЬ ВТ_ПодчиненныеДокументы
			|ИЗ
			|	Документ." + ВидДокумента + ".ДокументыОснования КАК ТЧ_Документов
			|ГДЕ
			|	ТЧ_Документов.ДокументОснование = &ДокументСсылка
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	ПодчиненныеДокументы.Ссылка
			|ИЗ
			|	ВТ_ПодчиненныеДокументы КАК ПодчиненныеДокументы
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СчетаФактурыПрекратившиеДействие.СрезПоследних(
			|				,
			|				СчетФактура В
			|					(ВЫБРАТЬ
			|						ВТ_ПодчиненныеДокументы.Ссылка
			|					ИЗ
			|						ВТ_ПодчиненныеДокументы КАК ВТ_ПодчиненныеДокументы)) КАК СчетаФактурыПрекратившиеДействие
			|		ПО ПодчиненныеДокументы.Ссылка = СчетаФактурыПрекратившиеДействие.СчетФактура
			|ГДЕ
			|	СчетаФактурыПрекратившиеДействие.СчетФактура ЕСТЬ NULL ";
		Иначе
			Запрос.Текст = 
			
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	Ссылка 
			|ИЗ
			|	Документ." + ВидДокумента + "
			|
			|ГДЕ
			|	ДокументОснование = &ДокументСсылка";
			
		КонецЕсли;
		
		ВыборкаИзЗапроса = Запрос.Выполнить().Выбрать();
		
		Если ВыборкаИзЗапроса.Следующий() Тогда
			НайденныйДокумент = ВыборкаИзЗапроса.Ссылка;
		КонецЕсли;
		
	КонецЕсли;

	Возврат НайденныйДокумент;

КонецФункции // НайтиПодчиненныйДокумент()

//Функция получает список документов, которые вводятся на основании заданного
//документа
//  Параметры: ДокументПоиска: Тип - Метаданные объекта
// 
Функция ПолучитьСписокВводимыхДокументовНаОсновании(ДокументПоиска) Экспорт 
	
	СписокДокументов = Новый СписокЗначений;
	Для Каждого Документ Из Метаданные.Документы Цикл
			Если Документ.ВводитсяНаОсновании.Содержит(ДокументПоиска) Тогда 
			СписокДокументов.Добавить(Документ.Имя, Документ.Синоним);	
		КонецЕсли;		
	КонецЦикла;
	Возврат СписокДокументов;
	
КонецФункции

// Функция возвращает Истина, если в базе существует хотя бы один проведенный документ,
// в котором содержится ссылка на переданный документ ДокументПоиска
//
Функция СуществуютПроведенныеДокументыВведенныеНаОсновании(ДокументПоиска) Экспорт

	ТекстЗапроса = "";
	ТипДокументаПоиска = ТипЗнч(ДокументПоиска);

	МетаданныеДокументы = Метаданные.Документы;
	Для Каждого Док Из МетаданныеДокументы Цикл
		
		Если НЕ ПравоДоступа("Чтение", Док) Тогда
			Продолжить;
		КонецЕсли;
	
		// просмотр всех реквизитов на возможность наличия ссылки на ДокументПоиска
		ТекстГде = "";
	
		РеквизитыДокумента = Док.Реквизиты;
		Для Каждого Реквизит Из РеквизитыДокумента Цикл
			Если Реквизит.Тип.СодержитТип(ТипДокументаПоиска) Тогда
				
				Если НЕ ПустаяСтрока(ТекстГде) Тогда
					ТекстГде = ТекстГде + " ИЛИ ";
				КонецЕсли;
				
				ТекстГде = ТекстГде + " Док." + Реквизит.Имя + " = &ДокументПоиска";
			
			КонецЕсли;
		КонецЦикла;
		
		Если Не ПустаяСтрока(ТекстГде) Тогда
			Если ПустаяСтрока(ТекстЗапроса) Тогда
				ТекстЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ";
			Иначе
				ТекстЗапроса = ТекстЗапроса + "
				|
				|ОБЪЕДИНИТЬ ВСЕ
				|
				|ВЫБРАТЬ
				|";
			КонецЕсли;
			
			ТекстЗапроса = ТекстЗапроса + "
			|	Док.Ссылка
			|ИЗ
			|	Документ." + Док.Имя + " КАК Док
			|ГДЕ
			|	Док.Проведен 
			|	И (" + ТекстГде + ")";
		КонецЕсли;
	
		// просмотр реквизитов табличных частей на наличие ссылки на ДокументПоиска
		ТабличныеЧастиДокумента = Док.ТабличныеЧасти;
		Для Каждого ТЧ Из ТабличныеЧастиДокумента Цикл
			ТекстГде = "";
			РеквизитыТЧ = ТЧ.Реквизиты;

			Для Каждого Реквизит Из РеквизитыТЧ Цикл
				Если Реквизит.Тип.СодержитТип(ТипДокументаПоиска) Тогда
					
					Если НЕ ПустаяСтрока(ТекстГде) Тогда
						ТекстГде = ТекстГде + " ИЛИ ";
					КонецЕсли;
					
					ТекстГде = ТекстГде + " Док." + Реквизит.Имя + " = &ДокументПоиска";
				
				КонецЕсли;
			КонецЦикла;
			
			Если Не ПустаяСтрока(ТекстГде) Тогда
				Если ПустаяСтрока(ТекстЗапроса) Тогда
					ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ 1 РАЗРЕШЕННЫЕ";
				Иначе
					ТекстЗапроса = ТекстЗапроса + "
					|
					|ОБЪЕДИНИТЬ ВСЕ
					|
					|ВЫБРАТЬ
					|";
				КонецЕсли;
				
				ТекстЗапроса = ТекстЗапроса + "
				|	Док.Ссылка
				|ИЗ
				|	Документ." + Док.Имя + "." + ТЧ.Имя + " КАК Док
				|ГДЕ
				|	Док.Ссылка.Проведен 
				|	И (" + ТекстГде + ")";
			КонецЕсли;

		КонецЦикла;
		
	КонецЦикла;
	
	Если ПустаяСтрока(ТекстЗапроса) Тогда
		Возврат Ложь; // на документ поиска вообще не существует в других документа
	Иначе
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ДокументПоиска", ДокументПоиска);
		Запрос.Текст = ТекстЗапроса + "
		|УПОРЯДОЧИТЬ ПО
		|	Ссылка";
		
		Выборка = Запрос.Выполнить().Выбрать();
		Возврат ?(Выборка.Количество() <> 0, Истина, Ложь);
	КонецЕсли;

КонецФункции // СуществуютПроведенныеДокументыВведенныеНаОсновании

// В качестве параметра КонтрагентОрганизация может выступать
// Ссылка на элемент справочника Контрагенты, ссылка на элемент справочника Организация либо Структура (подготовленная с помошью функции ОписаниеОрганизации)
//
Функция ПолучитьРегистрационныйНомерОрганизацииКонтрагентаВПечатнуюФорму(КонтрагентОрганизация, Дата, ВыводитьОписание = Истина, ПредставлениеРНН_БИН = "", КодЯзыка = "ru", ВыводитьРННиБИН = Ложь, ВыводитьБИНИИНВместе = Ложь) Экспорт
	
	РегистрационныйНомерСтрока = "";
	ЗначениеБИН = "";
	ЗначениеЮрФизЛицо = Перечисления.ЮрФизЛицо.ЮрЛицо;
	ПризнакВыводаРеквизитовНЕрезидентов = Ложь;
	ЗначениеНомераРегистрацииВСтранеРезидентства = "";
	ЗначениеСтраныТС = Справочники.СтраныУчастникиТаможенногоСоюза.ПустаяСсылка();
	
	Если ТипЗнч(КонтрагентОрганизация) = Тип("СправочникСсылка.Организации") Тогда
		ЗначениеБИН			= КонтрагентОрганизация.ИдентификационныйНомер;
		ЗначениеЮрФизЛицо 	= КонтрагентОрганизация.ЮрФизЛицо;
		ЗначениеНомераРегистрацииВСтранеРезидентства = СокрЛП(КонтрагентОрганизация.КодВСтранеРегистрации);
		ЗначениеСтраныТС	= КонтрагентОрганизация.СтранаРегистрации.УчастникТаможенногоСоюза;
	ИначеЕсли	ТипЗнч(КонтрагентОрганизация) = Тип("СправочникСсылка.Контрагенты")   Тогда
		ЗначениеБИН			= КонтрагентОрганизация.ИдентификационныйКодЛичности;
		ЗначениеЮрФизЛицо 	= КонтрагентОрганизация.ЮрФизЛицо;		
		ЗначениеНомераРегистрацииВСтранеРезидентства = СокрЛП(КонтрагентОрганизация.НомерНалоговойРегистрацииВСтранеРезидентства);
		ЗначениеСтраныТС							 = КонтрагентОрганизация.СтранаРезидентства.УчастникТаможенногоСоюза;
	ИначеЕсли	ТипЗнч(КонтрагентОрганизация) = Тип("Структура") И  КонтрагентОрганизация.Свойство("БИН_ИИН")  И  КонтрагентОрганизация.Свойство("ЮрФизЛицо") Тогда	
		ЗначениеБИН			= КонтрагентОрганизация.БИН_ИИН;
		ЗначениеЮрФизЛицо 	= КонтрагентОрганизация.ЮрФизЛицо;		
		Если КонтрагентОрганизация.Свойство("НомерРегистрацииВСтранеРезидентства") Тогда
			ЗначениеНомераРегистрацииВСтранеРезидентства = КонтрагентОрганизация.НомерРегистрацииВСтранеРезидентства;
		КонецЕсли;	
		Если КонтрагентОрганизация.Свойство("СтранаРезидентстваУчастникТаможенногоСоюза") Тогда
			ЗначениеСтраныТС = КонтрагентОрганизация.СтранаРезидентстваУчастникТаможенногоСоюза;
		КонецЕсли;	
	Иначе
		// не соответствующий тип в параметрах функции
		Возврат РегистрационныйНомерСтрока;
	КонецЕсли;	
	//
	
	// Проверка настроек системы по выводу РНН и БИН
	ДатаПрекращенияВыводаРНН 	= Константы.ДатаПрекращенияВыводаРННВПервичныхДокументах.Получить();
	ДатаНачалаВыводаБИН_ИИН 	= Константы.ДатаНачалаВыводаБИН_ИИНВПервичныхДокументах.Получить();
	
	ВыводитьРНН = НЕ ЗначениеЗаполнено(ДатаПрекращенияВыводаРНН) ИЛИ Дата<ДатаПрекращенияВыводаРНН;
	ВыводитьБИНвСФ = ЗначениеЗаполнено(ДатаНачалаВыводаБИН_ИИН) И Дата>=ДатаНачалаВыводаБИН_ИИН И ВыводитьРННиБИН;
	ВыводитьБИН = НЕ ВыводитьРНН;
	ВыводитьИНН_УНП = Ложь;
	
	ТекстРНН = "ru = ""РНН""; kz = ""СТН""";
	ТекстБИН = "ru = ""БИН""; kz = ""БСН""";
	ТекстИИН = "ru = ""ИИН""; kz = ""ЖСН""";
	ТекстИНН_УНП = "ru = ""ИИН""; kz = ""ЖСН""";
		
	Если Дата >= Дата(2010,7,1) Тогда // с 1 июля выводим данные о УНП, ИНН/КПП для РБ и РФ
		Если ЗначениеСтраныТС = Справочники.СтраныУчастникиТаможенногоСоюза.Беларусь Тогда
			ВыводитьИНН_УНП = Истина;
			ТекстИНН_УНП = "ru = ""УНП""; kz = ""УНП""";
		ИначеЕсли ЗначениеСтраныТС = Справочники.СтраныУчастникиТаможенногоСоюза.Россия Тогда
			ВыводитьИНН_УНП = Истина;
			ТекстИНН_УНП = "ru = ""ИНН/КПП""; kz = ""ИНН/КПП""";
		КонецЕсли;
		Если ВыводитьИНН_УНП = Истина Тогда
			// Для РФ и РБ выводим ЬИН только если они указаны для контрагента
			ВыводитьРНН = ВыводитьРНН И ЗначениеЗаполнено(КонтрагентОрганизация.РНН);
			ВыводитьБИН = ВыводитьБИН И ЗначениеЗаполнено(ЗначениеБИН);
			
			ПредставлениеИНН_УНП = НСТР(ТекстИНН_УНП, КодЯзыка);
		КонецЕсли;	
	КонецЕсли; 
	
	// Вывод стандартных РНН и БИН
	Если ВыводитьРНН Тогда
		РегистрационныйНомерСтрока = ?(ВыводитьОписание, НСТР(ТекстРНН, КодЯзыка) + ": ","") + КонтрагентОрганизация.РНН;
		ПредставлениеРНН_БИН = НСТР(ТекстРНН, КодЯзыка);
	КонецЕсли;	
	
	Если ВыводитьБИН ИЛИ (ВыводитьБИНвСФ И НЕ ВыводитьБИН) Тогда
		// Вывод разделительной запятой
		Если ЗначениеЗаполнено(РегистрационныйНомерСтрока) Тогда
			РегистрационныйНомерСтрока = РегистрационныйНомерСтрока + ", ";
			ПредставлениеРНН_БИН = ПредставлениеРНН_БИН + ", ";
		КонецЕсли;
				
		Если ВыводитьБИНИИНВместе Тогда
			НазваниеИдентификационногоНомера = НСТР(ТекстИИН, КодЯзыка) + " (" + НСТР(ТекстБИН, КодЯзыка) + ")";
		Иначе
			НазваниеИдентификационногоНомера = НСТР(ТекстБИН, КодЯзыка);
			Если ЗначениеЮрФизЛицо = Перечисления.ЮрФизЛицо.ФизЛицо Тогда
				НазваниеИдентификационногоНомера = НСТР(ТекстИИН, КодЯзыка);
			КонецЕсли;				
		КонецЕсли;
					
		Если ВыводитьОписание Тогда
			РегистрационныйНомерСтрока = РегистрационныйНомерСтрока +  НазваниеИдентификационногоНомера + ": ";
		КонецЕсли;
		
		ПредставлениеРНН_БИН = ПредставлениеРНН_БИН + НазваниеИдентификационногоНомера;		
		
		РегистрационныйНомерСтрока = РегистрационныйНомерСтрока + ЗначениеБИН;			
	КонецЕсли;		
		
	// с 1 июля выводим данные о УНП, ИНН/КПП для РБ и РФ
	Если ВыводитьИНН_УНП Тогда
		// Вывод разделительной запятой
		Если ЗначениеЗаполнено(РегистрационныйНомерСтрока) Тогда
			РегистрационныйНомерСтрока = РегистрационныйНомерСтрока + ", ";
			ПредставлениеРНН_БИН = ПредставлениеРНН_БИН + ", ";
		КонецЕсли;
		НазваниеИдентификационногоНомера = НСТР(ТекстИНН_УНП, КодЯзыка);
		
		Если ВыводитьОписание Тогда
			РегистрационныйНомерСтрока = РегистрационныйНомерСтрока +  НазваниеИдентификационногоНомера + ": ";
		КонецЕсли;
		
		ПредставлениеРНН_БИН = ПредставлениеРНН_БИН + НазваниеИдентификационногоНомера;		
		
		РегистрационныйНомерСтрока = РегистрационныйНомерСтрока + ЗначениеНомераРегистрацииВСтранеРезидентства;			
	КонецЕсли;	
		
	Возврат РегистрационныйНомерСтрока;
	
КонецФункции // ПолучитьРегистрационныйНомерОрганизацииКонтрагентаВПечатнуюФорму

// Функция возвращает признак ведения учета по сотрудникам на счете
// т.е. проверяет наличие субконто "Работники организации" на счете
// по умолчанию используется счет 3350 по бух.учету
//
Функция ПолучитьПризнакВеденияУчетаПоСотрудникам(Счет = Неопределено) Экспорт
	
	Если Счет = Неопределено Тогда
		Счет = ПланыСчетов.Типовой.КраткосрочнаяЗадолженностьПоОплатеТруда; //3350
	КонецЕсли;
		
	Субконто = Счет.ВидыСубконто.Найти(ПланыВидовХарактеристик.ВидыСубконтоТиповые.РаботникиОрганизаций);
	Если Субконто = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
		
КонецФункции // ПолучитьПризнакВеденияУчетаПоСотрудникам()


Процедура ЗаполнитьДанныеДоверенностиВПечатнойФорме(ДанныеДоверенности,ОбластьПечати, ПараметрДоверенность = "Доверенность", ПараметрДоверенностьЛицо = "ДоверенностьЛицо",
																					  ПараметрДоверенностьВыдана = "ДоверенностьВыдана", ВыводитьВыданаВОдномПараметре = Ложь, ВыводитьДанныеДоверенностиВОдномПараметре = Ложь,
																					  КодЯзыка = "ru") Экспорт
	
	Если НЕ (ДанныеДоверенности.Свойство("ДоверенностьНомер") ИЛИ  ДанныеДоверенности.Свойство("ДоверенностьДата")
		ИЛИ  ДанныеДоверенности.Свойство("ДоверенностьЛицо") ИЛИ  ДанныеДоверенности.Свойство("ДоверенностьВыдана")) Тогда
		Возврат;
	КонецЕсли;
	
	Если НРег(КодЯзыка) = "ru" Тогда
		ТекстВыданной = НСтр("ru = 'выданной'");		
	Иначе
		ТекстВыданной = НСтр("ru = 'берілген'");
	КонецЕсли;
		
	ТекстДоверенности = ПолучитьТекстДоверенности(ДанныеДоверенности,КодЯзыка);
	
	Если ВыводитьДанныеДоверенностиВОдномПараметре Тогда 				
		ТекстВыданна = ПолучитьТекстДоверенностиВыданной(ДанныеДоверенности, ТекстВыданной); 					
		ОбластьПечати.Параметры.Доверенность = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='%1%2'"),ТекстДоверенности, 
		?(ЗначениеЗаполнено(ТекстДоверенности) И ЗначениеЗаполнено(ТекстВыданна), ", " + ТекстВыданна, ТекстВыданна));		
	Иначе		
		Если ЗначениеЗаполнено(ТекстДоверенности)  Тогда
			ОбластьПечати.Параметры[ПараметрДоверенность] = ТекстДоверенности;
			
			ОбластьДоверенности = ОбластьПечати.Области.Найти("Доверенность") ;
			Если ОбластьДоверенности <> Неопределено Тогда
				ОбластьПечати.Области.Найти("Доверенность").ГраницаСнизу = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная) ;			
			КонецЕсли;  		
		Иначе    	
			Если НРег(КодЯзыка) = "ru" Тогда
				ОбластьПечати.Параметры[ПараметрДоверенность] =  НСтр("ru = '№_____________ от ""____""_____________________ 20___ года'");
			Иначе
				ОбластьПечати.Параметры[ПараметрДоверенность] =  НСтр("ru = '20___  жылғы ""____""__________________________ №_________'");
			КонецЕсли;	
		КонецЕсли;
	КонецЕсли;  
	
	//Если данные о выдаче доверенности выводится в одном параметре, то используется параметр "ПараметрДоверенностьВыдана"
	Если ВыводитьВыданаВОдномПараметре Тогда 		
		ОбластьПечати.Параметры[ПараметрДоверенностьВыдана]    = ПолучитьТекстДоверенностиВыданной(ДанныеДоверенности, "");		
	ИначеЕсли НЕ ВыводитьДанныеДоверенностиВОдномПараметре Тогда		
		ОбластьПечати.Параметры[ПараметрДоверенностьЛицо]    = СокрЛП(ДанныеДоверенности.ДоверенностьЛицо);
		ОбластьПечати.Параметры[ПараметрДоверенностьВыдана]  = СокрЛП(ДанныеДоверенности.ДоверенностьВыдана);		
	КонецЕсли;  	
	
КонецПроцедуры


Функция ПолучитьТекстДоверенности(ДанныеДоверенности,КодЯзыка = "ru") Экспорт
	
	ТекстДоверенности = "";
	
	Если ЗначениеЗаполнено(ДанныеДоверенности.ДоверенностьНомер) ИЛИ ЗначениеЗаполнено(ДанныеДоверенности.ДоверенностьДата) Тогда			
		ТекстДоверенности = НСтр("ru = '№%1 от %2 года'; kz = '%2 жылғы №%1'", КодЯзыка);
		
		ТекстДоверенности = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстДоверенности, СокрЛП(ДанныеДоверенности.ДоверенностьНомер), 
					Формат(ДанныеДоверенности.ДоверенностьДата, "ДФ=dd.MM.yyyy"));
	Иначе
		ТекстДоверенности = СокрЛП(ДанныеДоверенности.УдалитьДоверенность);			
	КонецЕсли; 
	
	Возврат ТекстДоверенности;
	
КонецФункции

Функция ПолучитьТекстДоверенностиВыданной(ДанныеДоверенности,ТекстВыданной = "выданной") Экспорт
	
	Если НЕ (ДанныеДоверенности.Свойство("ДоверенностьЛицо") И ДанныеДоверенности.Свойство("ДоверенностьВыдана")) Тогда
		Возврат "";
	КонецЕсли;
	
	ТекстВыданна = "";
	Если ЗначениеЗаполнено(ДанныеДоверенности.ДоверенностьВыдана) ИЛИ ЗначениеЗаполнено(ДанныеДоверенности.ДоверенностьЛицо) Тогда
		ТекстВыданна = ТекстВыданна +  НСтр("ru='%1 %2%3'");
		ПараметрВыдана = "";
		ПараметрЛицо   = "";
		Если ЗначениеЗаполнено(ДанныеДоверенности.ДоверенностьВыдана) Тогда
			ПараметрВыдана = СокрЛП(ДанныеДоверенности.ДоверенностьВыдана);
		КонецЕсли;
		Если ЗначениеЗаполнено(ДанныеДоверенности.ДоверенностьЛицо)Тогда
			Если ЗначениеЗаполнено(ПараметрВыдана) Тогда
				ПараметрЛицо = ", " + СокрЛП(ДанныеДоверенности.ДоверенностьЛицо);
			Иначе
				ПараметрЛицо = СокрЛП(ДанныеДоверенности.ДоверенностьЛицо);
			КонецЕсли;
		КонецЕсли;
		
		ТекстВыданна = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстВыданна, ТекстВыданной,ПараметрВыдана, ПараметрЛицо)
	КонецЕсли;      
	
	Возврат ТекстВыданна;	
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// Сравнивает два массива однотипных значений (кроме коллекций значений)
//
// Параметры: 
//  ПервыйМассив,ВторойМассив - сравниваемые массивы
//
// Возвращаемое значение:
//  булево.
//
Функция МассивыИдентичны(ПервыйМассив,ВторойМассив) Экспорт

    ЭлементовМассива = ПервыйМассив.Количество();
	МассивыСовпадают = (ЭлементовМассива = ВторойМассив.Количество()); 
	  
	Если МассивыСовпадают Тогда
		Для Сч = 1 По ЭлементовМассива Цикл
			Если ПервыйМассив[Сч-1] <> ВторойМассив[Сч-1] Тогда
				Возврат Ложь
			КонецЕсли;
		КонецЦикла; 		
	КонецЕсли;

	Возврат МассивыСовпадают

КонецФункции // МассивыИдентичны()

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//  ИсхСумма   - распределяемая сумма
//  МассивКоэф - массив коэффициентов распределения
//  Точность   - точность округления при распределении. Необязателен.
//
//Возвращает:
//  МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//               суммы в соответствии с весом коэффициента (из массива коэффициентов)
//               В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//               или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина) Экспорт

	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл

		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);

		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач   = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;

		СуммаКоэф = СуммаКоэф + МассивКоэф[К];

	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма    = РаспрСумма + МассивСумм[К];
	КонецЦикла;

	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;

	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()

// Удалает повторяющиеся элементы массива.
//
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМасссиве = Новый Соответствие; 
		БылоНеопределено = Ложь;
		
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента = ТипЗнч(ЭлементМассива); 
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМасссиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМасссиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции // УдалитьПовторяющиесяЭлементыМассива()

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С СТРУКТУРАМИ

// Функция выгружает структуру в строку
//
Функция ВыгрузитьСтруктуруВСтроку(Структура,ПоЗначениям = Ложь,СтруктураПроверки = Неопределено) Экспорт

	НеПроверять = (СтруктураПроверки = Неопределено);
	НоваяСтрока = "";

	Для каждого Колонка из Структура Цикл

		Если НеПроверять тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение)или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)+",";

		ИначеЕсли СтруктураПроверки.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение) или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)) тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+",";

		Иначе
			//Нет в проверке!
			Возврат Ложь;

		КонецЕсли;

	КонецЦикла;

	Если ЗначениеЗаполнено(НоваяСтрока) Тогда
		НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);
	КонецЕсли;

	Возврат НоваяСтрока;

КонецФункции // ВыгрузитьСтруктуруВСтроку()

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт

	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;

	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";

	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';

	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;

	Иначе
		Возврат Новый (ЗаданныйТип);

	КонецЕсли;

КонецФункции // ПустоеЗначениеТипа()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

//Процедура предназначена для обработки вызова "Предупреждение"
//
Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
	 
	#Если Клиент Тогда
		
		Предупреждение(ТекстСообщения);
	
	#Иначе
		
		ВызватьИсключение(ТекстСообщения);
		
	#КонецЕсли
	 
КонецПроцедуры // ПредупреждениеОбОшибке()

//Процедура предназначена для запуска приложения по указанному каталогу и программы
// вызова.
//
Процедура ЗапуститьПрограмму(ПутьКПрограмме, РабочийКаталог = Неопределено) Экспорт
	
	#Если Клиент Тогда
		
		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
	
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьПрограмму()

// Вернуть имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
Функция ИмяCOMСоединителя() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	ПодстрокиВерсии = РазложитьСтрокуВМассивПодстрок(СистемнаяИнформация.ВерсияПриложения, ".");
	
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";	
КонецФункции	

// Вернуть версию платформы 1С:Предприятиемдля настроек обмена и прочих процедур работы с ИБ.
Функция ВерсияПлатформыИнформационнойБазы() Экспорт

	СистемнаяИнформация = Новый СистемнаяИнформация;

	Если Лев(СистемнаяИнформация.ВерсияПриложения,3) = "8.0" тогда
		ВерсияПлатформыИнформационнойБазыДляПодключения = "V8";   	
	ИначеЕсли Лев(СистемнаяИнформация.ВерсияПриложения,3) = "8.1" тогда
		ВерсияПлатформыИнформационнойБазыДляПодключения = "V81";   
	ИначеЕсли Лев(СистемнаяИнформация.ВерсияПриложения,3) = "8.2" тогда	
		ВерсияПлатформыИнформационнойБазыДляПодключения = "V82";   
	ИначеЕсли Лев(СистемнаяИнформация.ВерсияПриложения,3) = "8.3" тогда	
		ВерсияПлатформыИнформационнойБазыДляПодключения = "V83";   
	КонецЕсли;	
	
	Возврат ВерсияПлатформыИнформационнойБазыДляПодключения
КонецФункции

Функция АдресРесурсовДляПроверкиНаличияОбновления() Экспорт
	лкАдресРесурсовОбозревателя = "";
	
	Если Найти(ВРег(Метаданные.Имя), "БАЗОВАЯ") > 0 Тогда
		лкАдресРесурсовОбозревателя = "AccountingKzBase";
	Иначе
		лкАдресРесурсовОбозревателя = "AccountingKz";
	КонецЕсли;
	
	//// Определение версии платформы
	СисИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии  = РазложитьСтрокуВМассивПодстрок(СисИнфо.ВерсияПриложения, ".");
	Если Число(ПодстрокиВерсии[0]) >= 8 И Число(ПодстрокиВерсии[1]) >= 2 Тогда
		лкАдресРесурсовОбозревателя  = "/" + лкАдресРесурсовОбозревателя + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + "/";
	КонецЕсли; 
	
	Возврат лкАдресРесурсовОбозревателя;	

КонецФункции	

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()

Процедура СообщитьИнформациюПользователю(СтрокаСообщенияПользователю, Знач Статус = Неопределено) Экспорт
	
	#Если Клиент Тогда
	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Обычное;
	КонецЕсли;
	Сообщить(СтрокаСообщенияПользователю, Статус);
	#КонецЕсли
	
КонецПроцедуры

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
//  В случае работы на клиенте или на сервере выводит в окно сообщений,
//  в случае внешнего соединения вызывает исключение.
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный)
Процедура СообщитьОбОшибке(ТекстСообщения, Отказ = Ложь, Заголовок = "",Статус = Неопределено) Экспорт

	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");

	Если ОкончаниеСлужебногоСообщения > 0 И Лев(ТекстСообщения, 1) = "{" Тогда
		ТекстСообщения = СокрЛП(Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2)));
	КонецЕсли;

	Отказ = Истина;

	#Если ВнешнееСоединение Тогда

		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;

		ВызватьИсключение (ТекстСообщения);

	#Иначе

		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;

		Если Статус = Неопределено тогда
			Статус = СтатусСообщения.Важное;
		КонецЕсли;
		Сообщить(ТекстСообщения, Статус);

	#КонецЕсли

КонецПроцедуры // СообщитьОбОшибке()

// Формирует сообщение при ошибках проведения документов.
//
// Параметры: 
//  ТекстСообщения - Исходный текст, выводимого сообщения,
//  Отказ          - Флаг отказа в проведении докумета,
//  Заголовок      - Заголовок начала серии сообщений об ошибках проведения (не обязательный)
//
Процедура ОшибкаПриПроведении(ТекстСообщения, Отказ, Заголовок="") Экспорт

	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок);

КонецПроцедуры // ОшибкаПриПроведении()

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Документ - ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция ПредставлениеДокументаПриПроведении(Документ) Экспорт

	МетаданныеДокумента = Документ.Метаданные();

	ВидОперацииСтр = "";

	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента) Тогда
		ВидОперацииСтр = " (" + Строка(Документ.ВидОперации) + ")";
	КонецЕсли;

	Возврат "Проведение документа: " + СокрЛП(Документ) + ВидОперацииСтр;

КонецФункции // ПредставлениеДокументаПриПроведении()

// Проверяет принадлежность документа к видам учета
//
// Параметры: 
//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
//  Отказ                   - флаг отказа в проведении.
//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
	
	Перем Упр, Бух, Нал;
	
	ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтраженоВОперУчете", Упр);
	ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
	Если Не ЕстьБух Тогда
		Бух = Истина;
	КонецЕсли;
	ЕстьНал = СтруктураШапкиДокумента.Свойство("УчитыватьКПН", Нал);
	
	Если ЕстьУпр ИЛИ ЕстьБух ИЛИ ЕстьНал Тогда
		Если НЕ МожетБытьТолькоНалоговый Тогда
			Если Упр <> Истина И Бух <> Истина  Тогда
				ОшибкаПриПроведении("Документ должен принадлежать хотя бы одному из видов учета: ""Оперативный"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);
			ИначеЕсли Бух <> Истина И Нал = Истина Тогда
				ОшибкаПриПроведении("Документ не может проводиться  по налоговому учету, если он не проводится по бухгалтерскому учету." , Отказ, Заголовок);
			КонецЕсли;
		Иначе
			Если Упр <> Истина И Бух <> Истина И Нал <> Истина Тогда
				ОшибкаПриПроведении("Документ должен принадлежать хотя бы одному из видов учета: ""Оперативный"", ""Бухгалтерский"", ""Налоговый"".", Отказ, Заголовок);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

// Проверяет правильность заполнения шапки документа.
// Если какой-то из реквизтов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеШапкиДокумента(ДокументОбъект, СтруктураОбязательныхПолей, Отказ, Заголовок) Экспорт

	ТипыПланыСчетов     = ПланыСчетов.ТипВсеСсылки();
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;

	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = ДокументОбъект[КлючЗначение.Ключ];
		ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();

		Если НЕ ЗначениеЗаполнено(Значение) Тогда // надо ругаться

			Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда //стандартное ругательство
				СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;

			ОшибкаПриПроведении(СтрокаСообщения, Отказ, Заголовок);

		ИначеЕсли ТипыПланыСчетов.СодержитТип(ТипЗнч(Значение)) тогда
			Если Значение.ЗапретитьИспользоватьВПроводках Тогда
				
				СтрокаСообщения = "Реквизит """ + СокрЛП(ПредставлениеРеквизита) + """ : счет " + СокрЛП(Значение)+" """ + Значение.Наименование + """ нельзя использовать в проводках.";
				ОшибкаПриПроведении(СтрокаСообщения, Отказ, Заголовок);

			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	Если СтруктураОбязательныхПолей.Свойство("Организация") и СтруктураОбязательныхПолей.Свойство("ДоговорКонтрагента") тогда

		// Если в документе есть организация и договор - провести проверку на соответствие
		//Организация в документе должна совпадать с организацией, указанной в договоре взаиморасчетов.
		//Организация = ДокументОбъект.Организация;
		//ДоговорКонтрагента = ДокументОбъект.ДоговорКонтрагента;
		//Если ТипЗнч(ДоговорКонтрагента) = Тип("СправочникСсылка.ДоговорыКонтрагентов") тогда
		//	ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов(Организация, ДоговорКонтрагента, ДоговорКонтрагента.Организация, Отказ, Заголовок);
		//КонецЕсли;

	КонецЕсли;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

// Проверяет правильность заполнения строк табличной части документа.
// Если какой-то из реквизтов, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
//
// Параметры:
//  ДокументОбъект             - объект проводимого документа, 
//  ИмяТабличнойЧасти          - табличная часть документа,
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураОбязательныхПолей, 
                                            Отказ, Заголовок, ВыводитьНомераСтрокВСообщении = Истина) Экспорт

	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();

	ТабличнаяЧасть      = ДокументОбъект[ИмяТабличнойЧасти];
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
		
	СтрокаНачалаСообщенияОбОшибке = "";
	
	// Цикл по строкам табличной части.
	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл    
		СтрокаНачалаСообщенияОбОшибке = "В строке номер """+ СокрЛП(СтрокаТаблицы.НомерСтроки) +
											""" табличной части """ + ПредставлениеТабличнойЧасти + """: ";
		// Цикл по проверяемым полям
		Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

			Значение = СтрокаТаблицы[КлючЗначение.Ключ];
			Если НЕ ЗначениеЗаполнено(Значение) Тогда // надо ругаться

				Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда //стандартное ругательство
					ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
					СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";

				Иначе
					СтрокаСообщения = КлючЗначение.Значение;

				КонецЕсли;

				ОшибкаПриПроведении(?(ВыводитьНомераСтрокВСообщении, СтрокаНачалаСообщенияОбОшибке, "")
										+ СтрокаСообщения, Отказ, Заголовок);

			КонецЕсли;

		КонецЦикла;		

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеТабличнойЧасти()

// Проверяет, что организация в документе совпадает с организацией, указанной в договоре взаиморасчетов.
//  при несовпадении устанавливается флаг отказа в проведении.
//
// Параметры:
//  Организация			- ссылка на организацию, выбранную в документе,
//  ДоговорКонтрагента	- ссылка на договор, выбранный в документе,
//  ДоговорОрганизация	- ссылка на Организацию, выбранную в договоре,
//  Отказ				- флаг отказа в проведении.
//  Заголовок			- строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов(Организация, ДоговорКонтрагента, 
																 ДоговорОрганизация, Отказ, Заголовок) Экспорт

	// Если не заполнен договор или организация, то не ругаемся
	Если ЗначениеЗаполнено(Организация) 
	   И ЗначениеЗаполнено(ДоговорКонтрагента)
	   И Организация <> ДоговорОрганизация Тогда

		//СообщитьОбОшибке("Выбран договор контрагента, не соответстветствующий организации, указанной в документе!", Отказ, Заголовок);

	КонецЕсли;

КонецПроцедуры // ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТАБЛИЦАМИ

// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
//
// Параметры
//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
//
//  Реквизиты – структура – Структура реквизитов. 
//							Ключ 		- Наименование колонки в источнике
//							Значение    - Наименование колонки в получаемой ТЗ
//							Если значение опущено - приравнивается ключу.
//	ПолучитьНомерСтрокиДокумента - булево
//	                        Используется только при выгрузке из табличной части документа.
//							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
//								и заполняет её реальными номерами строк
//
//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
// Возвращаемое значение:
//  Таблица значений или Неопределено (если не хватает реквизитов)
//
Функция СформироватьТаблицуЗначений(Источник, Реквизиты = Неопределено, ПолучитьНомерСтрокиДокумента = Ложь,
									ФормироватьОтстутствующиеКолонки = Ложь,КоллекцияКолонокДереваЗначений = Неопределено) Экспорт

	ЭтоТаблицаЗначений      = (ТипЗнч(Источник) = Тип("ТаблицаЗначений"));
	ЭтоСтрокиДереваЗначений = (ТипЗнч(Источник) = Тип("КоллекцияСтрокДереваЗначений"));

	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
		Возврат Неопределено;
	КонецЕсли;

	Если НЕ ЗначениеЗаполнено(Реквизиты) тогда

		Если ЭтоТаблицаЗначений тогда

			НоваяТЗ = Источник.Скопировать();

			Возврат НоваяТЗ;

		ИначеЕсли ЭтоСтрокиДереваЗначений тогда

			Реквизиты = Новый Структура();

			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
				Реквизиты.Вставить(Колонка.Имя);
			КонецЦикла;

		Иначе

			НоваяТЗ = Источник.Выгрузить();
			Возврат НоваяТЗ;

		КонецЕсли;

	КонецЕсли;

	Если НЕ ЭтоТаблицаЗначений И НЕ ЭтоСтрокиДереваЗначений тогда
		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
	КонецЕсли;

	НоваяТЗ = Новый ТаблицаЗначений();

	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",ПолучитьОписаниеТиповЧисла(5,0));
	КонецЕсли;

	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл

		Строка = НоваяТЗ.Добавить();

		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
		КонецЕсли;

	КонецЦикла;

	Для каждого ТекРеквизит из Реквизиты Цикл

		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит   = ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);

		Если ЭтоТаблицаЗначений тогда
			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);

		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);

		Иначе
			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);

		КонецЕсли;

		Если ИсточникКолонка= неопределено тогда

			//недостаточно реквизитов
			Если ФормироватьОтстутствующиеКолонки тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			Иначе
				Возврат Неопределено;
			КонецЕсли;

		Иначе
			НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);

		КонецЕсли;

	КонецЦикла;

	Возврат НоваяТЗ;

КонецФункции // СформироватьТаблицуЗначений()

Процедура ДополнитьКолонкиТаблицыЗначений(ТаблицаБазовая, ТаблицаДополнений) Экспорт

	Для каждого Колонка из ТаблицаДополнений.Колонки Цикл

		Если Не(ТаблицаБазовая.Колонки.Найти(Колонка.Имя) = Неопределено) тогда
			//Колонка уже есть
			Продолжить;
		КонецЕсли;

		ТаблицаБазовая.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);

	КонецЦикла;

КонецПроцедуры // ДополнитьКолонкиТаблицыЗначений()

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Сравнивает содержимое двух таблиц значений по списку полей либо по всем полям
//
// Параметры:
// 	ТаблицаЗначений1, ТаблицаЗначений2 - сравниваемые таблицы значений
// 	РежимВключенияПолей: 
//              Истина       - сравниваются только поля из СписокПолей
//              Ложь         - сравниваются поля кроме СписокПолей
//              Неопределено.- сравниваются все поля
//
// Возвращаемое значение
//	Истина, если в таблицы по переданному списку полей (по всем полям) идентичны, иначе - Ложь
//
Функция СравнитьТаблицыНаборовЗаписей(ТаблицаЗначений1, ТаблицаЗначений2) Экспорт

	Если ТипЗнч(ТаблицаЗначений1) <> Тип("ТаблицаЗначений") ИЛИ ТипЗнч(ТаблицаЗначений2) <> Тип("ТаблицаЗначений") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если ТаблицаЗначений1.Количество() <> ТаблицаЗначений2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли; 

	Если ТаблицаЗначений1.Колонки.Количество() <> ТаблицаЗначений2.Колонки.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверим поля
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если ТаблицаЗначений2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если ТаблицаЗначений1.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	
	// сформируем строку индекса для оптимизации поиска по таблице значений
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса+","+Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	// добавим индекс
	ТаблицаЗначений2.Индексы.Добавить(СтрокаИндекса);
	
	// Проверим записи
	Для каждого СтрокаТаблицы Из ТаблицаЗначений1 Цикл
		СтруктураПоиска = Новый Структура;
		Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
			СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
		КонецЦикла;
		СтрокиТаблицы2 = ТаблицаЗначений2.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы2.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	// сформируем строку индекса для оптимизации поиска по таблице значений
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса+","+Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	// добавим индекс
	ТаблицаЗначений1.Индексы.Добавить(СтрокаИндекса);
	
	Для каждого СтрокаТаблицы Из ТаблицаЗначений2 Цикл
		СтруктураПоиска = Новый Структура;
		Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
			СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
		КонецЦикла;
		СтрокиТаблицы1 = ТаблицаЗначений1.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы1.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // СравнитьТаблицыЗначений()

// Процедура устанавливает в переданной таблице значения булевских полей - флагов
// в соответствии с указанным действием.
//
// Параметры:
//	Таблица - таблица значений или табличная часть для обработки
//	ИмяПоляФлага - имя поля типа булево, которое содержит значения флагов
//	ВыполняемоеДействие - строка "Установить", "Снять", "Инвертировать"
//
Процедура ОбработатьЗначенияФлаговВТаблице(Таблица, ИмяПоляФлага, Знач ВыполняемоеДействие, ДокументИсправление = Ложь) Экспорт

	ВыполняемоеДействие = ВРег(ВыполняемоеДействие);	

	Для Каждого СтрокаТаблицы Из Таблица Цикл
	
		Если ВыполняемоеДействие = "УСТАНОВИТЬ" Тогда
			СтрокаТаблицы[ИмяПоляФлага] = ?(ДокументИсправление, НЕ СтрокаТаблицы.Сторно, Истина);
		ИначеЕсли ВыполняемоеДействие = "СНЯТЬ" Тогда
			СтрокаТаблицы[ИмяПоляФлага] = Ложь;
		Иначе                            
			Если ДокументИсправление Тогда
				Если СтрокаТаблицы.Сторно Тогда
					Флаг = Ложь;
				Иначе
					Флаг = НЕ СтрокаТаблицы[ИмяПоляФлага];
				КонецЕсли
			Иначе
				Флаг = НЕ СтрокаТаблицы[ИмяПоляФлага]
			КонецЕсли;
			СтрокаТаблицы[ИмяПоляФлага] = Флаг;
		КонецЕсли;
	
	КонецЦикла;

КонецПроцедуры // ОбработатьЗначенияФлаговВТаблице()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПОЛНЕНИЯ РЕКВИЗИТОВ
 
// Процедура устанавливает номер документа.
//
// Параметры:
//  ДокументОбъект  - ДокументОбъект. Экземпляр документа, которому 
//                    необходимо присвоить новый номер
//
Процедура УстановитьНомерДокумента(ДокументОбъект) Экспорт

	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	 Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда

		ДокументОбъект.УстановитьНовыйНомер("00");

	Иначе

		ДокументОбъект.УстановитьНовыйНомер(ДокументОбъект.Организация.Префикс);

	КонецЕсли;

КонецПроцедуры // УстановитьНомерДокумента()
                     
Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
	
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда 
		Реквизит = "Организация";
	ИначеЕсли ЕстьРеквизитДокумента("ОрганизацияОтправитель", МетаданныеДокумента) Тогда 
		Реквизит = "ОрганизацияОтправитель";
	Иначе 
		Если Не ЗначениеЗаполнено(Префикс) Тогда
			 Префикс = "0";
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ДокументОбъект[Реквизит].Префикс)  Тогда
		Если Не ЗначениеЗаполнено(Префикс) Тогда
			 Префикс = "0";
		КонецЕсли;
	Иначе
                                
		Префикс = ДокументОбъект[Реквизит].Префикс + Префикс;
        		
	КонецЕсли;
	
Конецпроцедуры

Процедура ДобавитьПрефиксСклада(ДокументОбъект, Префикс)
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если ЕстьРеквизитДокумента("Склад", МетаданныеДокумента)
		 И ЗначениеЗаполнено(ДокументОбъект.Склад.Префикс)  Тогда
			Префикс = ДокументОбъект.Склад.Префикс + Префикс;
			
	ИначеЕсли ЕстьРеквизитДокумента("СкладОтправитель", МетаданныеДокумента)
		 И ЗначениеЗаполнено(ДокументОбъект.СкладОтправитель.Префикс) Тогда 
		 	Префикс = ДокументОбъект.СкладОтправитель.Префикс + Префикс;
			
	ИначеЕсли ЕстьРеквизитДокумента("СкладОрдер", МетаданныеДокумента)
		 И ЗначениеЗаполнено(ДокументОбъект.СкладОрдер) Тогда
		 
		 	Если ТипЗнч(ДокументОбъект.СкладОрдер) = Тип("СправочникСсылка.Склады") Тогда 
		 		Префикс = ДокументОбъект.СкладОрдер.Префикс + Префикс;
			Иначе 
				Префикс = ДокументОбъект.СкладОрдер.Склад.Префикс + Префикс;
			КонецЕсли;				
			
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Префикс) Тогда
	 	Префикс = "0";
	КонецЕсли; 	
	
КонецПроцедуры

Процедура ДобавитьПрефиксКассы(ДокументОбъект, Префикс)
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если Не ЕстьРеквизитДокумента("Касса", МетаданныеДокумента)
		 Или Не ЗначениеЗаполнено(ДокументОбъект.Касса.Префикс)  Тогда
		 	Если Не ЗначениеЗаполнено(Префикс) Тогда
		 		Префикс = "0";
			КонецЕсли;
	Иначе 		 
		 
		 Префикс = ДокументОбъект.Касса.Префикс + Префикс;
        		
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьПрефиксБанковскогоСчета(ДокументОбъект, Префикс) Экспорт
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если Не ЕстьРеквизитДокумента("СчетОрганизации", МетаданныеДокумента)
		 Или Не ЗначениеЗаполнено(ДокументОбъект.СчетОрганизации.Префикс)  Тогда
		 	Если Не ЗначениеЗаполнено(Префикс) Тогда
		 		Префикс = "0";
		 	КонецЕсли;
	Иначе 
		                                
		Префикс = ДокументОбъект.СчетОрганизации.Префикс + Префикс;
        		
	КонецЕсли;	
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СПРАВОЧНИКАМИ

// Функция возвращает массив вышестоящих групп указанного элемента.
// 
// Переметры:
//  Элемент      - Элемент справочника, для которого ищется родитель
//
// Возвращаемое значение
//  Массив вышестояших групп
//
Функция ПолучитьСписокВышеСтоящихГрупп(ЭлементСправочника) Экспорт
	
	Результат = Новый Массив;		
	
	МетаданныеЭлемента = ЭлементСправочника.Метаданные();
	
	ИмяОбъектаМетаданных = МетаданныеЭлемента.Имя;
	
	ТипОбъектаМетаданных = "";
	Если Метаданные.Справочники.Содержит(МетаданныеЭлемента) Тогда
		ТипОбъектаМетаданных = "Справочник";
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаданныеЭлемента) Тогда
		ТипОбъектаМетаданных = "ПланСчетов";
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеЭлемента) Тогда
		ТипОбъектаМетаданных = "ПланВидовХарактеристик";
	КонецЕсли;
		
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Справочник1.Родитель КАК Родитель1,
	|	Справочник2.Родитель КАК Родитель2,
	|	Справочник3.Родитель КАК Родитель3,
	|	Справочник4.Родитель КАК Родитель4,
	|	Справочник5.Родитель КАК Родитель5
	|ИЗ
	|	" + ТипОбъектаМетаданных + "." + ИмяОбъектаМетаданных + " КАК Справочник1
	|		ЛЕВОЕ СОЕДИНЕНИЕ " + ТипОбъектаМетаданных + "." + ИмяОбъектаМетаданных + " КАК Справочник2
	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ " + ТипОбъектаМетаданных + "." + ИмяОбъектаМетаданных + " КАК Справочник3
	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ " + ТипОбъектаМетаданных + "." + ИмяОбъектаМетаданных + " КАК Справочник4
	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ " + ТипОбъектаМетаданных + "." + ИмяОбъектаМетаданных + " КАК Справочник5
	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
	|ГДЕ
	|	Справочник1.Ссылка = &Ссылка";
	
	ТекущийЭлемент = ЭлементСправочника;
	
	Пока ЗначениеЗаполнено(ТекущийЭлемент) Цикл		
		Запрос.УстановитьПараметр("Ссылка", ТекущийЭлемент);
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			Для Индекс = 1 по 5 Цикл
				ТекущийЭлемент = Выборка["Родитель" + Индекс];
				Если ЗначениеЗаполнено(ТекущийЭлемент) Тогда
					Результат.Добавить(ТекущийЭлемент);
				Иначе
					Прервать;
				КонецЕсли;				
			КонецЦикла;
		Иначе
			ТекущийЭлемент = Неопределено;
		КонецЕсли;
	КонецЦикла;	
	
	Возврат Результат;
	
КонецФункции // ПолучитьСписокВышеСтоящихГрупп()

// Проверяет наличие табличной части у справочника
//
//Параметры
//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
//
//Возвращаемое значение:
//  Булево   - Истина, если табличная часть есть, ложь в обратном случае
//
//Пример:
//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
//  	Возврат;
//  КонецЕсли;
//
Функция НаличиеТабличнойЧастиУСправочника(ИмяСправочника, ИмяТабличнойЧасти) Экспорт
	
	Возврат (Метаданные.Справочники[ИмяСправочника].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
	
КонецФункции 


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С УЧЕТНОЙ ПОЛИТИКОЙ

// Функция возвращает структуру с параметрами учетной политики на заданную дату.
//
Функция ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация = Неопределено, Учет = "Упр") Экспорт

	СтруктураУчПолитика = Новый Структура;
			
	Если Учет <> "Упр" И Не ЗначениеЗаполнено(Организация) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(КонДата) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;

	Если Учет = "Нал" Тогда
		УчетнаяПолитика = глЗначениеПеременной("глУчетнаяПолитикаПоНалоговомуУчету");
		
	ИначеЕсли Учет = "Упр" Тогда
		УчетнаяПолитика = глЗначениеПеременной("глУчетнаяПолитикаПоУправленческомуУчету");
		
	Иначе
		УчетнаяПолитика = глЗначениеПеременной("глУчетнаяПолитикаПоБухгалтерскомуУчету");
	КонецЕсли; 

	Если Учет = "Упр" Тогда
		
		Если УчетнаяПолитика.Количество() = 0 Тогда
			Отказ = Истина;
			СообщитьОбОшибке("Не указаны параметры учетной политики управленческого учета на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			Возврат СтруктураУчПолитика;	
		Иначе
				
			Номер = 0;
			ФлагОтказа = Истина;
			Для НомерСтроки = 1 По УчетнаяПолитика.Количество() Цикл
					
				Строка = УчетнаяПолитика.Получить(НомерСтроки - 1);
				Если Строка.Период <= КонДата Тогда
					Номер = НомерСтроки;
					ФлагОтказа = Ложь;
						
				Иначе 
					Прервать;
				КонецЕсли;
			КонецЦикла;
				
			Если Номер <> 0 Тогда
				Строка = УчетнаяПолитика.Получить(Номер - 1);
				Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
					СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
				КонецЦикла;
					
			КонецЕсли;
				
		КонецЕсли;
		
	Иначе
		
		УчетнаяПолитикаОрганизации = УчетнаяПолитика.НайтиСтроки(Новый Структура("Организация", Организация));
		
		Если УчетнаяПолитикаОрганизации.Количество() = 0 Тогда
			Отказ = Истина;
			СообщитьОбОшибке("Не указаны параметры учетной политики " + ?(Учет = "Нал", "налогового", "бухгалтерского") +" учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			Возврат СтруктураУчПолитика;	
		Иначе
				
			Номер = 0;
			ФлагОтказа = Истина;
			Для НомерСтроки = 1 По УчетнаяПолитикаОрганизации.Количество() Цикл
					
				Строка = УчетнаяПолитикаОрганизации.Получить(НомерСтроки - 1);
				Если Строка.Период <= КонДата Тогда
					Номер = НомерСтроки;
					ФлагОтказа = Ложь;
						
				Иначе 
					Прервать;
				КонецЕсли;
			КонецЦикла;
				
			Если Номер <> 0 Тогда
				Строка = УчетнаяПолитикаОрганизации.Получить(Номер - 1);
				Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
					СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
				КонецЦикла;
				
			КонецЕсли;
				
		КонецЕсли;
		
	КонецЕсли;
		
	Если ФлагОтказа = Истина Тогда
		Если Учет = "Упр" Тогда
			СообщитьОбОшибке("Не указаны параметры учетной политики управленческого учета на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
		Иначе
			СообщитьОбОшибке("Не указаны параметры учетной политики " + ?(Учет = "Нал", "налогового", "бухгалтерского") +" учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
		КонецЕсли;
		Возврат СтруктураУчПолитика;
	КонецЕсли; 
  	
	Возврат СтруктураУчПолитика;
	
КонецФункции // ПолучитьПараметрыУчетнойПолитики()
                   

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА

Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Если ВРег(ИмяПараметра) = ВРег("глИсчислениеНалоговСтруктурныхЕдиниц") Тогда
				Если НайденноеЗначение = Неопределено Тогда
					НайденноеЗначение = ПолныеПрава.ЗаполнитьИсчислениеНалоговСтруктурныхЕдиниц();
				КонецЕсли; 
			КонецЕсли;
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;

	// Значение в КЭШе не нашли, получим значение из БД
	Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
		НайденноеЗначение = ПараметрыСеанса.ТекущийПользователь;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоПерсоналу") Тогда
		// поскольку данная глобальная переменная присутствует не во всех конфигурациях,
		// то обращение к функции для ее заполнения через Вычислить()
		НайденноеЗначение = Вычислить("ЗаполнениеУчетнойПолитикиПоПерсоналу()");

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоПерсоналуОрганизации") Тогда
		// поскольку данная глобальная переменная присутствует не во всех конфигурациях,
		// то обращение к функции для ее заполнения через Вычислить()
		НайденноеЗначение = Вычислить("ПолныеПрава.ЗаполнениеУчетнойПолитикиПоПерсоналуОрганизации()");
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоБухгалтерскомуУчету") Тогда
		НайденноеЗначение = СоздатьКЭШУчетнойПолитики("БухгалтерскийУчет");
			
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоНалоговомуУчету") Тогда
		НайденноеЗначение = СоздатьКЭШУчетнойПолитики("НалоговыйУчет");
			
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоУправленческомуУчету") Тогда
		НайденноеЗначение = СоздатьКЭШУчетнойПолитики("");		
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("КэшСтратегииАвтонумерации") Тогда	
		НайденноеЗначение = Новый Соответствие;		
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глКоличествоСекундОпросаОбмена") Тогда
		НайденноеЗначение = Константы.ИнтервалДляОпросаРегламентныхЗаданийВФайловомВарианте.Получить();
		Если НайденноеЗначение = 0 Тогда
			НайденноеЗначение = 60;
		КонецЕсли; 
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоОбменДанными") Тогда
		НайденноеЗначение = ПроцедурыОбменаДанными.ВыполнитьИнициализациюАвтообменаПриНачалеРаботы();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глВедетсяУчетПоРасчетнымДокументам") Тогда
		// поскольку данная глобальная переменная присутствует не во всех конфигурациях,
		// то обращение к функции для ее заполнения через Вычислить()
		НайденноеЗначение = Вычислить("УправлениеВзаиморасчетами.ВедутсяВзаиморасчетыПоДокументам()");   
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глИсчислениеНалоговСтруктурныхЕдиниц") Тогда
		НайденноеЗначение = ПолныеПрава.ЗаполнитьИсчислениеНалоговСтруктурныхЕдиниц();   	
		
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глКомпонентаСклоненияФИО") Тогда

		#Если Клиент Тогда
		// поиск компоненты склонения ФИО
		КомпонентаНайдена = Ложь;
		Попытка
			ПодключитьВнешнююКомпоненту("ОбщийМакет.NameDecl_dll", "Decl", );
			НайденноеЗначение = Новый("AddIn.Decl.CNameDecl");
			КомпонентаНайдена = Истина;
		Исключение
			// Не удалось выполнить операции с внешней компонентой
			СообщитьОбОшибке("Ошибка записи временного файла внешней компоненты для склонения ФИО! Возможно нет административных прав!");
		КонецПопытки;		
		
		Если НЕ КомпонентаНайдена Тогда
			// Не удалось выполнить операции с внешней компонентой
			СообщитьОбОшибке("Ошибка загрузки внешней компоненты для склонения ФИО! Функции склонения будут недоступны!");
		КонецЕсли;
		#Иначе
		НайденноеЗначение = Неопределено;
					
		#КонецЕсли

	#Если Клиент Тогда
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоПолученияОтправкиЭлектронныхПисем") Тогда	
		МетаданныеОбработки = Метаданные.Обработки.Найти("АвтоПолучениеОтправкаЭлектронныхПисем");
		Если МетаданныеОбработки <> Неопределено Тогда
			Если ПравоДоступа("Использование", МетаданныеОбработки) Тогда
				НайденноеЗначение = Обработки["АвтоПолучениеОтправкаЭлектронныхПисем"].ПолучитьФорму();
			Иначе
				НайденноеЗначение = Неопределено;
			КонецЕсли;		
		Иначе
			НайденноеЗначение = Неопределено;
		КонецЕсли;

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глСоответствиеТекстовЭлектронныхПисем") Тогда
			НайденноеЗначение = Новый Соответствие;				

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаСообщений") Тогда
		НайденноеЗначение = Обработки.СообщенияВыполняемыхДействий.Создать();

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ФормаОповещенияОЗадачах") Тогда	
		НайденноеЗначение = Задачи["усд_ЗадачиСогласованияДокументов"].ПолучитьФорму("ФормаОповещенияОЗадачах", ,"Оригинал");
		
	#КонецЕсли
    		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ЗначенияДополнительныхПравПользователя") Тогда
		НайденноеЗначение = Новый Соответствие;
	
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глПоследняяОткрытаяФормаПечатьДокументов") Тогда
		// это глобальная переменная для хранения ссылки на последнюю открытую форму печати,
		// если еще ни разу за время сеанса форму печати не открывали, то просто возвратим Неопределено
		НайденноеЗначение = Неопределено;
	#Если Клиент Тогда	
				
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глЗапрашиватьПодтверждениеПриЗакрытии") Тогда	
		НайденноеЗначение = Истина;		
		
	#КонецЕсли
	
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глИспользоватьУправленческийУчет") Тогда
		НайденноеЗначение = Константы.ИспользоватьУправленческийУчет.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ИспользоватьПочтовыйКлиент") Тогда
		НайденноеЗначение = Константы.ИспользованиеВстроенногоПочтовогоКлиента.Получить();
	ИначеЕсли Врег(ИмяПараметра) = ВРег("глСписокСчетовПроизводстваБУ") Тогда
		НайденноеЗначение = ПроцедурыБухгалтерскогоУчета.ПолучитьСписокСчетовПроизводственногоУчета();
		
	ИначеЕсли Врег(ИмяПараметра) = ВРег("глСписокСчетовПроизводстваНУ") Тогда
		НайденноеЗначение = ПроцедурыБухгалтерскогоУчета.ПолучитьСписокСчетовПроизводственногоУчетаНУ();
		
	ИначеЕсли Врег(ИмяПараметра) = ВРег("глСписокСчетовВА") Тогда
		НайденноеЗначение = ПроцедурыБухгалтерскогоУчета.ПолучитьСписокСчетовВАУчетаНУ();
			
		
  	ИначеЕсли Метаданные.Константы.Найти("фин_"+ВРег(ИмяПараметра))<>Неопределено Тогда
		НайденноеЗначение = Константы["фин_"+ВРег(ИмяПараметра)].Получить();
  	ИначеЕсли Метаданные.Константы.Найти("узп_"+ВРег(ИмяПараметра))<>Неопределено Тогда
		НайденноеЗначение = Константы["узп_"+ВРег(ИмяПараметра)].Получить();
  	ИначеЕсли Метаданные.Константы.Найти("дог_"+ВРег(ИмяПараметра))<>Неопределено Тогда
		НайденноеЗначение = Константы["дог_"+ВРег(ИмяПараметра)].Получить();
   	ИначеЕсли Метаданные.Константы.Найти("ден_"+ВРег(ИмяПараметра))<>Неопределено Тогда
		НайденноеЗначение = Константы["ден_"+ВРег(ИмяПараметра)].Получить();
	ИначеЕсли Метаданные.Константы.Найти("усд_"+ВРег(ИмяПараметра))<>Неопределено Тогда
		НайденноеЗначение = Константы["усд_"+ВРег(ИмяПараметра)].Получить();
	ИначеЕсли Метаданные.Константы.Найти("общ_"+ВРег(ИмяПараметра))<>Неопределено Тогда
		НайденноеЗначение = Константы["общ_"+ВРег(ИмяПараметра)].Получить();
	ИначеЕсли Метаданные.Константы.Найти(ВРег(ИмяПараметра))<>Неопределено Тогда
		НайденноеЗначение = Константы[ВРег(ИмяПараметра)].Получить();
	Иначе
		СтрокаИсключения = "Невозможно обработать параметр " + """" + ИмяПараметра + """" + " для получения значения";
		ВызватьИсключение СтрокаИсключения;
	КонецЕсли;
	
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции

Процедура УстановитьЗначениеПеременной(ИмяПараметра, Кэш, ЗначениеПараметра, ОбновлятьВоВсехКэшах = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	КонецЕсли;

	Если Кэш.Свойство(ИмяПараметра) Тогда
		Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
	КонецЕсли;
	
	#Если Клиент ИЛИ ВнешнееСоединение Тогда
		Если ОбновлятьВоВсехКэшах Тогда
			Кэш = ПараметрыСеанса.ОбщиеЗначения.Получить();
			Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
			ПараметрыСеанса.ОбщиеЗначения = Новый ХранилищеЗначения(Кэш);
		КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

Процедура УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, ПроверятьДвижения = Ложь)Экспорт
	// получение списка последовательностей в которых зарегистрирован документ
	Если ПроверятьДвижения Тогда
		ТаблицаРегистраций = ОпределитьНаличиеРегистрацииДокументаВПоследовательности(ДокументОбъект);
	КонецЕсли;      
	КоллекцияПоследовательностей = ДокументОбъект.ПринадлежностьПоследовательностям;
	Для Каждого НаборЗаписейРегистрацииВПоследовательности ИЗ КоллекцияПоследовательностей Цикл
		Если (НаборЗаписейРегистрацииВПоследовательности.Количество() > 0)
		  ИЛИ (ПроверятьДвижения И (НЕ ТаблицаРегистраций.Найти(НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя,"Имя") = Неопределено)) Тогда
		   НаборЗаписейРегистрацииВПоследовательности.Очистить();
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры//УдалитьРегистрациюДокументаВПоследовательностях

Функция ОпределитьНаличиеРегистрацииДокументаВПоследовательности(ДокументОбъект) Экспорт
	ТекстЗапроса = "";	
	
	Для Каждого Последовательность ИЗ ДокументОбъект.ПринадлежностьПоследовательностям Цикл
		// в запросе получаем имена последовательностей, в которых документ зарегистрирован
		ТекстЗапроса = ТекстЗапроса + "
		|" + ?(ТекстЗапроса = "", "", "ОБЪЕДИНИТЬ ВСЕ ") + "
		|ВЫБРАТЬ """ + Последовательность.Метаданные().Имя 
		+  """ КАК Имя ИЗ " + Последовательность.Метаданные().ПолноеИмя()  
		+ " ГДЕ Регистратор = &Регистратор";
		
	КонецЦикла;
	
	Если ТекстЗапроса = "" Тогда
		Возврат Новый ТаблицаЗначений();
	Иначе
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Регистратор", ДокументОбъект.Ссылка);
		ТаблицаЗапроса = Запрос.Выполнить().Выгрузить();	
		Возврат ТаблицаЗапроса;
	КонецЕсли;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	Если НЕ ПустаяСтрока(ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы) Тогда
		Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	КонецЕсли;
	
КонецПроцедуры // ДобавитьПрефиксУзла()

Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.ИмяПриложения <> "BackgroundJob" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура СообщитьИнформацияОПрефиксации() Экспорт
	
	Если ПустаяСтрока(ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы) Тогда
		
		Сообщить("Для задействования механизма установки префиксов объектов необходимо установить константу ""Префикс узла для распределенной информационной базы"" 
			| и перезапустить текущий сеанс работы 1С:Предприятия.");
		Сообщить("Текущее значение префикса: " + ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы);
		
	КонецЕсли;
	
КонецПроцедуры


// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Проверка того, что тип имеет ссылочный тип данных
//
Функция ЭтоСсылка(Тип) Экспорт
	
	Возврат Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);
	
КонецФункции
	
Функция ПолучитьКлючиСтруктурыСтрокой(Структура, Разделитель = ",") Экспорт
	
	Результат = "";
	
	Для Каждого Элемент Из Структура Цикл
		
		СимволРазделителя = ?(ПустаяСтрока(Результат), "", Разделитель);
		
		Результат = Результат + СимволРазделителя + Элемент.Ключ;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Создает новый экземпляр объекта Структура, заполняет объект данными указанной структуры.
//
// Параметры:
//  СтруктураИсточник – Структура – структура, копию которой необходимо получить
// 
//  Возвращаемое значение:
//  Тип: Структура.
//
Функция СкопироватьСтруктуру(СтруктураИсточник) Экспорт
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого Элемент ИЗ СтруктураИсточник Цикл
		
		СтруктураРезультат.Вставить(Элемент.Ключ, Элемент.Значение);
		
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции


// Возвращает выборку со значениями реквизитов переданной ссылки
//
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	" + ИменаРеквизитов + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	Результат = Новый Структура(ИменаРеквизитов);
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Получает имя значения перечисления как объекта метаданных
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЕМ ПЕРИОДИЧНОСТЬ (ДЕНЬ, НЕДЕЛЯ, МЕСЯЦ, КВАРТАЛ, ГОД)

// Функция возвращает ближайшую дату начала периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаНачалаПериода		– ближайшая дата начала периода планирования
//
Функция ДатаНачалаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Если НЕ ТипЗнч(ДатаВПериоде)=Тип("Дата") Тогда
		Возврат '00010101';
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат НачалоДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат НачалоНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат НачалоМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат НачалоКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат НачалоГода (ДатаВПериоде);
	Иначе
		Возврат НачалоДня(ДатаВПериоде);
	КонецЕсли;
	
КонецФункции // ДатаНачалаПериода()

// Функция возвращает ближайшую дату окончания периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаКонцаПериода	– ближайшая дата окончания периода планирования
//
Функция ДатаКонцаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат КонецДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат КонецНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат КонецМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат КонецКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат КонецГода (ДатаВПериоде);
	Иначе
		Возврат КонецДня(ДатаВПериоде);
	КонецЕсли;
	
КонецФункции // ДатаКонцаПериода()

// Функция добавляет интервал к дате
//
// Параметры:
//	Периодичность (Перечисления.Периодичность)	- пнриодичность 
//	ДатаВПериоде (Дата)							- произвольная дата
//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
//
// Возвращаемое значение:
//	Дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт

	Если Смещение=0 Тогда
		НоваяДатаПериода=ДатаПериода;	
	ИначеЕсли Периодичность=Перечисления.Периодичность.День Тогда
		НоваяДатаПериода=НачалоДня(ДатаПериода+Смещение*24*3600);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода=НачалоНедели(ДатаПериода+Смещение*7*24*3600);

	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода=ДобавитьМесяц(ДатаПериода,Смещение);

	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода=ДобавитьМесяц(ДатаПериода,Смещение*3);

	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода=ДобавитьМесяц(ДатаПериода,Смещение*12);

	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода+Смещение*24*3600);

	КонецЕсли;

	Возврат НоваяДатаПериода;

КонецФункции

// Возвращает строку, описывающую период, определяемый переданными
// датой и периодичностью.
//
// Параметры
//  ДатаВПериоде:Дата - дата из периода
//  Периодичность: Строка - строка, определяющая периодичность
//
// Возвращаемое значение:
//   СтрокаПериод: строка   – представление периода для вывода в отчетах
//
Функция ПолучитьПериодСтрокой(ДатаВПериоде, Периодичность) Экспорт

	Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ='гггг ""г.""'";
		
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ='к"" квартал"" гггг ""г.""'";
		
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ='ММММ гггг ""г.""'";
		
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ='""Неделя (""дд.ММ.гггг'";
		
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ='дд.ММ.гггг ""г.""'";
		
	Иначе
		ФорматДаты = "";
	КонецЕсли;
	
	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
		СтрокаПериод = "" + НеделяГода(ДатаВПериоде) + "-ая " + СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ='"" - ""дд.ММ.гггг)'");
	КонецЕсли;
	
	Возврат СтрокаПериод;
	
КонецФункции // ПолучитьПериодСтрокой()

// Предназначена для реализации "произвольного" ввода даты-месяца
// подбирает по переданному тексту строку-представление даты или список таких строк
// в переданный параметр ДатаПоТексту возвращает подобранную по тексту дату
//
Функция ПериодПодобратьПоТексту(Текст, Периодичность, ДатаПоТексту = Неопределено) ЭКспорт
	
	СписокВозврата = Новый СписокЗначений;
	
	ТекущаяДата		= ПолучитьРабочуюДату();
	ТекущийГод		= Год(ТекущаяДата);
	ТекущийКвартал	= Цел(Месяц(ТекущаяДата) / 4) + 1;
	ТекущийМесяц	= Месяц(ТекущаяДата);
	ТекущаяНеделя	= НеделяГода(ТекущаяДата);
	ТекущийДень		= День(ТекущаяДата);
	
	НачалоГода		= НачалоГода(ТекущаяДата);
	НачалоМесяца	= НачалоМесяца(ТекущаяДата);
	КонецГода		= КонецГода(ТекущаяДата);
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат СписокВозврата;
	КонецЕсли;
	
	Если Найти(Текст, ".") <> 0 Тогда
		Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, ".");
		ИспользуемыйРазделитель = ".";
		
	ИначеЕсли Найти(Текст, ",") <> 0 Тогда
		Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, ",");
		ИспользуемыйРазделитель = ",";
		
	ИначеЕсли Найти(Текст, "-") <> 0 Тогда
		Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, "-");
		ИспользуемыйРазделитель = "-";
		
	ИначеЕсли Найти(Текст, "/") <> 0 Тогда
		Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, "/");
		ИспользуемыйРазделитель = "/";
		
	ИначеЕсли Найти(Текст, "\") <> 0 Тогда
		Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, "\");
		ИспользуемыйРазделитель = "\";
		
	Иначе
		Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, " ");
		ИспользуемыйРазделитель = " ";
		
	КонецЕсли;
	
	Если Периодичность = Перечисления.Периодичность.День Тогда
		КонецПериода = День(КонецМесяца(ТекущаяДата));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		КонецПериода = НеделяГода(КонецГода);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		КонецПериода = 12;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		КонецПериода = 4;
		
	КонецЕсли;
	
	Если Подстроки.Количество() = 1 И Периодичность <> Перечисления.Периодичность.Год Тогда
		// единственное слово - пытаемся получить период
		
		Если ТолькоЦифрыВСтроке(Текст) Тогда
			ПериодЧислом = Число(Текст);
			
			Если ПериодЧислом >= 1 И ПериодЧислом <= КонецПериода Тогда
				Если Периодичность = Перечисления.Периодичность.День Тогда
					ДатаПоТексту = ДобавитьИнтервал(НачалоМесяца, Периодичность, ПериодЧислом - 1);
				Иначе
					ДатаПоТексту = ДобавитьИнтервал(НачалоГода, Периодичность, ПериодЧислом - 1);
				КонецЕсли;
				
				Если Периодичность = Перечисления.Периодичность.День Тогда
					Если СтрДлина(Текст) = 1 Тогда
						ФорматированнаяДата	= Формат(ДатаПоТексту, "ДФ=d/MM/yyyy");
					Иначе
						ФорматированнаяДата	= Формат(ДатаПоТексту, "ДФ=dd/MM/yyyy");
					КонецЕсли;
					
				ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
					ФорматированнаяДата = Текст + Формат(ДатаПоТексту, "ДФ=/yyyy");
					
				ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
					ФорматированнаяДата = Текст + Формат(ДатаПоТексту, "ДФ=/yyyy");
					
				ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
					Если СтрДлина(Текст) = 1 Тогда
						ФорматированнаяДата	= Формат(ДатаПоТексту, "ДФ=M/yyyy");
					Иначе
						ФорматированнаяДата	= Формат(ДатаПоТексту, "ДФ=MM/yyyy");
					КонецЕсли;
					
				Иначе // Год
					ФорматированнаяДата = Текст;
					
				КонецЕсли;
				
				СписокВозврата.Добавить(ФорматированнаяДата);
			КонецЕсли;
				
		Иначе
			Если Периодичность = Перечисления.Периодичность.Месяц Тогда
				СписокМесяцев = СписокМесяцевПоСтроке(Текст);
				Для Каждого Месяц Из СписокМесяцев Цикл
					ДатаПоТексту = Дата(ТекущийГод, Месяц, 1);
					СписокВозврата.Добавить(Формат(ДатаПоТексту, "ДФ='ММММ гггг ""г""'"));
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;
	
	Иначе
		Если Периодичность = Перечисления.Периодичность.День Тогда
			Если Подстроки.Количество() >= 2 И Не ПустаяСтрока(Подстроки[1]) И ТолькоЦифрыВСтроке(Подстроки[1]) Тогда
				Месяц				= Число(Подстроки[1]);
				Если Месяц >= 1 И Месяц <= КонецПериода Тогда
					ФорматДляМесяца	= Прав("MM", СтрДлина(Подстроки[1]));
				Иначе
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Если ТолькоЦифрыВСтроке(Подстроки[1]) Тогда
					Месяц				= ТекущийМесяц;
					ФорматДляМесяца		= "MM";
				Иначе
					СписокМесяцев = СписокМесяцевПоСтроке(Подстроки[1]);
					Если СписокМесяцев.Количество() = 1 Тогда
						Месяц				= СписокМесяцев[0];
						ФорматДляМесяца		= "MMMM";
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Если Подстроки.Количество() >= 3 И Не ПустаяСтрока(Подстроки[2]) И ТолькоЦифрыВСтроке(Подстроки[2]) Тогда
				Год				= Число(Лев(Формат(ТекущийГод, "ЧГ="), 4-СтрДлина(Подстроки[2])) + Подстроки[2]);
				Если Год >= 1900 И Год < 3000 Тогда
					ФорматДляГода	= Прав("yyyy", СтрДлина(Подстроки[2]));
				Иначе
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Год				= ТекущийГод;
				ФорматДляГода	= "yyyy";
			КонецЕсли;
			
			Если Подстроки.Количество() >= 1 И Не ПустаяСтрока(Подстроки[0]) И ТолькоЦифрыВСтроке(Подстроки[0]) Тогда
				День				= Число(Подстроки[0]);
				Если День >= 1 И Месяц <> Неопределено И День <= День(КонецМесяца(Дата(Год, Месяц, 1))) Тогда
					ФорматДляДня	= Прав("dd", СтрДлина(Подстроки[0]));
				Иначе
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Возврат СписокВозврата;
			КонецЕсли;
			
			ДатаПоТексту = Дата(Год, Месяц, День);
			
			Если Подстроки.Количество() < 3 ИЛИ ПустаяСтрока(Подстроки[2]) Тогда
				ФорматированнаяДата	= Формат(ДатаПоТексту, "ДФ='" + ФорматДляДня + ИспользуемыйРазделитель + ФорматДляМесяца + ИспользуемыйРазделитель + ФорматДляГода + "'");
			Иначе
				ФорматированнаяДата	= "";
			КонецЕсли;
			
		ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
			Если Подстроки.Количество() >= 2 И Не ПустаяСтрока(Подстроки[1]) И ТолькоЦифрыВСтроке(Подстроки[1]) Тогда
				Год				= Число(Лев(Формат(ТекущийГод, "ЧГ="), 4-СтрДлина(Подстроки[1])) + Подстроки[1]);
				Если Год >= 1900 И Год < 3000 Тогда
					ФорматДляГода	= Прав("yyyy", СтрДлина(Подстроки[1]));
				Иначе
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Год				= ТекущийГод;
				ФорматДляГода	= "yyyy";
			КонецЕсли;
			
			Если Подстроки.Количество() >= 1 И Не ПустаяСтрока(Подстроки[0]) И ТолькоЦифрыВСтроке(Подстроки[0]) Тогда
				Неделя	= Число(Подстроки[0]) - 1;
				Если Неделя < 1 ИЛИ Неделя > НеделяГода(Дата(Год, 12, 31)) Тогда
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Возврат СписокВозврата;
			КонецЕсли;
			
			ДатаПоТексту = ДобавитьИнтервал(Дата(Год, 1, 1), Периодичность, Неделя);
			
			Если Подстроки.Количество() < 2 ИЛИ ПустаяСтрока(Подстроки[1]) Тогда
				ФорматированнаяДата	= Подстроки[0] + ИспользуемыйРазделитель + Формат(ДатаПоТексту, "ДФ='" + ФорматДляГода + "'");
			Иначе
				ФорматированнаяДата	= "";
			КонецЕсли;
			
		ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
			Если Подстроки.Количество() >= 1 И Не ПустаяСтрока(Подстроки[0]) И ТолькоЦифрыВСтроке(Подстроки[0]) Тогда
				Месяц			= Число(Подстроки[0]);
				Если Месяц >= 1 И Месяц <= КонецПериода Тогда
					ФорматДляМесяца	= Прав("MM", СтрДлина(Подстроки[0]));
				Иначе
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Возврат СписокВозврата;
			КонецЕсли;
			
			Если Подстроки.Количество() >= 2 И Не ПустаяСтрока(Подстроки[1]) И ТолькоЦифрыВСтроке(Подстроки[1]) Тогда
				Год				= Число(Лев(Формат(ТекущийГод, "ЧГ="), 4-СтрДлина(Подстроки[1])) + Подстроки[1]);
				Если Год >= 1900 И Год < 3000 Тогда
					ФорматДляГода	= Прав("yyyy", СтрДлина(Подстроки[1]));
				Иначе
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Год				= ТекущийГод;
				ФорматДляГода	= "yyyy";
			КонецЕсли;
			
			ДатаПоТексту = Дата(Год, Месяц, 1);
			
			Если Подстроки.Количество() < 2 ИЛИ ПустаяСтрока(Подстроки[1]) Тогда
				ФорматированнаяДата	= Формат(ДатаПоТексту, "ДФ='" + ФорматДляМесяца + ИспользуемыйРазделитель + ФорматДляГода + "'");
			Иначе
				ФорматированнаяДата	= "";
			КонецЕсли;
			
		ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
			Если Подстроки.Количество() >= 1 И Не ПустаяСтрока(Подстроки[0]) И ТолькоЦифрыВСтроке(Подстроки[0]) Тогда
				Квартал	= (Число(Подстроки[0]));
				Если Квартал < 1 ИЛИ Квартал > КонецПериода Тогда
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Возврат СписокВозврата;
			КонецЕсли;
			
			Если Подстроки.Количество() >= 2 И Не ПустаяСтрока(Подстроки[1]) И ТолькоЦифрыВСтроке(Подстроки[1]) Тогда
				Год				= Число(Лев(Формат(ТекущийГод, "ЧГ="), 4-СтрДлина(Подстроки[1])) + Подстроки[1]);
				Если Год >= 1900 И Год < 3000 Тогда
					ФорматДляГода	= Прав("yyyy", СтрДлина(Подстроки[1]));
				Иначе
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Год				= ТекущийГод;
				ФорматДляГода	= "yyyy";
			КонецЕсли;
			
			ДатаПоТексту = Дата(Год, (Квартал - 1) * 3 + 1, 1);
			
			Если Подстроки.Количество() < 2 ИЛИ ПустаяСтрока(Подстроки[1]) Тогда
				ФорматированнаяДата	= Подстроки[0] + ИспользуемыйРазделитель + Формат(ДатаПоТексту, "ДФ='" + ФорматДляГода + "'");
			Иначе
				ФорматированнаяДата	= "";
			КонецЕсли;
			
		ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
			Если Подстроки.Количество() >= 1 И Не ПустаяСтрока(Подстроки[0]) И ТолькоЦифрыВСтроке(Подстроки[0]) Тогда
				Год				= Число(Лев(Формат(ТекущийГод, "ЧГ="), 4-СтрДлина(Подстроки[0])) + Подстроки[0]);
				Если Год >= 1900 И Год < 3000 Тогда
					ФорматДляГода	= Прав("yyyy", СтрДлина(Подстроки[0]));
				Иначе
					Возврат СписокВозврата;
				КонецЕсли;
			Иначе
				Возврат СписокВозврата;
			КонецЕсли;
			
			ДатаПоТексту = Дата(Год, 1, 1);
			
			Если Подстроки.Количество() < 2 ИЛИ ПустаяСтрока(Подстроки[1]) Тогда
				ФорматированнаяДата = Подстроки[0] + " год";
			Иначе
				ФорматированнаяДата	= "";
			КонецЕсли;
			
		КонецЕсли;
		
		СписокВозврата.Добавить(ФорматированнаяДата);
		
	КонецЕсли;
	
	Возврат СписокВозврата;
	
КонецФункции // ПериодПодобратьПоТексту()

// Подбирает массив номеров месяцев, соответствующих переданной строке
// например, для строки "ма" это будут 3 и 5, для "а" - 4 и 8
// используется в ПодобратьДатуПоТексту
//
Функция СписокМесяцевПоСтроке(Текст) Экспорт
	
	СписокМесяцев = Новый СписокЗначений;
	Месяцы = Новый Соответствие;
	МесяцыВозврата = Новый Массив;
	
	Для Счетчик = 1 По 12 Цикл
		Представление = Формат(Дата(2000, Счетчик, 1), "ДФ='ММММ'");
		СписокМесяцев.Добавить(Счетчик, Представление);
		Представление = Формат(Дата(2000, Счетчик, 1), "ДФ='МММ'");
		СписокМесяцев.Добавить(Счетчик, Представление);
	КонецЦикла;
	
	Для Каждого ЭлементСписка Из СписокМесяцев Цикл
		Если ВРег(Текст) = ВРег(Лев(ЭлементСписка.Представление, СтрДлина(Текст))) Тогда
			Месяцы[ЭлементСписка.Значение] = 0;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Элемент Из Месяцы Цикл
		МесяцыВозврата.Добавить(Элемент.Ключ);
	КонецЦикла;
	
	Возврат МесяцыВозврата;
	
КонецФункции // СписокМесяцевПоСтроке()

// Процедура - обработчик события Автоподбор поля ввода периода 
//
Процедура ПериодАвтоПодборТекста(Текст, ТекстАвтоПодбора, Периодичность, СтандартнаяОбработка) Экспорт
	
	СтандартнаяОбработка = Ложь;
	
	Список = ПериодПодобратьПоТексту(Текст, Периодичность);
	Если Список.Количество() = 1 Тогда
		ТекстАвтоПодбора = Список[0].Значение;
	КонецЕсли;
	
КонецПроцедуры // ПериодАвтоПодборТекста()

// Процедура - обработчик события ОкончаниеВводаТекста поля ввода периода 
//
Процедура ПериодОкончаниеВводаТекста(Текст, Значение, Периодичность, СтандартнаяОбработка, ДатаПоТексту = Неопределено) Экспорт
	
	СтандартнаяОбработка = Ложь;
	
	Список = ПериодПодобратьПоТексту(Текст, Периодичность, ДатаПоТексту);
	Если Список.Количество() = 1 Тогда
		Значение = Список[0].Значение;
	Иначе
		Значение = Список;
	КонецЕсли;
	
КонецПроцедуры // ПериодОкончаниеВводаТекста()

/////////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ  - ОБРАБОТЧИКИ ПОДПИСОК НА СОБЫТИЯ МЕХАНИЗМА ОБРАБОТКИ ОБЩИХ РЕКВИЗИТОВ 

// процедура формирования номера документа
//
Процедура ПриУстановкеНовогоНомераДляДокументов(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ОбщегоНазначения.ДобавитьПрефиксОрганизации(Источник, Префикс);
	ОбщегоНазначения.ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

// процедура формирования номера документа с дополнительным префиксом счета
//
Процедура ПриУстановкеНовогоНомераДляДокументовСПрефиксомБанковскиеСчета(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ДобавитьПрефиксБанковскогоСчета(Источник, Префикс);
	ДобавитьПрефиксОрганизации(Источник, Префикс);
	ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

// процедура формирования номера документа с дополнительным префиксом кассы
//
Процедура ПриУстановкеНовогоНомераДляДокументовСПрефиксомКассы(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ДобавитьПрефиксКассы(Источник, Префикс);	
	ДобавитьПрефиксОрганизации(Источник, Префикс);
	ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

// процедура формирования номера документа с дополнительным префиксом склада
//
Процедура ПриУстановкеНовогоНомераДляДокументовСПрефиксомСклады(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ДобавитьПрефиксСклада(Источник, Префикс);	
	ДобавитьПрефиксОрганизации(Источник, Префикс);
	ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

// Процедура обрабатывает событие ПриУстановкеНовогоКода справочника
//
Процедура ПриУстановкеНовогоКодаСправочника(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	ДобавитьПрефиксУзла(Префикс);
	
КонецПроцедуры

// Процедура - обработчик события ПриУстановкеНовогоКода для подписки на событие
//
Процедура ПриУстановкеКодаПВХПриУстановкеНовогоКода(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры // ПриУстановкеКодаПВХПриУстановкеНовогоКода()

// Процедура обрабатывает событие ПриКопирование документа
// Перднозначена для очистки общих реквизитов при копировании документа
Процедура ПриКопированиеДокументаОчисткаОбщихРеквизитов(Источник, ОбъектКопирования) Экспорт
	
	Если Источник.Метаданные().Реквизиты.Найти("Автор") <> Неопределено Тогда 
		Источник.Автор = Справочники.Пользователи.ПустаяСсылка()
	КонецЕсли;
	
	Если Источник.Метаданные().Реквизиты.Найти("РучнаяКорректировка") <> Неопределено Тогда 
		Источник.РучнаяКорректировка = Ложь
	КонецЕсли;
	
	Если Источник.Метаданные().Реквизиты.Найти("ДокументОснование") <> Неопределено Тогда 
		Источник.ДокументОснование = Неопределено
	КонецЕсли;
	
	Если Источник.Метаданные().Реквизиты.Найти("СтруктурноеПодразделение") <> Неопределено Тогда 
		Если НЕ ПолучитьПризнакОтображенияСтруктурныхПодразделений() Тогда 
			Источник.СтруктурноеПодразделение = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();
		КонецЕсли;
	КонецЕсли;
	
	Если Источник.Метаданные().Реквизиты.Найти("УдалитьДоверенность") <> Неопределено Тогда		
		Источник.УдалитьДоверенность = "";
	КонецЕсли;
	
	Если Источник.Метаданные().Реквизиты.Найти("ЗаявкаПрошлаСогласованиеРук") <> Неопределено Тогда		
		Источник.ЗаявкаПрошлаСогласованиеРук = "";
	КонецЕсли; 
	
	Если Источник.Метаданные().Реквизиты.Найти("ЗаявкаВключенаВРеестр") <> Неопределено Тогда		
		Источник.ЗаявкаВключенаВРеестр = "";
	КонецЕсли; 
	
	Если Источник.Метаданные().Реквизиты.Найти("ЗаявкаПрошлаСогласованиеКурирующимЧП") <> Неопределено Тогда		
		Источник.ЗаявкаПрошлаСогласованиеКурирующимЧП = "";
	КонецЕсли; 
	
	Если Источник.Метаданные().Реквизиты.Найти("РасчетнаяДатаПлатежа") <> Неопределено Тогда		
		Источник.РасчетнаяДатаПлатежа = "";
	КонецЕсли; 

	//Если Источник.Метаданные().ТабличныеЧасти.Найти("РасчетнаяТаблица") <> Неопределено Тогда		
	//	Источник.РасчетнаяТаблица.Очистить();
	//КонецЕсли; 

	Если Источник.Метаданные().ТабличныеЧасти.Найти("Подписи") <> Неопределено Тогда		
		Источник.Подписи.Очистить();
	КонецЕсли; 
	
	//-=-=
	Если Источник.Метаданные().Реквизиты.Найти("ЗаявкаПрошлаСогласованиеРуководительФД") <> Неопределено Тогда		
		Источник.ЗаявкаПрошлаСогласованиеРуководительФД = "";
	КонецЕсли;  
	//-=-=
КонецПроцедуры

// Процедура обрабатывает событие ПередЗаписью документа
// Перднозначена для очистки реквизита РучнаяКорректировка в случае отмены проведения документа
//
Процедура ПередЗаписьюДокументаОчисткаРеквизитаРучнаяКорректировка(Источник, Отказ, РежимЗаписи, РежимПроведения) Экспорт
	
	Если (Источник.РучнаяКорректировка) И (РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения) Тогда 
		Источник.РучнаяКорректировка = Ложь
	КонецЕсли;	
	
КонецПроцедуры


///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ , ПРЕДНАЗНАЧЕННЫЕ ДЛЯ СВЕРТКИ ЗАПИСЕЙ В РЕГИСТРАХ

// Процедура сворачивает движения по регистру накопления
//
Процедура СвернутьТаблицуДвиженийРегистраНакопления(НаборДвижений, ТабДвижений = Неопределено, УдалятьПустыеДвижения = Ложь) Экспорт
	
	Если ТипЗнч(НаборДвижений) = Тип("Строка") Тогда
		МетаРег = Метаданные.РегистрыНакопления[НаборДвижений];
		ТаблицаДвижений = ТабДвижений;
	Иначе
		МетаРег = НаборДвижений.Метаданные();
		Если ТабДвижений = Неопределено Тогда
			ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
		Иначе
			ТаблицаДвижений = ТабДвижений;
		КонецЕсли;
	КонецЕсли;
	
	
	Если ТаблицаДвижений = Неопределено ИЛИ ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Измерения = "Период,Регистратор,Активность";
	Если МетаРег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
		Измерения = Измерения + ",ВидДвижения";
	КонецЕсли;
	
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	
	Ресурсы = "";
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Ресурсы = Ресурсы + МетаРес.Имя + ",";
	КонецЦикла;
	
	ТаблицаДвижений.Свернуть(Измерения, Ресурсы);
	
	Если УдалятьПустыеДвижения Тогда
		
		СтруктРесурсы   = Новый Структура(Ресурсы);
		МассивПустСтрок = Новый Массив;
		СтруктПоиска    = Новый Структура;
		
		Для Каждого РесурсКлюч Из СтруктРесурсы Цикл
			СтруктПоиска.Вставить( РесурсКлюч.Ключ, 0);
		КонецЦикла;
		
		МассивПустСтрок = ТаблицаДвижений.НайтиСтроки(СтруктПоиска);
		Для К = 0 По МассивПустСтрок.ВГраница() Цикл
			ТаблицаДвижений.Удалить(МассивПустСтрок[К]);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры // СвернутьТаблицуДвиженийРегистраНакопления()

// Процедура сворачивает переданный набор записей регистра бухгалтерии по измерениям и реквизитам
// Параметры: НаборЗаписейРегистраБухгалтерии, тип - набор записей регистров бухгалтерии Налоговый или Типовой
//            СтрокаГруппировка, тип - строка - список колонок таблицы значений по которым будет выполняться группировка
//            СтрокаСуммирование, тип - строка - список колонок таблицы значений которые будут суммироваться
Процедура СвернутьНаборЗаписейРегистраБухгалтерии(НаборЗаписейРегистраБухгалтерии, СтрокаГруппировка, СтрокаСуммирование) Экспорт
	Перем ТаблицаЗаписейРегистраБухгалтерии;
	
	КоличествоЗаписейНабораЗаписей = НаборЗаписейРегистраБухгалтерии.Количество();
	//Если количество записей не больше 1 - не требуется выполнять сворачивание
	Если КоличествоЗаписейНабораЗаписей<=1 Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаЗаписейРегистраБухгалтерии = НаборЗаписейРегистраБухгалтерии.Выгрузить();
	//Данная колонка в таблице не нужна
	ТаблицаЗаписейРегистраБухгалтерии.Колонки.Удалить("НомерСтроки");
	
	
	ТаблицаЗаписейРегистраБухгалтерии.Свернуть(СтрокаГруппировка,СтрокаСуммирование);
	//ничего не свернулось, количество записей осталось без изменений 
	//	- не требуется загружать свернутую таблицу в набор записей 
	Если ТаблицаЗаписейРегистраБухгалтерии.Количество()=КоличествоЗаписейНабораЗаписей Тогда
		Возврат;
	КонецЕсли;
	
	//поиск и удаление проводок с пустым  количеством и суммой
	
	//готовим структуру поиска - нулевые значения колонок, которые входят в список суммируемых колонок
	СтруктураПоиска = новый Структура(СтрокаСуммирование);
	Для каждого элементСтруктуры из СтруктураПоиска цикл
		СтруктураПоиска[ЭлементСтруктуры.Ключ]=0;
	КонецЦикла;
	МассивСтрокКУдалению = ТаблицаЗаписейРегистраБухгалтерии.НайтиСтроки(СтруктураПоиска);
	//удаление строк с пустыми значениями суммируемых колонок
	Если МассивСтрокКУдалению.Количество()>0 Тогда
		Для каждого ЭлементМассива из МассивСтрокКУдалению цикл
			 ТаблицаЗаписейРегистраБухгалтерии.Удалить(ЭлементМассива);
		конецЦикла;
	КонецЕсли;
	
	НаборЗаписейРегистраБухгалтерии.Загрузить(ТаблицаЗаписейРегистраБухгалтерии);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПО РАБОТЕ С ПРАВАМИ ПОЛЬЗОВАТЕЛЕЙ

// Функция проверяет, есть ли доступ к объекту метаданных.
// 
// Параметры:
//  ОбъектМетаданных    - объект метаданных, к которому нужно проверить доступ.
//  Право               - Строка, название права, которое необходимо проверить.
//                        необязательный параметр, значение по умолчанию - "Чтение".  
//  флВыводитьСообщения - Булево, признак вывода сообщения, с текстом о нарушении прав доступа к объекту,
//                        необязательный параметр, значение по умолчанию - Истина.
//
// Возвращаемое значение:
//   Булево - Истина - есть право доступа
//            Ложь   - нет права доступа  
//
Функция ПроверитьПравоДоступа(ОбъектМетаданных, Право = "Чтение", флВыводитьСообщения = Истина) Экспорт
	
	ЕстьПраво = ПравоДоступа(Право, ОбъектМетаданных);
	
	ПолноеИмяобъекта = ОбъектМетаданных.ПолноеИмя();
	ВидОбъекта = Сред(ПолноеИмяобъекта, 1, Найти(ПолноеИмяобъекта, ".")-1);
	
	Если НЕ ЕстьПраво Тогда
		
		Если флВыводитьСообщения Тогда
			#Если Клиент Тогда
				Предупреждение("Нарушение прав доступа! " + ВидОбъекта + ": " + ОбъектМетаданных.Синоним);
			#Иначе
				Сообщить("Нарушение прав доступа! " + ВидОбъекта + ": " + ОбъектМетаданных.Синоним, СтатусСообщения.Важное);
			#КонецЕсли
		КонецЕсли;	
	
	КонецЕсли; 

	Возврат ЕстьПраво;
	
КонецФункции // ПроверитьПравоДоступа()

// Функция проверяет наличие роли "Только просмотр" у текущего пользователя
// используется в случаях, когда необходимо ограничить доступ к 
// какой-либо функциональности
//
Функция ПроверкаУстановленнойРолиТолькоПросмотр(ВыводитьСообщение = Истина) Экспорт
	
	Если РольДоступна("ТолькоПросмотрБазовыеФункции") Тогда
		
		Если ВыводитьСообщение Тогда
			#Если Клиент Тогда
				Предупреждение("Нарушение прав доступа!");
			#Иначе
				Сообщить("Нарушение прав доступа!");
			#КонецЕсли
		КонецЕсли;

		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции // ПроверкаУстановленнойРолиТолькоПросмотр()


///////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного
// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора)
//
// Параметры:
//  ОбъектМетаданных  - Объект матаданных конфигурации, для которого необходимо получить значение свойств реквизитов.
//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
//  Свойства - Строка - свойства реквизитов, перечисленных через запятую, значение которых необходимо получить.
//                      Например: "Имя, Тип, Синоним, Подсказка"
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица значений с описанием требуемых свойств всех реквизитов объекта метаданного
//
Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
	
	МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	
	// возвращаемое значение функции
	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
	
	// добавляем в таблицу поля согласно именам переданных свойств
	Для Каждого ИмяСвойства ИЗ МассивСвойств Цикл
		
		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
		
	КонецЦикла;
	
	// заполняем строку таблицы свойствами реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
		
	КонецЦикла;
	
	// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.СтандартныеРеквизиты Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
		
	КонецЦикла;
	
	Возврат ТаблицаОписанияСвойствОбъекта;
	
КонецФункции
    
// Добавляет колонку в таблицу значений. Заполняет колонку переданным значением
//
// Параметры:
//  Таблица           - ТаблицаЗначений - таблица значений для добавления колонки
//  ЗначениеИтератора - Произвольный - значение, которым будет заполнено новое поле таблицы
//  ИмяПоляИтератора  - Строка - имя добавляемого поля
// 
Процедура ДобавитьИтераторТаблице(Таблица, ЗначениеИтератора, ИмяПоляИтератора) Экспорт
	
	Таблица.Колонки.Добавить(ИмяПоляИтератора);
	
	Таблица.ЗаполнитьЗначения(ЗначениеИтератора, ИмяПоляИтератора);
	
КонецПроцедуры

Функция ПолучитьДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
	
	ИспользоватьОтбор = (Отбор <> Неопределено);
	
	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
	
	КоллекцииОбъектовМетаданныхНоваяСтрока("Константы",               "Константы",                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("Справочники",             "Справочники",               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("Документы",               "Документы",                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("ПланыВидовХарактеристик", "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("ПланыСчетов",             "Планы счетов",              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("ПланыВидовРасчета",       "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("РегистрыСведений",        "Регистры сведений",         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("РегистрыНакопления",      "Регистры накопления",       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("РегистрыБухгалтерии",     "Регистры бухгалтерии",      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("РегистрыРасчета",         "Регистры расчета",          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("БизнесПроцессы",          "Бизнес-процессы",           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
	КоллекцииОбъектовМетаданныхНоваяСтрока("Задачи",                  "Задачи",                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
	
	// возвращаемое значение функции
	ДеревоМетаданных = Новый ДеревоЗначений;
	ДеревоМетаданных.Колонки.Добавить("Имя");
	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
	ДеревоМетаданных.Колонки.Добавить("Синоним");
	ДеревоМетаданных.Колонки.Добавить("Картинка");
	
	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
		
		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
		
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
		
		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
			
			// ============================ {Фильтр}
			Если ИспользоватьОтбор Тогда
				
				ОбъектПрошелФильтр = Истина;
				
				Для Каждого ЭлементОтбора Из Отбор Цикл
					
					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
					
					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
						
						ОбъектПрошелФильтр = Ложь;
						
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбъектПрошелФильтр Тогда
					
					Продолжить;
					
				КонецЕсли;
				
			КонецЕсли;
			// ============================ {Фильтр}
			
			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// удаляем строки без подчиненных элементов
	Если ИспользоватьОтбор Тогда
		
		// используем обратный порядок обхода дерева значений
		КолвоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
			
			ТекущийИндекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
			
			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
			
			Если СтрокаДерева.Строки.Количество() = 0 Тогда
				
				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
				
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат ДеревоМетаданных;
КонецФункции

Процедура КоллекцииОбъектовМетаданныхНоваяСтрока(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
	
	НоваяСтрока = Таб.Добавить();
	НоваяСтрока.Имя               = Имя;
	НоваяСтрока.Синоним           = Синоним;
	НоваяСтрока.Картинка          = Картинка;
	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
	
КонецПроцедуры

Процедура ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(КоллекцияЭлементовДерева, ДеревоЗначений) Экспорт
	
	Для Каждого Строка Из ДеревоЗначений.Строки Цикл
		
		ЭлементДерева = КоллекцияЭлементовДерева.Добавить();
		
		ЗаполнитьЗначенияСвойств(ЭлементДерева, Строка);
		
		Если Строка.Строки.Количество() > 0 Тогда
			
			ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(ЭлементДерева.ПолучитьЭлементы(), Строка);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//  Истина - ссылка физически существует;
//  Ложь   - ссылка физически не существует
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Возвращает полное имя объекта метаданных по переданному значению ссылки
// Например,
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная"
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного значения ссылки
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).ПолноеИмя();
	
КонецФункции

// Возвращает строку реквизитов объекта метаданных с заданным типом
//
// Параметры:
//  Ссылка – ЛюбаяСсылка – ссылка на элемент базы данных, для которого требуется получить результат функции
//  Тип    – Тип – тип значения реквизита
// 
//  Возвращаемое значение:
// Тип: Строка – строка реквизитов объекта метаданных конфигурации, разделенные символом ","
//
Функция ИменаРеквизитовПоТипу(Ссылка, Тип) Экспорт
	
	Результат = "";
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		
		Если Реквизит.Тип.СодержитТип(Тип) Тогда
			
			Результат = Результат + ?(ПустаяСтрока(Результат), "", ", ") + Реквизит.Имя;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция УровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции


// Возвращает описание предмета в виде текстовой строки.
// 
// Параметры:
//  СсылкаНаПредмет  - ЛюбаяСсылка - объект ссылочного типа.
//
// Возвращаемое значение:
//   Строка.
// 
Функция ПредметСтрокой(СсылкаНаПредмет) Экспорт
	
	Результат = "";
	
	//ОбработчикиСобытия = ОбработчикиСлужебногоСобытия(
	//	"СтандартныеПодсистемы.БазоваяФункциональность\ПриОпределенииПредставленияПредмета");
	//
	//Для каждого Обработчик Из ОбработчикиСобытия Цикл
	//	Обработчик.Модуль.ПриОпределенииПредставленияПредмета(СсылкаНаПредмет, Результат);
	//КонецЦикла;
	//
	//ОбщегоНазначенияПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат);
	
	Если ПустаяСтрока(Результат) Тогда
		Если СсылкаНаПредмет = Неопределено Или СсылкаНаПредмет.Пустая() Тогда
			Результат = НСтр("ru = 'не задан'");
		ИначеЕсли Метаданные.Документы.Содержит(СсылкаНаПредмет.Метаданные()) Тогда
			Результат = Строка(СсылкаНаПредмет);
		Иначе
			ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().ПредставлениеОбъекта;
			Если ПустаяСтрока(ПредставлениеОбъекта) Тогда
				ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().Представление();
			КонецЕсли;
			Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"%1 (%2)", Строка(СсылкаНаПредмет), ПредставлениеОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


// Возвращает значение, полученное из XML-строки. 
// Получены из XML-строки могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// СтрокаXML - строка представления значения в сериализованном виде.
//
// Возвращаемое значение:
// Значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

#Если ТолстыйКлиентОбычноеПриложение Тогда

// Работа с отправкой печатной формы
//
Процедура ОтправкаПечатнойФормыПоЭлПочте(Форма, Знач ТабДокумент)Экспорт
	
	Если НЕ (РольДоступна("ПользовательЭлектроннойПочты") ИЛИ РольДоступна("ПолныеПрава")) Тогда
		Сообщить("Недостаточно прав для работы с электронной почтой");
		Возврат;
	КонецЕсли;
	
	ТабДокумент.АвтоМасштаб = Истина;
	
	ПараметрыОтправки = Новый Структура;
	Получатель = Новый Массив;
	Попытка
		ПолучательПисьма = Форма.ОбъектПечати.Контрагент;
		Представление = "";
		Адрес = "";
		ТипКонтактнойИнформации = Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты;
		ОтправкаПечатныхФормПоЭлектроннойПочте.ДозаполнитьПоляКонтактов(ПолучательПисьма, Представление, Адрес, ТипКонтактнойИнформации);

		Получатель.Добавить(Новый Структура("ИсточникКонтактнойИнформации, Адрес, Представление", ПолучательПисьма, Адрес, Представление));
	Исключение
		Получатель.Добавить(Новый Структура("ИсточникКонтактнойИнформации, Адрес, Представление", Неопределено, Неопределено, Неопределено));
	КонецПопытки;
	
	ПараметрыОтправки.Вставить("Получатель", Получатель);
	ПараметрыОтправки.Вставить("Тема", Форма.Заголовок);
	ПараметрыОтправки.Вставить("Текст", Форма.Заголовок);
    ПараметрыОтправки.Вставить("КлючУникальности", ?(ТипЗнч(Форма)=Тип("Форма"),Форма.КлючУникальности,Неопределено));
	ПараметрыОтправки.Вставить("ПолеДокумента", ТабДокумент);
	
	ПараметрыОткрытия = Новый Структура;
	ИмяОткрываемойФормы = "ОбщаяФорма.ВыборФорматаВложений";
	//Если ОтправкаПечатныхФормПоЭлектроннойПочте.ПолучателейБольшеОдного(ПараметрыОтправки.Получатель) Тогда
	//	ПараметрыОткрытия.Вставить("Получатели", ПараметрыОтправки.Получатель);
	//	ИмяОткрываемойФормы = "ОбщаяФорма.ОтправкаПечатнойФормыПоПочте";
	//КонецЕсли;
	
	//НастройкиСохранения = ОткрытьФормуМодально(ИмяОткрываемойФормы, ПараметрыОткрытия);
	//Если НастройкиСохранения <> Неопределено И НастройкиСохранения <> КодВозвратаДиалога.Отмена Тогда
	//	СписокВложений = ОтправкаПечатныхФормПоЭлектроннойПочте.ПоместитьТабличныеДокументыВоВременноеХранилище(НастройкиСохранения, ПараметрыОтправки);
	//	Получатели = ПараметрыОтправки.Получатель;
	//	ОтправкаПечатныхФормПоЭлектроннойПочте.ОткрытьФормуОтправкиПочтовогоСообщения( , Получатели, ПараметрыОтправки.Тема, ПараметрыОтправки.Текст, СписокВложений, Истина);
	//КонецЕсли;

КонецПроцедуры

// Возвращает дополненую панель с кнопкой отправки на почту
// 
// Параметры
//  КП – командная панель.
//  НовоеДействие  – строка.
//
// Возвращаемое значение:
//   Командная панель 
// 
Функция ДобавитьКнопкуОтправкиНаПочтуВПанель(КП, НовоеДействие) Экспорт 
	
	//ТипКнопки = ТипКнопкиКоманднойПанели.Разделитель;
	//НовыйРазделитель = КП.Кнопки.Добавить("РазделительДляПочты", ТипКнопки, , );
	//
	//ТипКнопки = ТипКнопкиКоманднойПанели.Действие;
	//НоваяКнопка = КП.Кнопки.Добавить("Отправить", ТипКнопки, "Отправить...", НовоеДействие);
	//НоваяКнопка.Отображение = ОтображениеКнопкиКоманднойПанели.НадписьКартинка;
	//НоваяКнопка.Картинка = БиблиотекаКартинок.ОтправитьПолучитьПочту;
	
КонецФункции

#КонецЕсли



////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с формами

// Получает картинку для вывода на странице с комментарием в зависимости
// от наличия текста в комментарии.
//
// Параметры
//  Комментарий  - Строка - текст комментария
//
// Возвращаемое значение:
//  Картинка - Картинка, которая должна отображаться на странице с комментарием.
//
Функция ПолучитьКартинкуКомментария(Комментарий) Экспорт
	
	Если НЕ ПустаяСтрока(Комментарий) Тогда
		Картинка = БиблиотекаКартинок.Комментарий;
	Иначе
		Картинка = Новый Картинка;
	КонецЕсли;
	
	Возврат Картинка;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Сохранение, чтение и удаление настроек из хранилищ

// Сохраняет настройку в хранилище общих настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Значение,
		ОписаниеНастроек,
		ИмяПользователя,
		НужноОбновитьПовторноИспользуемыеЗначения
	);
	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя
	);
	
КонецФункции

// Удаляет настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя
	);
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур. 
// Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур,
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, Элемент.Настройка, Элемент.Значение);
	КонецЦикла;
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур и обновляет повторно
//   используемые значения. Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//
Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
	
	ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище общих настроек и обновляет повторно используемые 
//   значения.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(КлючОбъекта, КлючНастроек, Значение) Экспорт
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения
	);
	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя
	);
	
КонецФункции

// Удаляет настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя
	);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения
	);
	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя
	);
	
КонецФункции

// Удаляет настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеНастроекДанныхФорм.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя
	);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек через его менеджер.
// 
// Параметры:
//   МенеджерХранилища (СтандартноеХранилищеНастроекМенеджер) Хранилище, в котором сохраняется настройка
//   КлючОбъекта       (Строка) Ключ объекта настройки. 
//                              Подробнее см. раздел справки "Настройки, автоматически сохраняемые в системном хранилище".
//   КлючНастроек      (Строка) Ключ сохраняемых настроек.
//   Значение          (*)      Содержит настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  (ОписаниеНастроек) Содержит информацию об описании настройки.
//   ИмяПользователя   (Строка) Имя пользователя, настройки которого сохраняются.
//                              Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения (Булево)
// 
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения)
	
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Загружает настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища   (СтандартноеХранилищеНастроекМенеджер) Хранилище, из которого загружается настройка
//   КлючОбъекта         (Строка) Ключ объекта настройки. 
//                                Подробнее см. раздел справки "Настройки, автоматически сохраняемые в системном хранилище".
//   КлючНастроек        (Строка) Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию (*)      Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек    (ОписаниеНастроек) Через данный параметр при загрузке можно получить описание настроек.
//   ИмяПользователя     (Строка) Имя пользователя, настройки которого загружается.
//                                Если не указано, то загружается настройки текущего пользователя.
// 
// Возвращаемое значение: 
//   (*) Настройки, загруженные из хранилища. Неопределено, если настройки не найдены. 
// 
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
	ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
	
	Если (Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено) Тогда
		Результат = ЗначениеПоУмолчанию;
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

// Удаляет настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища (СтандартноеХранилищеНастроекМенеджер) Хранилище, из которого удаляется настройка
//   КлючОбъекта       (Строка)       Ключ объекта настройки. 
//                     (Неопределено) Удаляются настройки для всех объектов.
//   КлючНастроек      (Строка)       Ключ сохраняемых настроек.
//                     (Неопределено) Удаляются настройки со всеми ключами.
//   ИмяПользователя   (Строка)       Имя пользователя, настройки которого загружается.
//                     (Неопределено) Удаляются настройки всех пользователей.
// 
// Возвращаемое значение: 
//   (*) Настройки, загруженные из хранилища. Неопределено, если настройки не найдены. 
// 
Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек, ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с журналом регистрации

// Процедура пакетной записи сообщений в журнал регистрации
// 
// Параметры: СобытияДляЖурналаРегистрации - массив структур, клиентская глобальная переменная 
// Каждая структура - сообщение для журнала регистрации.
// После записи переменная очищается.
Процедура ЗаписатьСобытияВЖурналРегистрации(СобытияДляЖурналаРегистрации) Экспорт
	
	Если ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений") Тогда
		Возврат;
	КонецЕсли;	
	
	Если СобытияДляЖурналаРегистрации.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СообщениеЖурнала Из СобытияДляЖурналаРегистрации Цикл
		ЗначениеСообщения = СообщениеЖурнала.Значение;
		ИмяСобытия = ЗначениеСообщения.ИмяСобытия;
		УровеньСобытия = УровеньСобытияПоПредставлению(ЗначениеСообщения.ПредставлениеУровня);
		ДатаСобытия = ТекущаяДатаСеанса();
		Если ЗначениеСообщения.Свойство("ДатаСобытия") И ЗначениеЗаполнено(ЗначениеСообщения.ДатаСобытия) Тогда
			ДатаСобытия = ЗначениеСообщения.ДатаСобытия;
		КонецЕсли;
		Комментарий = Строка(ДатаСобытия) + " " + ЗначениеСообщения.Комментарий;
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньСобытия,,, Комментарий);
	КонецЦикла;
	СобытияДляЖурналаРегистрации.Очистить();
	
КонецПроцедуры

// Проверяет правильность заполнения Ф.И.О.
//
Функция ФИОНаписаноВерно(Знач СтрокаПараметр, ПроверятьТолькоРусскиеБуквы = Ложь) Экспорт
	
	СтрокаПараметр = СокрЛП(СтрокаПараметр);
	
	СписокДопустимыхЗначений = Новый Соответствие;
	СписокДопустимыхЗначений.Вставить(КодСимвола(" "), " ");
	СписокДопустимыхЗначений.Вставить(КодСимвола("-"), "-");
	СписокДопустимыхЗначений.Вставить(КодСимвола("ё"), "ё");
	СписокДопустимыхЗначений.Вставить(КодСимвола("Ё"), "Ё");
	
	КодA = КодСимвола("A");
	КодZ = КодСимвола("z");
	КодА = КодСимвола("А");
	КодЯ = КодСимвола("я");
	Если  ПроверятьТолькоРусскиеБуквы Тогда
		Для Сч = 1 По СтрДлина(СтрокаПараметр) Цикл
			Код = КодСимвола(СтрокаПараметр, Сч);
			Если ((Код >= КодА) И (Код <= КодЯ)) ИЛИ (СписокДопустимыхЗначений.Получить(Код) <> Неопределено) Тогда
				Продолжить;
			Иначе
				Возврат 0;
			КонецЕсли;
		КонецЦикла;
	Иначе
		Для Сч = 1 По СтрДлина(СтрокаПараметр) Цикл
			Код = КодСимвола(СтрокаПараметр, Сч);
			Если (((Код >= КодA) И (Код <= КодZ)) ИЛИ ((Код >= КодА) И (Код <= КодЯ))) ИЛИ (СписокДопустимыхЗначений.Получить(Код) <> Неопределено) Тогда
				Продолжить;
			Иначе
				Возврат 0;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;	
	Возврат 1;
	
КонецФункции // ФИОНаписаноВерно()

// Функция склоняет переданую фразу
// Параметры:
//  Фраза (обязательный), тип строка
//   Параметр должен содержать фразу. Каждое слово фразы будет просклонено отдельно
//
//  Падеж (обязательный), тип число
//   Падеж, в который необходимо поставить ФИО.
//   1 - Именительный
//   2 - Родительный
//   3 - Дательный
//   4 - Винительный
//   5 - Творительный
//   6 - Предложный
//
Функция Просклонять(Компонента, Знач Фраза = "", Падеж = 1, Пол = Неопределено, Результат) Экспорт
	
	Если Компонента = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Результат = "";
	
	#Если Клиент Тогда
		
	МассивСтрок = РазложитьСтрокуВМассивПодстрок(Фраза, " ");
	
	// Выделим первые 3 слова, так как компонента не умеет склонять фразу большую 3х символов
	НомерНесклоняемогоСимвола = 4;
	Для Номер = 1 По Мин(МассивСтрок.Количество(), 3) Цикл
		Если НЕ ФИОНаписаноВерно(МассивСтрок[Номер-1], Истина) Тогда
			НомерНесклоняемогоСимвола = Номер;
			Прервать;
		КонецЕсли;

		Результат = Результат + ?(Номер > 1, " ", "") + МассивСтрок[Номер-1];
	КонецЦикла;
	
	Если ПустаяСтрока(Результат) Тогда
		Результат = Фраза;
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		Если Пол = Перечисления.ПолФизическихЛиц.Мужской Тогда
			Результат = Компонента.Просклонять(Результат, Падеж, 1) + " ";
			
		ИначеЕсли Пол = Перечисления.ПолФизическихЛиц.Женский Тогда
			Результат = Компонента.Просклонять(Результат, Падеж, 2) + " ";
			
		Иначе
			Результат = Компонента.Просклонять(Результат, Падеж) + " ";
			
		КонецЕсли;
		
	Исключение
		Результат = Фраза;
		Возврат Ложь;
		
	КонецПопытки;
	
	// Остальные символы добавим без склонения
	Для Номер = НомерНесклоняемогоСимвола По МассивСтрок.Количество() Цикл
		Результат = Результат + " " + МассивСтрок[Номер-1];
	КонецЦикла;
	
	Результат = СокрЛП(Результат);
	
	Возврат Истина;
	
	#Иначе
		
	Возврат Ложь;
	
	#КонецЕсли
	
КонецФункции // Просклонять()


// Проверяет соответствие ИИН/БИН требованиям
// Параметры:
//		РНН - строка - проверяемый регистрационный номер налогоплательщика
//		
Функция ИИНБИНСоответствуетТребованиям(Знач ИИН_БИН, ВыводитьСообщение = Истина) Экспорт
	
	ИИН_БИН	     = СокрЛП(ИИН_БИН);
	ДлинаИИН_БИН = СтрДлина(ИИН_БИН);
	
	//Проверка на длину ИИН/БИН
	Если ДлинаИИН_БИН < 12 Тогда
		
		Если ВыводитьСообщение Тогда
			Сообщить("Количество знаков в ИИН/БИН меньше 12!");
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецЕсли;

	// В ИИН/БИН имеются символы, отличные от цифр (0..9)
	ИИН_БИНБезНулей = СтрЗаменить(ИИН_БИН, "0", "1");
	
	Попытка
	    ЧислоИИН_БИН = Число(ИИН_БИНБезНулей);
		
		Если ЧислоИИН_БИН <> Цел(ЧислоИИН_БИН) Тогда // Есть символ "." или ","
			Если ВыводитьСообщение Тогда
				Сообщить("ИИН/БИН содержит символы отличные от цифр!");
			КонецЕсли;
			Возврат Ложь;
		КонецЕсли;		

	Исключение
		
		Если ВыводитьСообщение Тогда
			Сообщить("ИИН/БИН содержит символы отличные от цифр!");
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецПопытки; 

	// Проверка на одинаковость всех цифр
	Если СтрЧислоВхождений(ИИН_БИН, Лев(ИИН_БИН, 1)) = 12 Тогда
		
		Если ВыводитьСообщение Тогда
			Сообщить("Цифра " + Лев(ИИН_БИН, 1) + " повторяется 12 раз!");
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецЕсли;

	// а12=(а1*b1+а2*b2+а3*b3+а4*b4+а5*b5+а6*b6+а7*b7+а8*b8+а9*b9+a10*b10+a11*b11) mod 11
	ПодстрокаИН11 		= Лев(ИИН_БИН, 11);	// копируем первые 11 символов
	КонтрольноеЗначение = Прав(ИИН_БИН, 1);	// контрольная сумма ИИН/БИН
	         
	//разряд ИИН:  1 2 3 4 5 6 7 8 9 10 11
	//вес разряда: 1 2 3 4 5 6 7 8 9 10 11.

	СуммаРазрядов = 1 * Сред(ИИН_БИН, 1, 1) + 2 * Сред(ИИН_БИН, 2, 1) + 3 * Сред(ИИН_БИН, 3, 1) + 4 * Сред(ИИН_БИН, 4, 1) + 5 * Сред(ИИН_БИН, 5, 1) + 6 * Сред(ИИН_БИН, 6, 1)
					+ 7 * Сред(ИИН_БИН, 7, 1)+ 8 * Сред(ИИН_БИН, 8, 1) + 9 * Сред(ИИН_БИН, 9, 1) + 10 * Сред(ИИН_БИН, 10, 1) + 11 * Сред(ИИН_БИН, 11, 1);
					
	ВычисленноеКонтрольноеЗначение = СуммаРазрядов - Цел(СуммаРазрядов / 11) * 11; // mod - остаток от деления Суммы разрядов на 11.
	
	Если ВычисленноеКонтрольноеЗначение = 10 Тогда
		//разряд ИИН:  1 2 3 4 5 6 7 8 9 10 11 
		//вес разряда: 3 4 5 6 7 8 9 10 11 1 2.

		СуммаРазрядов = 3 * Сред(ИИН_БИН, 1, 1) + 4 * Сред(ИИН_БИН, 2, 1) + 5 * Сред(ИИН_БИН, 3, 1) + 6 * Сред(ИИН_БИН, 4, 1) + 7 * Сред(ИИН_БИН, 5, 1) + 8 * Сред(ИИН_БИН, 6, 1)
						+ 9 * Сред(ИИН_БИН, 7, 1) + 10 * Сред(ИИН_БИН, 8, 1) + 11 * Сред(ИИН_БИН, 9, 1) + 1*Сред(ИИН_БИН, 10, 1) + 2 * Сред(ИИН_БИН, 11, 1);
		ВычисленноеКонтрольноеЗначение = СуммаРазрядов - Цел(СуммаРазрядов / 11) * 11;   
		
	КонецЕсли;
	
	Если ВычисленноеКонтрольноеЗначение <> Число(КонтрольноеЗначение) Тогда
		
		Если ВыводитьСообщение Тогда
			Сообщить("Введенный ИИН/БИН не корректен!");
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецЕсли;	
	
	Возврат Истина;
	
КонецФункции // РННСоответствуетТребованиям()
	

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

//Процедура выполняет удаление движений документа по регистрам при отмене проведения
//	Является обработчиком подписки на событие "ОбработкаУдаленияПроведенияДокумента"
//
Процедура ОбработкаУдаленияПроведенияДокумента(Источник, Отказ) Экспорт
	
	УдалитьДвиженияРегистратора(Источник, Отказ);
	
КонецПроцедуры

// Функция формирует фамилию и инициалы работника в заданном падеже 
// по переданным данным о работнике.
//  либо по переданным строкам.
//
// Параметры
//  Работник	- строка (Фамилия + Имя + Отчество, разделенными пробелами) 
//                или ссылка на элемент справочника ФизическиеЛица или Сотрудники.
//  Падеж (необязательный), тип число
//   Падеж, в который необходимо поставить ФИО.
//   1 - Именительный
//   2 - Родительный
//   3 - Дательный
//   4 - Винительный
//   5 - Творительный
//   6 - Предложный
//
//  Пол (необязательный), тип ПеречислениеСсылка.ПолФизическихЛиц
//   Данный параметр предназначен для разрешения возможных неоднозначностей
//   В остальных случаях рекомендуется опускать этот параметр.
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой.
//
Функция ПредставлениеРаботника(Работник, Знач Падеж = 1, Знач Пол = Неопределено) Экспорт

	ТипДанных = ТипЗнч(Работник);
	Если ТипДанных = Тип("Строка") Тогда
		РаботникФИО = Работник;
		РаботникПол = Пол;
	Иначе
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Работник", Работник);
		Если ТипДанных = Тип("СправочникСсылка.СотрудникиОрганизаций") Тогда
			Запрос.Текст = 
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	СотрудникиОрганизаций.Наименование,
			|	СотрудникиОрганизаций.Физлицо.Пол КАК Пол
			|ИЗ
			|	Справочник.СотрудникиОрганизаций КАК СотрудникиОрганизаций
			|ГДЕ
			|	СотрудникиОрганизаций.Ссылка = &Работник";
		Иначе
			Запрос.Текст = 
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	ФизическиеЛица.Наименование,
			|	ФизическиеЛица.Пол
			|ИЗ
			|	Справочник.ФизическиеЛица КАК ФизическиеЛица
			|ГДЕ
			|	ФизическиеЛица.Ссылка = &Работник";
		КонецЕсли;
		
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			РаботникФИО = Выборка.Наименование;
			РаботникПол = Выборка.Пол;
		Иначе
			Возврат ""
		КонецЕсли;
	КонецЕсли;
	
	ФИО = ОбщегоНазначения.ФамилияИнициалыФизЛица(РаботникФИО);
	
	ПозицияПервогоПробела = Найти(ФИО + " "," ");
	Фамилия  = Лев(ФИО,ПозицияПервогоПробела-1);
	Инициалы = Сред(ФИО,ПозицияПервогоПробела+1);
	
	РезультатСклонения = "";
	Если ОбщегоНазначения.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Фамилия, Падеж, РаботникПол, РезультатСклонения) Тогда
		ФИО = РезультатСклонения + " " + Инициалы;	
	КонецЕсли;
	
	Возврат ФИО
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ 

// Получает первичную информацию об ошибке
// Параметры:
//	ИнформацияОбОшибке - информация об ошибке
// Возвращает:
//	Информацию об ошибке, которая является первопричиной возникновения переданной ИнформацияОбОшибке
//  Если ошибка первичная, то возвращается сама ошибка, переданная в качестве параметра
Функция ПолучитьПричинуОшибки(ИнформацияОбОшибке) Экспорт
	
	ПричинаОшибки = ИнформацияОбОшибке.Причина;
	
	Если ПричинаОшибки = НеОпределено Тогда
		Возврат ИнформацияОбОшибке;
	КонецЕсли;
	Пока ПричинаОшибки.Причина <> НеОпределено Цикл
		ПричинаОшибки = ПричинаОшибки.Причина;
	КонецЦикла;
	
	Возврат ПричинаОшибки;
	
КонецФункции

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте вывобит сообщение в обработку комментирования
// на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения  - строка, текст сообщения.
//					  Строка может содержать символы %%, которые при формировании 
//					  сообщения заменяются на представления элементов расшифровки
//  Отказ           - булево, признак отказа (необязательный).
//  Заголовок	    - Заголовок сообщения, для вывода сообщения если работа на сервере или внешнее соединение
//	Расшифровки 	- массив расшифровок для переданного ТекстСообщения
//					  Представляет собой массив структур с полями Представление и Расшифровка
//					  Поле Представление - текст, дополняющий ТекстСообщения
//					  Поле Расшифровка - действие, выполняемое по расшифровке
//
Процедура ВывестиИнформациюОбОшибке(Знач ТекстСообщения, Отказ = Истина, Заголовок = "", ВидСообщения = Неопределено, Расшифровки = Неопределено, РодительскаяСтрока = НеОпределено, РаскрытьСообщение = Истина) Экспорт
	
	Отказ = Истина;
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
	
		Если ВидСообщения = Неопределено Тогда
			ВидСообщения = Перечисления.ВидыСообщений.Ошибка;
		КонецЕсли;
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Обработка.ДобавитьСообщение(ТекстСообщения, ВидСообщения, Расшифровки, РодительскаяСтрока, РаскрытьСообщение);
		
	#ИначеЕсли ВнешнееСоединение Тогда
		
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Сообщить(ТекстСообщения, СтатусСообщения.Важное);
		
	#КонецЕсли
	
КонецПроцедуры // ВывестиИнформациюОбОшибке()

#Область НеИспользуемые

// Формирует список головных организаций предприятия
//
Функция ПолучитьСписокГоловныхОрганизацийДляУчетаЗарплаты() Экспорт       

	УчетнаяПолитикаПоПерсоналуОрганизацииТаблица = ПолныеПрава.СформироватьТаблицуУчетнойПолитикиПоПерсоналу(глЗначениеПеременной("глУчетнаяПолитикаПоПерсоналуОрганизации"));
	
	Запрос = Новый Запрос("ВЫБРАТЬ
	                      |	УчетнаяПолитика.Организация,
	                      |	УчетнаяПолитика.ВедениеУчетаПоГоловнойОрганизации
	                      |ПОМЕСТИТЬ ВТ_УчетнаяПолитикаПоПерсоналуОрганизации
	                      |ИЗ
	                      |	&парамУчетнаяПолитикаПоПерсоналуОрганизации КАК УчетнаяПолитика
	                      |;
	                      |
	                      |////////////////////////////////////////////////////////////////////////////////
	                      |ВЫБРАТЬ РАЗРЕШЕННЫЕ
	                      |	Организации.Ссылка,
	                      |	Организации.Наименование КАК Наименование
	                      |ИЗ
	                      |	Справочник.Организации КАК Организации
	                      |		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_УчетнаяПолитикаПоПерсоналуОрганизации КАК ВТ_УчетнаяПолитикаПоПерсоналуОрганизации
	                      |		ПО Организации.Ссылка = ВТ_УчетнаяПолитикаПоПерсоналуОрганизации.Организация
	                      |ГДЕ
	                      |	ВЫБОР
	                      |			КОГДА ВТ_УчетнаяПолитикаПоПерсоналуОрганизации.ВедениеУчетаПоГоловнойОрганизации
	                      |				ТОГДА Организации.ГоловнаяОрганизация = &ПустаяОрганизация
	                      |						ИЛИ Организации.ГоловнаяОрганизация = Организации.Ссылка
	                      |			ИНАЧЕ ИСТИНА
	                      |		КОНЕЦ
	                      |
	                      |УПОРЯДОЧИТЬ ПО
	                      |	Наименование");

	Запрос.УстановитьПараметр("ПустаяОрганизация", Справочники.Организации.ПустаяСсылка());
	Запрос.УстановитьПараметр("парамУчетнаяПолитикаПоПерсоналуОрганизации", УчетнаяПолитикаПоПерсоналуОрганизацииТаблица);		

	СписокОрганизаций = Новый СписокЗначений;
	Выборка = Запрос.Выполнить().Выбрать(); 

	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;

КонецФункции // ПолучитьСписокГоловныхОрганизаций()

// Формирует список обособленных структурных подразделений организации
// Из списка обособленных подразделений организации исключаются те организации
// которые ведут учет зарплаты самостоятельно и не являются в данном случае ОП
//
Функция ПолучитьСписокОбособленныхПодразделенийОрганизацииДляУчетаЗарплаты(Организация) Экспорт 
	
	УчетнаяПолитикаПоПерсоналуОрганизацииТаблица = ПолныеПрава.СформироватьТаблицуУчетнойПолитикиПоПерсоналу(глЗначениеПеременной("глУчетнаяПолитикаПоПерсоналуОрганизации"));
	
	Запрос = Новый Запрос("ВЫБРАТЬ
	                      |	УчетнаяПолитика.Организация,
	                      |	УчетнаяПолитика.ВедениеУчетаПоГоловнойОрганизации
	                      |ПОМЕСТИТЬ ВТ_УчетнаяПолитикаПоПерсоналуОрганизации
	                      |ИЗ
	                      |	&парамУчетнаяПолитикаПоПерсоналуОрганизации КАК УчетнаяПолитика
	                      |;
	                      |
	                      |////////////////////////////////////////////////////////////////////////////////
	                      |ВЫБРАТЬ РАЗРЕШЕННЫЕ
	                      |	Организации.Ссылка,
	                      |	Организации.Наименование
	                      |ИЗ
	                      |	Справочник.Организации КАК Организации
	                      |		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_УчетнаяПолитикаПоПерсоналуОрганизации КАК ВТ_УчетнаяПолитикаПоПерсоналуОрганизации
	                      |		ПО Организации.Ссылка = ВТ_УчетнаяПолитикаПоПерсоналуОрганизации.Организация
	                      |ГДЕ
	                      |	Организации.ГоловнаяОрганизация = &Организация
	                      |	И ВЫБОР
	                      |			КОГДА Организации.Ссылка <> &Организация   // организация-филиал
	                      |				ТОГДА ВТ_УчетнаяПолитикаПоПерсоналуОрганизации.ВедениеУчетаПоГоловнойОрганизации = ИСТИНА
	                      |			ИНАЧЕ ИСТИНА
	                      |		КОНЕЦ");
						  
	Запрос.УстановитьПараметр("Организация", Организация);
	Запрос.УстановитьПараметр("парамУчетнаяПолитикаПоПерсоналуОрганизации", УчетнаяПолитикаПоПерсоналуОрганизацииТаблица);

	СписокОрганизаций = Новый СписокЗначений;
	Выборка = Запрос.Выполнить().Выбрать(); 

	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;

КонецФункции // ПолучитьСписокОбособленныхПодразделенийОрганизации()

#КонецОбласти


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Производит проверку наличия комплекта обновления и 
// открывает форму для просмотра результатов проверки
Процедура ПроверкаНаличияКомплектаОбновлений() Экспорт
	
	Если РольДоступна("ПолныеПрава") Тогда
        Обозреватель = Обработки.Обозреватель.Создать();
		Форма        = Обозреватель.ПолучитьФорму("ПроверкаНаличияОбновления");

		Обозреватель.Проверить(Форма.ЭлементыФормы);

		Форма.Открыть();
	Иначе
		Сообщить("Недостаточно прав для выполнения данной операции!");
	КонецЕсли;	

КонецПроцедуры

Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ (ТонкийКлиент ИЛИ ВебКлиент) Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = Найти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура ПриПроведенииДокументовСлужебныеОперацииПриЗаписи(Источник, Отказ) Экспорт
	// не используемая процедура
	СтандартнаяОбработка = Истина;
	
КонецПроцедуры

Процедура УстановитьАналитикуНаУправляемыхСчетах(Источник, Отказ, РежимЗаписи) Экспорт
	// не используемая процедура
	СтандартнаяОбработка = Истина;
КонецПроцедуры

// Функция определяет необходимость отображать структурные подразделения
//
// Возвращаемое значение:
//     Булево - истина, если необходимо отображать структурные подразделения
//              ложь, если нет необходимости отображать структурные подразделения
Функция ПолучитьПризнакОтображенияСтруктурныхПодразделенийВЗарплате() Экспорт
	
	ОтображениеСтруктурныхПодразделений = Константы.общ_ПоддержкаРаботыСоСтруктурнымиПодразделениямиВЗарплате.Получить();
	
	Возврат ОтображениеСтруктурныхПодразделений;
	
КонецФункции


// Устарела. Следует использовать РаботаВБезопасномРежиме.ВыполнитьМетодКонфигурации().
Процедура ВыполнитьБезопасно(ИмяЭкспортнойПроцедуры, Параметры = Неопределено, ОбластьДанных = Неопределено) Экспорт
	
	ВыполненаУстановкаРазделенияСеанса = Ложь;
	//Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
	//	Если Не ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
	//		Если ОбластьДанных = Неопределено Тогда
	//			ОбластьДанных = ЗначениеРазделителяСеанса();
	//		Иначе 
	//			Если ОбластьДанных <> ЗначениеРазделителяСеанса() Тогда
	//				ВызватьИсключение(НСтр("ru = 'В данном сеансе недопустимо обращение к данным из другой области данных!'"));
	//			КонецЕсли;
	//		КонецЕсли;
	//	КонецЕсли;
	//	Если ОбластьДанных <> Неопределено
	//		И (НЕ ИспользованиеРазделителяСеанса() ИЛИ ОбластьДанных <> ЗначениеРазделителяСеанса()) Тогда
	//		УстановитьРазделениеСеанса(Истина, ОбластьДанных);
	//		ВыполненаУстановкаРазделенияСеанса = Истина;
	//	КонецЕсли;
	//КонецЕсли;
	
	Попытка
		
		РаботаВБезопасномРежиме.ВыполнитьМетодКонфигурации(ИмяЭкспортнойПроцедуры, Параметры);
		
		//Если ВыполненаУстановкаРазделенияСеанса Тогда
		//	УстановитьРазделениеСеанса(Ложь);
		//КонецЕсли;
		
	Исключение
		
		//Если ВыполненаУстановкаРазделенияСеанса Тогда
		//	УстановитьРазделениеСеанса(Ложь);
		//КонецЕсли;
		
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Устарела. Следует использовать РаботаВБезопасномРежиме.ПроверитьИмяМетодаКонфигурации().
Функция ПроверитьИмяЭкспортнойПроцедуры(Знач ИмяЭкспортнойПроцедуры, ТекстСообщения) Экспорт
	
	Попытка
		РаботаВБезопасномРежиме.ПроверитьИмяМетодаКонфигурации(ИмяЭкспортнойПроцедуры);
		Возврат Истина;
	Исключение
		ТекстСообщения = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечатьСчетфактуры(Документ, глСписокПрефиксовУзлов = Неопределено, ПредставлениеНомераДокумента = Неопределено) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Номер = СокрЛП(Документ.Номер);
	
	Если ПредставлениеНомераДокумента = Неопределено Тогда
		ПредставлениеНомераДокумента = Константы.ПредставлениеНомераДокументов.Получить();
	КонецЕсли;	
	
	Если (ПредставлениеНомераДокумента <> Перечисления.ВидыПредставленийНомеровДокументов.ПустаяСсылка()) Тогда
		 
		Попытка
			ПрефиксОрганизации = СокрЛП(Документ.Организация.Префикс); 
		Исключение
			Попытка
				ПрефиксОрганизации = СокрЛП(Документ.ДокументОснование.Организация.Префикс); 
			Исключение
				ПрефиксОрганизации = "";
			КонецПопытки;
		КонецПопытки;
		СписокПрефиксовУзлов = ?(глСписокПрефиксовУзлов<>Неопределено, глСписокПрефиксовУзлов, Новый Структура);
		ДополнительныйПрефикс = ПолучитьДополнительныйПрефиксНомераДокумента(Документ);
		
		ПолныйПрефиксНайден = Ложь;
		
		//в номере может быть префикс любого узла
		Для Каждого ЭлементСпискаПрефиксовУзлов Из СписокПрефиксовУзлов Цикл
			ПрефиксУзла = СокрЛП(ЭлементСпискаПрефиксовУзлов.Значение);
			//ПолныйПрефикс = ПрефиксУзла + ПрефиксОрганизации + ДополнительныйПрефикс;
			ПолныйПрефикс = ПрефиксУзла;
			ПозицияПолногоПрефикса = Найти(Номер, ПолныйПрефикс);
			Если ПозицияПолногоПрефикса = 1 Тогда
				Номер = Прав(Номер, СтрДлина(Номер) - СтрДлина(ПолныйПрефикс));
				ПолныйПрефиксНайден = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;	
		
		//так же возможно в номере нет префикса узла
		Если Не ПолныйПрефиксНайден Тогда
			ПолныйПрефикс = ПрефиксОрганизации;
			Если Не ПустаяСтрока(ПолныйПрефикс) Тогда 
				ПозицияПолногоПрефикса = Найти(Номер, ПолныйПрефикс);
				Если ПозицияПолногоПрефикса = 1 Тогда
					Номер = Прав(Номер, СтрДлина(Номер) - СтрДлина(ПолныйПрефикс));
					ПолныйПрефиксНайден = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		//возможно в номере есть только префикс организации
		Если Не ПолныйПрефиксНайден Тогда
			ПолныйПрефикс = ПрефиксОрганизации;
			Если Не ПустаяСтрока(ПолныйПрефикс) Тогда 
				ПозицияПолногоПрефикса = Найти(Номер, ПолныйПрефикс);
				Если ПозицияПолногоПрефикса = 1 Тогда
					Номер = Прав(Номер, СтрДлина(Номер) - СтрДлина(ПолныйПрефикс));
					ПолныйПрефиксНайден = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		//
		//Пока Лев(Номер, 1) = "0" Цикл
		//	Номер = Прав(Номер, СтрДлина(Номер) - 1);
		//КонецЦикла;
		
		Если ПредставлениеНомераДокумента = Перечисления.ВидыПредставленийНомеровДокументов.ПрефиксБезНулей Тогда
			Если ПолныйПрефиксНайден Тогда
				Номер = ПолныйПрефикс + Номер;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Номер;
	
КонецФункции // ПолучитьНомерНаПечать()

