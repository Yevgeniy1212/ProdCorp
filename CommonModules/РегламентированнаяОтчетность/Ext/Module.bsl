////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ВЫБОРКИ ДАННЫХ 
                               
//Функция получает имя области из кода декларации
//
Функция ПреобразоватьКодДекларации(КодСтроки) Экспорт;
	
	ИмяСтроки = "s_" + СтрЗаменить(КодСтроки, ".", "_");
	ИмяСтроки = Нрег(СтрЗаменить(ИмяСтроки, " ", ""));
	Пока (Прав(ИмяСтроки,1)="_") Цикл 
		КоличествоСимволовВСтроке = СтрДлина(ИмяСтроки);
		ИмяСтроки = Нрег(Лев(ИмяСтроки,КоличествоСимволовВСтроке-1));
	КонецЦикла;
	Возврат ИмяСтроки;
	
КонецФункции

// Функция возвращает наименование строки из макета классификатора по ее коду
//
// Параметры:
//	ТабличныйМакет - табличный документ, содеджащий данные классификатора
//	Область - область табличного документа, по строкам которой осуществляется поиск
//	КодСтроки - строковый код 
//	НомерКолонкиКода - число - номер колонки, в которой содержатся коды строк
//	НомерКолонкиНаименования - число - номер колонки, в которой содержатся наименование строк
//
Функция ПолучитьНаименованиеСтрокиКлассификатораПоКоду(МакетКлассификатора, Область, Знач КодСтроки, НомерКолонкиКода = 1, НомерКолонкиНаименования = 2) Экспорт

	НаименованиеСтроки = "";
	КодСтроки = ВРег(СокрЛП(КодСтроки));

	Для НомерСтроки = Область.Верх По Область.Низ Цикл
		
		Если КодСтроки = ВРег(СокрЛП(МакетКлассификатора.Область(НомерСтроки, НомерКолонкиКода).Текст)) Тогда
			НаименованиеСтроки = МакетКлассификатора.Область(НомерСтроки, НомерКолонкиНаименования).Текст;
			Прервать;
		КонецЕсли;
	
	КонецЦикла;

	Возврат НаименованиеСтроки;

КонецФункции // ПолучитьНаименованиеСтрокиПоКоду()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА ПОДДЕРЖКИ ВНЕШНИХ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

#Если Клиент Тогда
	
// ОсновнаяФормаОрганизацияНеЗаполненаВывестиТекст
// Функция возвращает текст, который выводится в сообщении во всех общих формах.
// Возвращаемое значение:
//  Строка для вывода в Сообщить
//
Функция ОсновнаяФормаОрганизацияНеЗаполненаВывестиТекст() Экспорт

	Возврат "Не выбрана организация.";

КонецФункции // ОсновнаяФормаОрганизацияНеЗаполненаВывестиТекст

// Функция пытается сравнить объект (внешний регламентированный отчет) в памяти с объектом, 
// находящемся в соответствующем файле в текущем каталоге.
// Если объекты совпадают, функция загружает файл на диске в реквизит ВнешнийОтчетХранилище
// соответствующего элемента справочника РегламентированныеОтчеты.
// Параметры:
//       Объект - объект в памяти, который сравнивается с объектом на диске.
//	Возвращаемое значение:
//		 Булево - Истина, если объект загружен; Ложь в противном случае.
Функция СравнитьИЗалитьВХранилище(Объект)

	ИмяФайлаВнешнегоОтчета = Объект.Метаданные().Имя + ".erf";
	ФайлВнешнегоОтчета = Новый Файл(ИмяФайлаВнешнегоОтчета);
	Если НЕ ФайлВнешнегоОтчета.Существует() Тогда
		Возврат Ложь;
	КонецЕсли;

	Попытка
		ОбъектВнешнийОтчет = ВнешниеОтчеты.Создать(ИмяФайлаВнешнегоОтчета);
	Исключение
		Возврат Ложь;
	Конецпопытки;

	Если ОбъектВнешнийОтчет.Метаданные().Имя <> Объект.Метаданные().Имя ИЛИ
			ОбъектВнешнийОтчет.Метаданные().Синоним <> Объект.Метаданные().Синоним ИЛИ
			ОбъектВнешнийОтчет.Метаданные().Комментарий <> Объект.Метаданные().Комментарий ИЛИ
			ЗначениеВСтрокуВнутр(ОбъектВнешнийОтчет.Метаданные()) <> ЗначениеВСтрокуВнутр(Объект.Метаданные()) Тогда

		Возврат Ложь;

	КонецЕсли;

	Если ОбъектВнешнийОтчет.Метаданные().Формы = Неопределено ИЛИ Объект.Метаданные().Формы = Неопределено 
			ИЛИ ОбъектВнешнийОтчет.Метаданные().Формы.Количество() <> Объект.Метаданные().Формы.Количество() Тогда

		Возврат Ложь;

	КонецЕсли;

	Если ОбъектВнешнийОтчет.Метаданные().Макеты = Неопределено И Объект.Метаданные().Макеты <> Неопределено
		ИЛИ ОбъектВнешнийОтчет.Метаданные().Макеты <> Неопределено И Объект.Метаданные().Макеты = Неопределено
		ИЛИ ОбъектВнешнийОтчет.Метаданные().Макеты.Количество() <> Объект.Метаданные().Макеты.Количество() Тогда

		Возврат Ложь;

	КонецЕсли;

	ВремФайлВнешнегоОтчета1 = ПолучитьИмяВременногоФайла();
	Попытка
		КопироватьФайл(ИмяФайлаВнешнегоОтчета, ВремФайлВнешнегоОтчета1);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Объект.Метаданные().Имя);
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Ложь;
	КонецЕсли;
	Если НайденныйЭлемент.ВнешнийОтчетХранилище.Получить() <> Неопределено Тогда
		ВремФайлВнешнегоОтчета2 = ПолучитьИмяВременногоФайла();
		Попытка
			НайденныйЭлемент.ВнешнийОтчетХранилище.Получить().Записать(ВремФайлВнешнегоОтчета2);
			Сравнение = Новый СравнениеФайлов();
			Сравнение.ПервыйФайл = ВремФайлВнешнегоОтчета1;
			Сравнение.ВторойФайл = ВремФайлВнешнегоОтчета2;
			Сравнение.СпособСравнения = СпособСравненияФайлов.Двоичное;
			Если Сравнение.Сравнить() Тогда
				Возврат Ложь;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;
	Если Вопрос("Отчет, который хранится в информационной базе, отличается от выбранного." + Символы.ПС + "Загрузить выбранный отчет в информационную базу?",
				РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Нет Тогда

		Возврат Ложь;

	КонецЕсли;
	Попытка
		ОбъектНайденныйЭлемент = НайденныйЭлемент.ПолучитьОбъект();
		ОбъектНайденныйЭлемент.ВнешнийОтчетХранилище = Новый ХранилищеЗначения(Новый ДвоичныеДанные(ВремФайлВнешнегоОтчета1), Новый СжатиеДанных(9));
		ОбъектНайденныйЭлемент.ВнешнийОтчетИспользовать = Истина;
		ОбъектНайденныйЭлемент.Записать();
	Исключение
		Предупреждение("Не удалось загрузить выбранный отчет в информационную базу!");
		Возврат Ложь;
	КонецПопытки;
	Предупреждение("Внешний отчет успешно загружен в информационную базу." + 
		?(ОтчетКэшировался(ОбъектНайденныйЭлемент), Символы.ПС + "ИЗМЕНЕНИЯ ВСТУПЯТ В СИЛУ ТОЛЬКО ПОСЛЕ ПОВТОРНОГО ЗАПУСКА ПРОГРАММЫ!", ""));

	ТекОтчет = РеглОтчеты(Объект.Метаданные().Имя);
	ТекФорма = ФормаРеглОтчета(Объект.Метаданные().Имя);
	ТекФорма.РежимВыбора = Ложь;
	ТекФорма.Открыть();
	Возврат Истина;

КонецФункции

// Сравнивает "версию" данных, хранящихся в экземпляре документа РегламентированныйОтчет с 
// "версией" отчета, с помощью которого эти данные пытаются открыть.
// Параметры:
// 		ВерсияФормы - "версия" данных.
//		мВерсияФормы = "версия" отчета.
// Возвращаемое значение:
//		Булево - Истина, если отчет с версией мВерсияФормы способен работать с данными версии ВерсияФормы.
//				 Ложь, если отчет с версией мВерсияФормы НЕ способен работать с данными версии ВерсияФормы.
Функция ПродолжитьПриНесоответствииВерсийФорм(Знач ВерсияФормы, Знач мВерсияФормы) Экспорт
	
	ПервыйСлеш = Найти(ВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(ВерсияФормы, ПервыйСлеш - 1) + " " + Сред(ВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодВерсияФормы = Сред(ВерсияФормы, ВторойСлеш + 1);
	МесяцВерсияФормы = Сред(ВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньВерсияФормы = Сред(ВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодВерсияФормы) = 2 Тогда
		ГодВерсияФормы = "20" + ГодВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцВерсияФормы) = 1 Тогда
		МесяцВерсияФормы = "0" + МесяцВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньВерсияФормы) = 1 Тогда
		ДеньВерсияФормы = "0" + ДеньВерсияФормы;
	КонецЕсли;
	ДатаВерсияФормы = Дата(ГодВерсияФормы + МесяцВерсияФормы + ДеньВерсияФормы);
	
	ПервыйСлеш = Найти(мВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(мВерсияФормы, ПервыйСлеш - 1) + " " + Сред(мВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодмВерсияФормы = Сред(мВерсияФормы, ВторойСлеш + 1);
	МесяцмВерсияФормы = Сред(мВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньмВерсияФормы = Сред(мВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодмВерсияФормы) = 2 Тогда
		ГодмВерсияФормы = "20" + ГодмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцмВерсияФормы) = 1 Тогда
		МесяцмВерсияФормы = "0" + МесяцмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньмВерсияФормы) = 1 Тогда
		ДеньмВерсияФормы = "0" + ДеньмВерсияФормы;
	КонецЕсли;
	ДатамВерсияФормы = Дата(ГодмВерсияФормы + МесяцмВерсияФормы + ДеньмВерсияФормы);
	
	Если ДатамВерсияФормы < ДатаВерсияФормы Тогда
		Предупреждение("Сохраненные данные не могут быть открыты текущей версией отчета!" + Символы.ПС + 
						"Версия отчета - от " + Формат(ДатамВерсияФормы, "ДЛФ=DD; ДП='Пустая дата'") + Символы.ПС + 
						"Версия данных - от " + Формат(ДатаВерсияФормы, "ДЛФ=DD; ДП='Пустая дата'"));
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// Возвращает двоичные данные с файлом - внешней обработкой с учетом кэша (реквизит ВнешнийОтчетХранилище), 
// для переданного в качестве параметра элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
//		Содержимое реквизита ВнешнийОтчетХранилище элемента справочника с учетом кэша.
Функция ОбъектОтчетСУчетомКэша(РеглОтч)
	
	Перем ОтчетВКэше;
	
	Попытка
		Кэш = ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить();
	Исключение
		Кэш = Новый Структура;
	КонецПопытки;
	
	Если Кэш.Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше) Тогда
		Возврат ОтчетВКэше.Отчет;
	Иначе
		Попытка
			ОтчетВКэш = РеглОтч.ВнешнийОтчетХранилище.Получить();
			Кэш.Вставить(РеглОтч.ИсточникОтчета, Новый Структура("Отчет, Признак", ОтчетВКэш, РеглОтч.ВнешнийОтчетИспользовать));
			ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(Кэш);
			Возврат ОтчетВКэш;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	
КонецФункции // ОбъектОтчетСУчетомКэша()

// Определяет кэшировалась ли информация для заданного элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
// 		Булево - Истина - информация кэшировалась,
// 				 Ложь - в противном случае.
Функция ОтчетКэшировался(РеглОтч) Экспорт
	
	Перем ОтчетВКэше;
	
	Попытка
		Возврат ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить().Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции // ОтчетКэшировался()

// Возвращает признак использования внешнего отчета с учетом кэша (реквизит ВнешнийОтчетИспользовать), 
// для переданного в качестве параметра элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
//		Признак использования внешнего отчета для заданного элемента справочника с учетом кэша.
Функция ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(РеглОтч)
	
	Перем ОтчетВКэше;
	
	Попытка
		Кэш = ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить();
	Исключение
		Кэш = Новый Структура;
	КонецПопытки;
	
	Если Кэш.Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше) Тогда
		Возврат ОтчетВКэше.Признак;
	Иначе
		Попытка
			ВнешнийОтчетИспользовать = РеглОтч.ВнешнийОтчетИспользовать;
			Кэш.Вставить(РеглОтч.ИсточникОтчета, Новый Структура("Отчет, Признак", РеглОтч.ВнешнийОтчетХранилище.Получить(), ВнешнийОтчетИспользовать));
			ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(Кэш);
			Возврат ВнешнийОтчетИспользовать;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	
КонецФункции // ПризнакИспользованияВнешнегоОтчетаСУчетомКэша()

// Определяет, с учетом кэша, является ли отчет, заданный строкой-идентификатором Наим, внешним.
// Параметры:
//		Наим - строка-идентификатор отчета.
// ВозвращаемоеЗначение:
//		Булево - Истина, если для заданной строки-идентификатора используется внешний отчет.
//				 Ложь - в противном случае.
//				 Неопределено - информация по отчету, заданному строкой-идентификатором 
//  			 отсутствует в справочнике РегламентированныеОтчеты.
Функция ЭтоВнешнийОтчет(Наим) Экспорт
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина 
	 ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // внутренний отчет
		Возврат Ложь;
	Иначе // внешний отчет
		Возврат Истина;
	КонецЕсли;
	
КонецФункции // ЭтоВнешнийОтчет()

// Показывает или скрывает (в зависимости от вида отчета) элемент формы, сигнализирующий пользователю
// о том, что текущая форма принадлежит внешнему отчету.
// Параметры:
//		Форма - объект Форма.
Процедура ДобавитьНадписьВнешнийОтчет(Форма) Экспорт
	
	ИндикаторВнешнегоОтчета = Форма.ЭлементыФормы.Найти("_ИндикаторВнешнегоОтчета");
	Если ИндикаторВнешнегоОтчета = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Ключ = "Внешний отчет объект";
	ЭтоВнешнийОтчет = (Лев(Строка(ТипЗнч(Форма.ЭтотОбъект)), СтрДлина(Ключ)) = Ключ);
	ИндикаторВнешнегоОтчета.Видимость = ЭтоВнешнийОтчет;
	
КонецПроцедуры // ДобавитьНадписьВнешнийОтчет()

// Создает и возвращает ссылку на объект - регламентированный отчет, соответствующий переданному 
// в качестве параметра наименованию. При создании объекта учитывается информация в кэше.
// Параметры:
//		Наим - строка-идентификатор регламентированного отчета.
//		СоздаватьИНеЗапоминать - признак того, что созданный объект не оставить след в кэше.
// Возвращаемое значение:
//		Отчет или ВнешняяОбработка - созданный объект. В случае неудачи возвращается Неопределено.
Функция РеглОтчеты(Наим, СоздаватьИНеЗапоминать = Ложь) Экспорт
	
	Перем ВременныйФайл;
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // используется внутренний отчет
		Если Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
			Возврат Отчеты[Наим];
		Иначе
			Сообщить("Не найден отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
			Возврат Неопределено;
		КонецЕсли; 
	Иначе // используется внешний отчет
		
		Попытка
			СтруктураРегламентированныхОтчетов = ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов.Получить();
		Исключение
			СтруктураРегламентированныхОтчетов = Новый Структура;
		КонецПопытки;
		
		Если НЕ СтруктураРегламентированныхОтчетов.Свойство(Наим, ВременныйФайл) 
		 ИЛИ ВременныйФайл = Неопределено Тогда
			
			Попытка
				ВременныйФайл = ПолучитьИмяВременногоФайла();
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				ВнешнийОтчет = ВнешниеОтчеты.Создать(ВременныйФайл);
				
				Попытка
					ВнешнийОтчет.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
				Исключение
					
				КонецПопытки;
				
				Если НЕ СоздаватьИНеЗапоминать Тогда
					СтруктураРегламентированныхОтчетов.Вставить(Наим, ВременныйФайл);
					ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(СтруктураРегламентированныхОтчетов);
				КонецЕсли;
				
				Возврат ВнешнийОтчет;
				
			Исключение
				Сообщить("Не удалось запустить внешний отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
				Возврат Неопределено;
			Конецпопытки;
			
		Иначе
			
			Попытка
				
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				ВнешнийОтчет = ВнешниеОтчеты.Создать(ВременныйФайл);
				
				Попытка
					ВнешнийОтчет.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
				Исключение
					
				КонецПопытки;
				
				Возврат ВнешнийОтчет;
				
			Исключение
				Сообщить("Не удалось запустить внешний отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
				Возврат Неопределено;
			Конецпопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции // РеглОтчеты()

// Создает и возвращает ссылку на форму регламентированного отчета, соответствующего переданному 
// в качестве параметра наименованию. При получении формы учитывается информация в кэше.
// Параметры:
//		Наим - строка-идентификатор регламентированного отчета.
//		Выбраннаяформа - строка - имя формы.
//		Владелец - владелец формы. Форма или элемент управления.
//		КлючУникальности - ключ, значение которого будет использовано для поиска уже открытых форм.
// Возвращаемое значение:
//		Форма - созданный объект. В случае неудачи возвращается Неопределено.
Функция ФормаРеглОтчета(Наим, ВыбраннаяФорма = Неопределено, Владелец = Неопределено, 
						КлючУникальности = Неопределено) Экспорт
	
	Перем ВременныйФайл;
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // используется внутренний отчет
		Если Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
			Возврат Отчеты[Наим].ПолучитьФорму(ВыбраннаяФорма, Владелец, КлючУникальности);
		Иначе
			// отчет с таким именем не найден
			Сообщить("Не найден отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
			Возврат Неопределено;
		КонецЕсли; 
	Иначе // используется внешний отчет
		
		Попытка
			СтруктураРегламентированныхОтчетов = ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов.Получить();
		Исключение
			СтруктураРегламентированныхОтчетов = Новый Структура;
		КонецПопытки;
		
		Если НЕ СтруктураРегламентированныхОтчетов.Свойство(Наим, ВременныйФайл) ИЛИ ВременныйФайл = Неопределено Тогда
			Возврат Неопределено;
		Иначе
			
			Попытка
				
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				ВнешнийОтчет = ВнешниеОтчеты.ПолучитьФорму(ВременныйФайл, ВыбраннаяФорма, Владелец, КлючУникальности);
				
				Попытка
					ВнешнийОтчет.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
				Исключение
					
				КонецПопытки;
				
				ДобавитьНадписьВнешнийОтчет(ВнешнийОтчет);
				Возврат ВнешнийОтчет;
				
			Исключение
				Возврат Неопределено;
			Конецпопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции // ФормаРеглОтчета()

// Создает и возвращает ссылку на форму регламентированного отчета, соответствующего переданному 
// в качестве параметра наименованию. При получении формы учитывается информация в кэше.
// Параметры:
//		НаименованиеОтчета - строка-идентификатор регламентированного отчета.
//		НаименованиеМакета - строка - имя макета.
// Возвращаемое значение:
//		Форма - созданный объект. В случае неудачи возвращается Неопределено.
Функция ПолучитьМакетРеглОтчета(НаименованиеОтчета, НаименованиеМакета) Экспорт
	
	Перем ВременныйФайл;
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", НаименованиеОтчета);
	
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // используется внутренний отчет
		Если Метаданные.Отчеты.Найти(НаименованиеОтчета) <> Неопределено Тогда
			Возврат Отчеты[НаименованиеОтчета].ПолучитьМакет(НаименованиеМакета);
		Иначе
			// отчет с таким именем не найден		
			Возврат Неопределено;
		КонецЕсли; 
	Иначе // используется внешний отчет
		
		Попытка
			СтруктураРегламентированныхОтчетов = ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов.Получить();
		Исключение
			СтруктураРегламентированныхОтчетов = Новый Структура;
		КонецПопытки;
		
		Если НЕ СтруктураРегламентированныхОтчетов.Свойство(НаименованиеОтчета, ВременныйФайл) ИЛИ ВременныйФайл = Неопределено Тогда
			Возврат Неопределено;
		Иначе
			
			Попытка
				
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				
				ВнешнийОтчет = ВнешниеОтчеты.Создать(ВременныйФайл);

				Возврат ВнешнийОтчет.ПолучитьМакет(НаименованиеМакета);			
				
			Исключение
				Возврат Неопределено;
			Конецпопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции // ФормаРеглОтчета()


// Выводит листы в общую форму ПечатьРегламентированныхОтчетов.
// Параметры:
// ТаблицаСтраницНаПечать - таблица значений, содержит листы которые необходиом распечатать
// Форма - объект типа Форма, из которого была вызвана печать.
// ВидПечати - строка, задающая действие, которое следует произвести с печатными формами: 
// непосредственная печать или предварительный просмотр.
//
Процедура ПечатьРегламентированногоОтчета(ТаблицаСтраницНаПечать,  Форма, ВидПечати) Экспорт
	
	ПредПросмотр = ПолучитьОбщуюФорму("ПечатьРегламентированныхОтчетов", , Форма);
	Если ПредПросмотр.Открыта() Тогда
		ПредПросмотр.Закрыть();
		ПредПросмотр = ПолучитьОбщуюФорму("ПечатьРегламентированныхОтчетов", , Форма);
	КонецЕсли;
	
	Для Каждого Эл Из ТаблицаСтраницНаПечать Цикл
		НовСтр = ПредПросмотр.СписокПечатаемыхЛистов.Добавить();
		НовСтр.Наименование = Эл.ИмяЛиста;
		НовСтр.ТабличныйДокумент = Эл.ПолеТабличногоДокумента;
		НовСтр.НаименованиеДляЗаписи = Эл.ИмяЛистаДляЗаписи;
	КонецЦикла;
	
	ПредПросмотр.ВидПечати = ВидПечати;
	ПредПросмотр.Открыть();

КонецПроцедуры

// Пытается заблокировать документ. В случае неудачной попытки выдает предупреждение.
// Параметры:
//		мСохраненныйДок - объект ДокументОбъект, блокировку которого следует выполнить.
// Возвращаемое значение:
// 		Булево - Истина - объект удалось заблокировать,
// 				 Ложь - объект заблокировать не удалось.
Функция ЗаблокироватьДокумент(мСохраненныйДок)
	
	Попытка
		мСохраненныйДок.Заблокировать();
		Возврат Истина;
	Исключение
		Предупреждение("Не удается заблокировать документ!" + Символы.ПС + "Возможно, документ уже открыт другим пользователем!");
		Возврат Ложь;
	Конецпопытки;
			
КонецФункции

// Формирует пользовательское представление документа вида РегламентированныйОтчет
Функция ПредставлениеДокументаРеглОтч(Док) Экспорт
	
	Представление = "" + Док.НаименованиеОтчета + " за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	Возврат Представление;
	
КонецФункции

//Предлагает пользователю указать каталог для выгрузки декларации в электронном виде
Функция ПолучитьПутьВыгрузки(ПутьДляВыгрузки = Неопределено) Экспорт

	ФормаПараметровСохранения = роПолучитьОбщуюФорму("НастройкаПараметровВыгрузкиРегламентированногоОтчета");
	ФормаПараметровСохранения.ПутьДляВыгрузки = ПутьДляВыгрузки;

	РезВыбора = ФормаПараметровСохранения.ОткрытьМодально();
	Если РезВыбора = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	Если НЕ РезВыбора Тогда
		Возврат Ложь;
	Иначе
		Возврат ФормаПараметровСохранения.ПутьДляВыгрузки;
	КонецЕсли;

КонецФункции

// Пытается выгрузить регламентированные отчеты.
//
// Параметры:
//	ДокументСсылка.РегламентированныйОтчет - отчет, коотрый требуется выгрузить.
// Возвращаемое значение:
//	Булево - Истина, если отчет удалось выгрузить; Ложь - в противном случае.
//
Функция ВыгрузитьОтчеты(Доки) Экспорт
	
	Попытка
		Если ТипЗнч(Доки) <> Тип("СписокЗначений") ИЛИ Доки.Количество() = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
		// выберем каталог для выгрузки отчетов
		ПутьДляВыгрузки = ПолучитьПутьВыгрузки();
		Если ПутьДляВыгрузки = Ложь Тогда
			Возврат Ложь;
		КонецЕсли;
		НеВыгружаемыеОтчеты = Новый СписокЗначений;
		ВыгруженныеОтчеты = Новый СписокЗначений;
		Для Каждого Док Из Доки Цикл
			Отчет = ИнициализацияТекущегоОтчета(Док.Значение);
			Попытка 
				ИмяФайлаВыгрузки = Отчет.ИмяФайлаВыгрузки;
				ИмяФайлаВыгрузки = ПутьДляВыгрузки + Док.Значение.Номер + "_" + ИмяФайлаВыгрузки;
				Если Отчет.мСписокФормБезИерархии <> Неопределено И ТипЗнч(Отчет.мСписокФормБезИерархии) = Тип("ДеревоЗначений") Тогда
					// выгружаем данные отчета					
					
					мВыбраннаяФорма = Отчет.мВыбраннаяФорма;
					Если Найти(мВыбраннаяФорма, "Форма300") Тогда
						Отчет.ВыгрузитьОтчетВXMLДляСОНО300(ИмяФайлаВыгрузки, Отчет);
					ИначеЕсли Найти(мВыбраннаяФорма, "Форма100") Тогда
						Отчет.ВыгрузитьОтчетВXMLДляСОНО100(ИмяФайлаВыгрузки, Отчет);
					Иначе
						ВыгрузитьОтчетВXMLДляСОНО(ИмяФайлаВыгрузки, Отчет);
					КонецЕсли;	
					
					ВыгруженныеОтчеты.Добавить(ИмяФайлаВыгрузки,ПредставлениеДокументаРеглОтч(Док.Значение));
				Иначе
					НеВыгружаемыеОтчеты.Добавить(Док.Значение,"Не показывать");
					Продолжить;
				КонецЕсли;
			Исключение                            				
				НеВыгружаемыеОтчеты.Добавить(Док.Значение);
				Продолжить;
			КонецПопытки;			
		КонецЦикла;
		
		// сообщаем для каких отчетов выгрузка не предусмотрена
		Если НеВыгружаемыеОтчеты.Количество() <> 0 Тогда
			Сообщить("Для следующих отчетов выгрузка не предусмотрена:", СтатусСообщения.Важное);
			Для Каждого Стр Из НеВыгружаемыеОтчеты Цикл
				Если Не Стр.Представление = "Не показывать" Тогда
					Сообщить(" - " + ПредставлениеДокументаРеглОтч(Стр.Значение));
				Иначе
					Сообщить("Выгрузка для отчета - """ + ПредставлениеДокументаРеглОтч(Стр.Значение) + """ невозможна," + Символы.ПС
					         + "     т.к. отчет был сохранен в более ранних версиях программы.");
					// т.к. отчет был сохранен в более ранних версиях программы
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		// сообщим для каких отчетов произведена выгрузка
		Если ВыгруженныеОтчеты.Количество() <> 0 Тогда
			Для Каждого Стр Из ВыгруженныеОтчеты Цикл
				Сообщить("Выгружен отчет: """ + Стр.Представление + """" + ". Путь отчета: """ 
					          + Стр.Значение + """.",СтатусСообщения.Информация);				
			КонецЦикла;
		КонецЕсли;
		
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Создает соответствующий экземпляру документа вида РегламентированныйОтчет объект Отчет
// и инициализирует основные переменные объекта.
//
// Параметры:
//	Док - ДокументСсылка.РегламентированныйОтчет, который требуется "открыть".
//
// Возвращаемое значение:
//	Форма, если удалось создать соответствующий отчет или Неопределено в противном случае.
//
Функция ИнициализацияТекущегоОтчета(Док, Форма = Неопределено) 

	Отчет = РеглОтчеты(Док.ИсточникОтчета).ПолучитьФорму(, , Новый УникальныйИдентификатор);
	Отчет.мСохраненныйДок = Док.ПолучитьОбъект();
	
 	мСписокСохранения        = Отчет.мСохраненныйДок.ДанныеОтчета.Получить();
	ПоказателиФормы = Неопределено;
	Если мСписокСохранения.Свойство("ПоказателиОтчета", ПоказателиФормы) Тогда
		// в некоторых отчетах нет переменной мСписокФормБезИерархии
		Попытка
			Отчет.мСписокФормБезИерархии = ПоказателиФормы;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	// определяем границы периода построения отчета
	Отчет.мДатаНачалаПериодаОтчета = НачалоДня(Отчет.мСохраненныйДок.ДатаНачала);
	Отчет.мДатаКонцаПериодаОтчета  = КонецДня(Отчет.мСохраненныйДок.ДатаОкончания);
			
	// в некоторых отчетах (формы баланса, например) переменная мПериодичность не определена
	Попытка
		Отчет.мПериодичность = Отчет.мСохраненныйДок.Периодичность;
	Исключение
	КонецПопытки;

	ВыбраннаяФорма = Док.ВыбраннаяФорма;
			
	Если Отчет.ЭтотОбъект.Метаданные().Формы.Найти(СокрП(ВыбраннаяФорма)) <> Неопределено Тогда
		ВыбФормаОтчета = Отчет.ПолучитьФорму(СокрП(ВыбраннаяФорма), Форма, Новый УникальныйИдентификатор);
	Иначе
		// Если не удалось найти форму с таким названием (могла быть переименована),
		// то по умолчанию выдаем текущую (действующую) форму
		ВыбраннаяФорма = Отчет.мТаблицаФормОтчета[0].ФормаОтчета;
		ВыбФормаОтчета = Отчет.ПолучитьФорму(ВыбраннаяФорма, Форма, Новый УникальныйИдентификатор);
	КонецЕсли;
			
	Отчет.мВыбраннаяФорма = ВыбраннаяФорма;
	Возврат ВыбФормаОтчета;
	
КонецФункции

// Проверяет был ли сохранен отчет в более ранних версиях программы
//
Функция ОтчетСохраненВБолееРаннихВерсияхПрограммы(мСписокСохранения) Экспорт
	
	Перем ДанныеОтчета;
	
	Если мСписокСохранения.Свойство("ПоказателиОтчета") Тогда
		мСписокСохранения.Свойство("ПоказателиОтчета",ДанныеОтчета);
		Если ТипЗнч(ДанныеОтчета) <> Тип("ДеревоЗначений") Тогда
			Предупреждение("Данный отчет не может быть открыт, так как сохранен в более ранних версиях программы");
			Возврат Истина;
		КонецЕсли;				
	Иначе
		Предупреждение("Данный отчет не может быть открыт, так как сохранен в более ранних версиях программы");
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ОБЩИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// ПолучитьСтруктуруТаблицыРО
// Функция получает таблицу значений со структурой ТаблицаИсточник.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, на основе которой нужно сделать новую таблицу
//
// Возвращаемое значение:
//  Пустая таблица значений, со структурой из таблицы источника.
//
Функция ПолучитьСтруктуруТаблицыРО(ТаблицаИсточник) Экспорт

	Результат = Новый ТаблицаЗначений;
	Для каждого Стр Из ТаблицаИсточник.Колонки Цикл
		Результат.Колонки.Добавить(Стр.Имя, Стр.ТипЗначения);
	КонецЦикла;
	Возврат Результат;

КонецФункции // ПолучитьСтруктуруТаблицыРО

// ПолучитьСтруктуруДереваРО
// Функция получает дерево значений со структурой ТаблицаИсточник.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, на основе которой нужно сделать новую таблицу
//
// Возвращаемое значение:
//  Пустая таблица значений, со структурой из таблицы источника.
//
Функция ПолучитьСтруктуруДереваРО(ТаблицаИсточник) Экспорт

	Результат = Новый ДеревоЗначений;
	Для каждого Стр Из ТаблицаИсточник.Колонки Цикл
		Результат.Колонки.Добавить(Стр.Имя, Стр.ТипЗначения);
	КонецЦикла;
	Возврат Результат;

КонецФункции // ПолучитьСтруктуруТаблицыРО

// ПолучитьКварталРО
// Получает номер квартала
//
// Параметры:
// ЗаданнаяДата - дата или номер месяца.
//
// Возврат - номер квартала
//
Функция ПолучитьКварталРО(ЗаданнаяДата) Экспорт
	Если ТипЗнч(ЗаданнаяДата) = Тип("Дата") Тогда
		Возврат Месяц(КонецКвартала(ЗаданнаяДата)) / 3;
	ИначеЕсли ТипЗнч(ЗаданнаяДата) = Тип("Число") Тогда
		Возврат Цел((ЗаданнаяДата - 1) / 3) + 1;
	КонецЕсли;
КонецФункции // ПолучитьКварталРО

// Функция возвращает общую форму регламентированной отчетности.
//
// Параметры:
//	ИмяФормы - строка с именем запрашиваемой формы.
//	Владелец - форма-владелец открываемой формы.
//	КлючУникальности - ключ для поиска уже открытых форм.
//
// Возвращаемое значение:
//	Форма - запрошенная общая форма регламентированной отчетности 
//			или Неопределено в случае отсутствия общей формы с указанным именем.
//
Функция роПолучитьОбщуюФорму(ИмяФормы, Владелец = Неопределено, КлючУникальности = Неопределено) Экспорт
	
	Если Метаданные.Обработки.ОбщиеОбъектыРегламентированнойОтчетности.Формы.Найти(ИмяФормы) <> Неопределено Тогда
		Возврат Обработки.ОбщиеОбъектыРегламентированнойОтчетности.ПолучитьФорму(ИмяФормы, Владелец, КлючУникальности);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
		
КонецФункции

Функция СвойствоОпределено(Объект, ИмяСвойства) Экспорт
	
	ГУИД = Новый УникальныйИдентификатор;
	ВремСтрукт = Новый Структура(ИмяСвойства, ГУИД);
	ЗаполнитьЗначенияСвойств(ВремСтрукт, Объект);
	Возврат (ВремСтрукт[ИмяСвойства] <> ГУИД);
	
КонецФункции


// ФУНКЦИИ И ПРОЦЕДУРЫ ДЛЯ КАЛЕНДАРЯ

// Возвращает количество документов РегламентированныйОтчет в ИБ с учетом установленных критериев отбора.
//
// Параметры:
//	Нет.
//
// Вовращаемое значение:
//	Число - количество документов в ИБ с учетом установленных пользователей на форме параметров отбора.
//	
Функция ДокументыСУчетомКритериевОтбораКалендарь(ИсточникОтчета, ДатаНачалаПериодаОтчета, ДатаКонцаПериодаОтчета, ОрганизацияОтбор, Периодичность) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИсточникОтчета", ИсточникОтчета);
	Запрос.УстановитьПараметр("Организация", ОрганизацияОтбор);
	ДатаОконч = ?(НЕ ЗначениеЗаполнено(ДатаКонцаПериодаОтчета), '20291231', ДатаКонцаПериодаОтчета);
	Запрос.УстановитьПараметр("ДатаОкончания", НачалоДня(ДатаОконч));
	Запрос.УстановитьПараметр("ДатаОкончанияКон", КонецДня(ДатаОконч));
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	РегламентированныйОтчет.Ссылка
	               |ИЗ
	               |	Документ.РегламентированныйОтчет КАК РегламентированныйОтчет
	               |ГДЕ
	               |	РегламентированныйОтчет.ИсточникОтчета = &ИсточникОтчета
			   	   |	И РегламентированныйОтчет.Организация В ИЕРАРХИИ (&Организация)";
	Запрос.Текст = Запрос.Текст + "
				   |	И (РегламентированныйОтчет.ДатаОкончания МЕЖДУ &ДатаОкончания И &ДатаОкончанияКон)";
	Если Периодичность = "Квартальная" Тогда
		Запрос.Текст = Запрос.Текст + "
					   |	И (РегламентированныйОтчет.Периодичность = ЗНАЧЕНИЕ(Перечисление.Периодичность.Квартал))";
	КонецЕсли;
	Если Периодичность = "Месячная" Тогда
		Запрос.Текст = Запрос.Текст + "
					   |	И (РегламентированныйОтчет.Периодичность = ЗНАЧЕНИЕ(Перечисление.Периодичность.Месяц))";
	КонецЕсли;
			   
	ТаблРез = Запрос.Выполнить().Выгрузить();
	КолТаблРез = ТаблРез.Количество();
	Если КолТаблРез = 0 Тогда
		Возврат 0;
	Иначе
		Возврат КолТаблРез;
	КонецЕсли;
	
КонецФункции // ДокументыСУчетомКритериевОтбораКалендарь

// ОткрытьРегОтчет
//
Процедура ОткрытьРегОтчетКалендарь(ИсточникОтчета, ДатаНач, ДатаКон, Периодичность, ОрганизацияОтбор) Экспорт
	ПравоДоступаКОтчету = ПравоДоступаКРегламентированномуОтчету(ИсточникОтчета);
	Если ПравоДоступаКОтчету = Ложь Тогда
		Предупреждение("Недостаточно прав!");
		Возврат;
	ИначеЕсли ПравоДоступаКОтчету = Неопределено Тогда
		Предупреждение("Отчет не найден!");
		Возврат;
	КонецЕсли;

	Если НЕ ЭтоВнешнийОтчет(ИсточникОтчета) И Метаданные.Документы.Найти(ИсточникОтчета) <> Неопределено Тогда // это внутренний отчет-документ

		ВнутреннийОтчет = Документы[ИсточникОтчета];
		ВыбФормаОтчета  = ВнутреннийОтчет.ПолучитьФорму("ОсновнаяФорма");
		ВыбФормаОтчета.РежимВыбора = Ложь;
		ВыбФормаОтчета.Открыть();
		Возврат;

	КонецЕсли;

	ТекОтчет = РеглОтчеты(ИсточникОтчета);

	Если ТекОтчет = Неопределено Тогда
		Сообщить("Не удалось открыть отчет!", СтатусСообщения.Важное);
		Возврат;
	КонецЕсли;
	
	ТекФорма = ФормаРеглОтчета(ИсточникОтчета);
	Если ТекФорма = Неопределено Тогда
		Сообщить("Не удалось открыть отчет!", СтатусСообщения.Важное);
		Возврат;
	КонецЕсли;

	Попытка
		Если ТипЗнч(ОрганизацияОтбор) = Тип("СписокЗначений") И ОрганизацияОтбор.Количество() <> 0 Тогда
			ТекФорма.Налогоплательщик = ОрганизацияОтбор.Получить(0).Значение;
			ТекФорма.мСписокСтруктурныхЕдиниц = ОрганизацияОтбор;
		Иначе
			ТекФорма.Налогоплательщик = ОрганизацияОтбор;
		КонецЕсли;		
	Исключение
	КонецПопытки;

	Попытка
		ТекФорма.мДатаНачалаПериодаОтчета = ДатаНач;
		ТекФорма.мДатаКонцаПериодаОтчета = ДатаКон;
	Исключение
	КонецПопытки;

	Если СвойствоОпределено(ТекФорма, "мПериодичность") Тогда
		Если Периодичность <> Неопределено Тогда
			ТекФорма.мПериодичность = Периодичность;
		КонецЕсли;
	КонецЕсли;

	ТекФорма.РежимВыбора = Ложь;
	ТекФорма.Открыть();

КонецПроцедуры // ОткрытьРегОтчет

// ПроверитьНапоминанияПользователяКалендарьБухгалтераСобытия
//
Процедура ПроверитьНапоминанияПользователяКалендарьБухгалтераСобытия(ВыбПользователь) Экспорт
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|Пользователь
	|, ПоследняяДатаДействия
	|, ИсточникОтчета
	|, ЗаПериодС
	|, ЗаПериодПо
	|, Организация
	|, ТипСообщения
	|, Состояние
	|, ФормаОтчета
	|, Периодичность
	|, Название
	|, Налогоплательщик
	|, ДобавитьКДате(ПоследняяДатаДействия, День, &ДниНапоминаний) Как СрокНачалаНапоминаний	
	|, ДатаПоказа
	|ИЗ РегистрСведений.СобытияКалендаряБухгалтера
	|ГДЕ
	|Пользователь = &Пользователь
	|И &РабочаяДата >= ДобавитьКДате(ПоследняяДатаДействия, День, &ДниНапоминаний)
	|И Состояние = &Состояние
	|И ДатаПоказа <> &ДатаПоказа";

	КолВоДней = ЗначениеИнтервалаНапоминанийРегламентированнойОтчетности();
	Если КолВоДней = 0 Тогда
		Возврат;
	КонецЕсли;
	ТекРабочаяДата = ОбщегоНазначения.ПолучитьРабочуюДату();
	Запрос.УстановитьПараметр("Пользователь", ВыбПользователь);
	Запрос.УстановитьПараметр("Состояние", Перечисления.СостоянияСобытий.Запланировано);
	Запрос.УстановитьПараметр("ДниНапоминаний", (-1) * КолВоДней);
	Запрос.УстановитьПараметр("РабочаяДата", ТекРабочаяДата);
	Запрос.УстановитьПараметр("ДатаПоказа", ТекРабочаяДата);
	ТаблРезультат = Запрос.Выполнить().Выгрузить();

	Если ТаблРезультат.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	Для Каждого Зап Из ТаблРезультат Цикл
		Запись = РегистрыСведений.СобытияКалендаряБухгалтера.СоздатьМенеджерЗаписи();
		ЗаполнитьЗначенияСвойств(Запись, Зап);
		Запись.Прочитать();
		Если Запись.Выбран() Тогда
			Запись.ДатаПоказа = ТекРабочаяДата;
			Запись.Записать();
			Зап.ДатаПоказа = ТекРабочаяДата;
		КонецЕсли;
	КонецЦикла;

	ФормаНапоминания = роПолучитьОбщуюФорму("НапоминанияКалендаряБухгалтера");
	ФормаНапоминания.НачальноеЗначениеВыбора = ТаблРезультат;
	Если ФормаНапоминания.Открыта() Тогда
		ФормаНапоминания.Закрыть();
	КонецЕсли;
	ФормаНапоминания.Открыть();

КонецПроцедуры // ПроверитьНапоминанияПользователяКалендарьБухгалтераСобытия

////////////////////////////////////////////////////////////////////////////////
// СОБЫТИЯ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ
 
// Событие возникает перед открытием основной формы регламентированного отчета.
// В процедуре инициализируются стандартные переменные отчета. Выполняются специфические для
// внешних регламентированных отчетов действия, в случае если отчет внешний.
// Параметры:
//		Форма - основная форма отчета.
//		Отказ - признак отказа от открытия формы.
//		СтандартнаяОбработка - признак стандартной обработки открытия формы.
Процедура ПередОткрытиемОсновнойФормыРегламентиованногоОтчета(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	СтроковоеПредставлениеТипаОбъекта = Строка(ТипЗнч(Форма.ЭтотОбъект));
	ЭтоВнешнийОтчет = (Лев(СтроковоеПредставлениеТипаОбъекта, 24) = "Внешний отчет объект");
	Если ЭтоВнешнийОтчет И Форма.мПолноеИмяФайлаВнешнейОбработки = Неопределено Тогда
		Если СравнитьИЗалитьВХранилище(Форма.ЭтотОбъект) Тогда
			Отказ = Истина;
			Возврат;
		КонецЕсли;
		Если Форма.мПолноеИмяФайлаВнешнейОбработки = Неопределено Тогда
			Предупреждение("Внимание, отчет не зарегистрирован! Функция сохранения будет недоступна!");
			Форма.мЗаписьЗапрещена = Истина;
		КонецЕсли;
	КонецЕсли;
	Форма.АвтоЗаголовок = Ложь;

	Если Форма.ВладелецФормы <> Неопределено Тогда
		Если Не Форма.ВладелецФормы.ЭтоНовый() Тогда
			
			// При восстановлении сохраненных данных сразу открываем
			// нужную форму отчета, минуя основную форму.
			Отказ = Истина;

			Форма.мСохраненныйДок = Форма.ВладелецФормы.ДокументОбъект;
			
			// определяем границы периода построения отчета
			Форма.мДатаНачалаПериодаОтчета = НачалоДня(Форма.мСохраненныйДок.ДатаНачала);
			Форма.мДатаКонцаПериодаОтчета  = КонецДня(Форма.мСохраненныйДок.ДатаОкончания);
			
			// в некоторых отчетах (формы баланса, например) переменная мПериодичность не определена
			Попытка
				Форма.мПериодичность = Форма.мСохраненныйДок.Периодичность;
			Исключение
			КонецПопытки;

			// по реквизиту ВыбраннаяФорма документа определяем,
			// какую форму следует открыть
			ВыбраннаяФорма = Форма.ВладелецФормы.ВыбраннаяФорма;
			
			//УжеОткрытаяФорма = Отчеты[ЭтотОбъект.Метаданные().Имя].ПолучитьФорму(?(ПустаяСтрока(ВыбраннаяФорма), ПолучитьФормуДляПериода(мСохраненныйДок.ДатаОкончания), СокрЛП(ВыбраннаяФорма)), , мСохраненныйДок.Ссылка);
			УжеОткрытаяФорма = ФормаРеглОтчета(Форма.ЭтотОбъект.Метаданные().Имя, СокрЛП(ВыбраннаяФорма), , Форма.мСохраненныйДок.Ссылка);
			Если УжеОткрытаяФорма.Открыта() И УжеОткрытаяФорма.мСохраненныйДок.Ссылка = Форма.мСохраненныйДок.Ссылка Тогда
				УжеОткрытаяФорма.Активизировать();
				Возврат;
			КонецЕсли;
			
			Если НЕ ЗаблокироватьДокумент(Форма.мСохраненныйДок) Тогда
				Возврат;
			КонецЕсли;
			
			Если Форма.ЭтотОбъект.Метаданные().Формы.Найти(СокрП(ВыбраннаяФорма)) <> Неопределено Тогда
				ВыбФормаОтчета = Форма.ПолучитьФорму(СокрП(ВыбраннаяФорма), , Форма.мСохраненныйДок.Ссылка);
			Иначе
				// Если не удалось найти форму с таким названием (могла быть переименована),
				// то по умолчанию выдаем текущую (действующую) форму
				ВыбраннаяФорма = Форма.мТаблицаФормОтчета[0].ФормаОтчета;
				ВыбФормаОтчета = Форма.ПолучитьФорму(ВыбраннаяФорма, , Форма.мСохраненныйДок.Ссылка);
			КонецЕсли;
			
			// Попытка получения переменной мВерсияФормы сохраненного документа для сравнения
			// с аналогичной переменной объекта отчет.
			Попытка
				ВерсияФормыДанных = Форма.мСохраненныйДок.ДанныеОтчета.Получить().ВерсияФормы;
				Если НЕ ПродолжитьПриНесоответствииВерсийФорм(ВерсияФормыДанных, ВыбФормаОтчета.мВерсияФормы) Тогда
					Возврат;
				КонецЕсли;
			Исключение
			Конецпопытки;
			
			Форма.мВыбраннаяФорма = ВыбраннаяФорма;

			ДобавитьНадписьВнешнийОтчет(ВыбФормаОтчета);
			ВыбФормаОтчета.РежимВыбора = Ложь;
			ВыбФормаОтчета.Открыть();

		ИначеЕсли Форма.ВладелецФормы.мСкопированаФорма <> Неопределено Тогда
			// Новый документ РегламентированныйОтчет был получен
			// методом копирования имеющегося.
			// Переменной мСохраненныйДок присвоим текущий документ
			Форма.мСохраненныйДок   = Форма.ВладелецФормы.ДокументОбъект;
			Форма.мСкопированаФорма = Форма.ВладелецФормы.мСкопированаФорма;
			
			Если НЕ ЗаблокироватьДокумент(Форма.мСохраненныйДок) Тогда
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
	Иначе

	КонецЕсли;
	
КонецПроцедуры

// Событие возникает после записи из регалментированного отчета информации в экземпляр документа
// РегламентированныйОтчет.
// Параметры:
// 		Форма - форма регламентированного отчета, из которой происходила запись в документ.
Процедура ПослеЗаписиРегламентированногоОтчета(Форма) Экспорт
	
	ЗаблокироватьДокумент(Форма.мСохраненныйДок);
	КартинкаСохранение = Форма.ЭлементыФормы.Найти("КартинкаСохранение");
	Если КартинкаСохранение <> Неопределено Тогда
	    КартинкаСохранение.Видимость = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Событие возникает перед записью из регламентированного отчета информации в экземпляр документа
// РегламентированныйОтчет.
// Проверяет возможность записи данных в экземлпяр документа РегламентированныйОтчет из 
// переданной в качестве параметра Формы регламентированного отчета.
// В случае невозможности записи выдает предупреждение.
// Параметры:
// 		Форма - форма регламентированного отчета, из которой производится попытка записи данных в документ.
// Возвращаемое значение:
//		Булево - Истина, если запись возможна; Ложь - в противном случае.
Функция ПриЗаписиРегламентированногоОтчета(Форма) Экспорт
	
	Если Форма.мЗаписьЗапрещена = Истина Тогда
		Предупреждение("Невозможно сохранить отчет! Воспользуйтесь механизмом внешних регламентированных отчетов, встроенным в конфигурацию!");
		Возврат Ложь;
	КонецЕсли;
	КартинкаСохранение = Форма.ЭлементыФормы.Найти("КартинкаСохранение");
	Если КартинкаСохранение <> Неопределено Тогда
	    КартинкаСохранение.Видимость = Истина;
	КонецЕсли;
	Возврат Истина;
	
КонецФункции

// Событие возникает при закрытии регламентированного отчета
// Параметры:
// 		Форма - закрываемая форма регламентированного отчета.
Процедура ПриЗакрытииРегламентированногоОтчета(Форма) Экспорт
	
	Если Форма.мСохраненныйДок <> Неопределено И Форма.мСохраненныйДок <> ОбщегоНазначения.ПустоеЗначениеТипа(ТипЗнч(Форма.мСохраненныйДок)) И Форма.мСохраненныйДок.Заблокирован() Тогда
		Форма.мСохраненныйДок.Разблокировать();
	КонецЕсли;
	СохранитьЗначение("ИнтервалАвтосохраненияРегламентированнойОтчетности", Форма.мИнтервалАвтосохранения);
	
КонецПроцедуры

// Функция определяет возможность использования регламентированного отчета текущим пользователем.
//
// Параметры:
//	ИдентификаторОтчета - строка - уникальный идентификатор регламентированного отчета.
//
// Возвращаемое значение:
//	Булево. Истина - пользователь имеет право использовать отчет.
//			Ложь - пользователь не имеет право использовать отчет.
//			Неопределено - указанный отчет не зарегистрирован в системе.
//
Функция ПравоДоступаКРегламентированномуОтчету(ИдентификаторОтчета) Экспорт
	
	Если НЕ ЭтоВнешнийОтчет(ИдентификаторОтчета) Тогда // это внутренний отчет
		
		Если Метаданные.Документы.Найти(ИдентификаторОтчета) <> Неопределено Тогда // это документ
			
			Если НЕ ПравоДоступа("Изменение", Метаданные.Документы[ИдентификаторОтчета]) Тогда
				Возврат Ложь;
			КонецЕсли;
			
		ИначеЕсли Метаданные.Отчеты.Найти(ИдентификаторОтчета) <> Неопределено Тогда // это отчет
			
			Если НЕ ПравоДоступа("Использование", Метаданные.Отчеты[ИдентификаторОтчета]) Тогда
				Возврат Ложь;
			КонецЕсли;
			
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции	

//Процедура сообщает пользователю о том, что выгрузка  данных в формате XML удачно завершена
//и рекомендации для дальнейшего использования файла
//
Процедура ВыдатьОтветПриВыгрузке()  Экспорт
	
	ТекстПредупреждения = "Выгрузка данных закончена! Если Вы планируете сдавать отчет в электронной форме, Вам необходимо открыть данный файл в соответствующем программном обеспечении по вводу и передаче форм налоговой отчетности, предоставляемой налоговым комитетом, заполнить недостающие данные и ОБЯЗАТЕЛЬНО сохранить его в этой программе!";
	Предупреждение(ТекстПредупреждения);
	
КонецПроцедуры


///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА АВТОСОХРАНЕНИЯ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

// Функция возвращает значение интервала автосохранения отчетов (в минутах)
// для пользователя текущего сеанса.
//
// Функция не имеет параметров.
// Возвращаемое значение: Число - интервал автосохранения регламентированных отчетов.
Функция ЗначениеИнтервалаАвтосохраненияРегламентированнойОтчетности() Экспорт
	
	ИнтервалАвтосохраненияРегламентированнойОтчетности = ВосстановитьЗначение("ИнтервалАвтосохраненияРегламентированнойОтчетности");
	Если ИнтервалАвтосохраненияРегламентированнойОтчетности = Неопределено Тогда
		ИнтервалАвтосохранения = 10;
	Иначе
		ИнтервалАвтосохранения = ИнтервалАвтосохраненияРегламентированнойОтчетности;
	КонецЕсли;
	Возврат ИнтервалАвтосохранения;
	
КонецФункции

// Функция возвращает значение интервала напоминания для календаря (в днях)
//
// Функция не имеет параметров.
// Возвращаемое значение: Число - интервал напоминаний регламентированных отчетов.
//
Функция ЗначениеИнтервалаНапоминанийРегламентированнойОтчетности() Экспорт

	ИнтервалНапоминанийРегламентированнойОтчетности = ВосстановитьЗначение("ИнтервалНапоминанийРегламентированнойОтчетности");
	Если ИнтервалНапоминанийРегламентированнойОтчетности = Неопределено Тогда
		ИнтервалНапоминаний = 3;
	Иначе
		ИнтервалНапоминаний = ИнтервалНапоминанийРегламентированнойОтчетности;
	КонецЕсли;
	Возврат ИнтервалНапоминаний;

КонецФункции // ЗначениеИнтервалаНапоминанийРегламентированнойОтчетности


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА ФОРМИРОВАНИЯ НАЛОГОВЫХ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

//Процедура сохранет отчет в документ Регламентированный отчет
//
Процедура СохранитьРегОтчетВДокумент(РеглОтч, МодифицированностьФормы, СохранениеСОповещением = Истина) Экспорт
	
	Если РеглОтч.мСохраненныйДок <> Неопределено Тогда
						
		ХранилищеДанных = Новый ХранилищеЗначения(РеглОтч.мСписокСохранения);
		РеглОтч.мСохраненныйДок.ДанныеОтчета = ХранилищеДанных;
		
		СохранитьОшибка = 1;
		
		// записываем документ, хранящий данные отчета
		Попытка
			РеглОтч.мСохраненныйДок.Записать();
			Если СохранениеСОповещением Тогда
				Оповестить("Позиционирование в списке отчетов", РеглОтч.мСохраненныйДок.Ссылка);
			КонецЕсли;
		Исключение
			Предупреждение("Не удается сохранить регламентированный отчет! " + ОписаниеОшибки());
			СохранитьОшибка = 0;
		КонецПопытки;
		
		Если СохранитьОшибка = 1 Тогда
			// всё прошло без ошибок
			МодифицированностьФормы = Ложь;
		КонецЕсли;
		
		РеглОтч.мФормаНавигации.КлючУникальности = РеглОтч.мСохраненныйДок.Ссылка;
	КонецЕсли;
	
КонецПроцедуры

//Процедура перенумеровывает номера строк в таблица расшифровке, после удаления 
//строки пользователем
//	Параметры:
//	ТаблицаРасшифровки: Таблица значений, в которой хранятся расшифровки ячеек
//	НомерСтроки: Число, номер удаляемой ячейки
//
Процедура  ПерезаполнитьТаблицуРасшифровкиФормы(ТаблицаРасшифровки, НомерСтроки) Экспорт
	
	Отбор = Новый Структура("НомерСтроки", Число(НомерСтроки));
	ТаблицаРасшифровки.Сортировать("НомерСтроки");
	МассивСтрок = ТаблицаРасшифровки.НайтиСтроки(Отбор);
	Если МассивСтрок.Количество() > 0 Тогда
		Для Каждого Элемент Из МассивСтрок Цикл
			Индекс = ТаблицаРасшифровки.Индекс(Элемент);
			ТаблицаРасшифровки.Удалить(Элемент);
		КонецЦикла;
		Для ИндексСтроки = Индекс По ТаблицаРасшифровки.Количество()-1 Цикл
			ТаблицаРасшифровки[ИндексСтроки].НомерСтроки = ТаблицаРасшифровки[ИндексСтроки].НомерСтроки - 1;
		КонецЦикла;	
	Иначе
		Для Каждого Строка Из  ТаблицаРасшифровки Цикл
			Если Строка.НомерСтроки > Число(НомерСтроки) Тогда
				Строка.НомерСтроки = Строка.НомерСтроки - 1;
			КонецЕсли;
		КонецЦикла;	    		
	КонецЕсли;    
	
КонецПроцедуры   //ПерезаполнитьТаблицуРасшифровкиФормы()

// Добавляет строку в таблицу расшифровки 
//
 Процедура ДобавитьСтрокуРасшифровкиВТаблицуРасшифровкиФормы(ТаблицаРасшифровки, ИмяГруппы, ИмяЯчейки, ПолеПоиска, НомерСтрокиРасшифровки) Экспорт
	 
	НоваяСтрока = ТаблицаРасшифровки.Добавить();	 
	НоваяСтрока.ИмяГруппы 	= ИмяГруппы;
	НоваяСтрока.ИмяЯчейки   = ИмяЯчейки;
	НоваяСтрока.ПолеПоиска  = ПолеПоиска;
	НоваяСтрока.НомерСтроки = НомерСтрокиРасшифровки;
	
КонецПроцедуры // ДобавитьСтрокуРасшифровкиВТаблицуРасшифровкиФормы()

// Открывает форму расшифровки, предназначенную для значения выбранной ячейки
//
// Параметры:
//   мФорма - открытая в данный момент форма рег.отчета
//	 Ячейка - имя ячейки в табличном документе
//   ИмяЯчейки - имя, как оно задано в таблице расшифровке для формы
//   ТаблицаРасшифровки  - таблица значений, в которой хранятся именя ячеек и их значения
//   Форма - Форма, которая должна открыться для значения ячейки
//   СписокВыбора - список значений расшифровки
//
Процедура ОткрытьРасшифровкуЯчейкиРегОтчета(мФорма, Ячейка, ИмяЯчейки, ТаблицаРасшифровки, Форма, СписокВыбора = Неопределено) Экспорт
	
	НомерЯчейки = Число(Сред(Ячейка, Найти(Ячейка, "__")+ 2));
	СтруктураПоиска =  Новый Структура;
	СтруктураПоиска.Вставить("ИмяЯчейки",ИмяЯчейки);
	СтруктураПоиска.Вставить("НомерСтроки", НомерЯчейки);
	Строка = ТаблицаРасшифровки.НайтиСтроки(СтруктураПоиска);
	Если Строка.Количество() = 0  Тогда
		Если СписокВыбора <> Неопределено Тогда 
			ВыбранноеЗначение = СписокВыбора.ВыбратьЭлемент("Выберите расшифровку", СписокВыбора[0]);
			Если ВыбранноеЗначение <> Неопределено Тогда 
				Элемент = ВыбранноеЗначение.Значение;
				ФормаВыбора = Элемент.ПолучитьФормуВыбора(,мФорма);
				ФормаВыбора.ОткрытьМодально();  				
			Иначе
				Возврат;
			КонецЕсли;
		Иначе
			Форма.ОткрытьМодально();  				
		КонецЕсли;
		Возврат;
	КонецЕсли;				 
	Расшифровка        = Строка[0].ПолеПоиска;
	Если  Расшифровка <> Неопределено Тогда
		Если Не Расшифровка.Пустая() Тогда
			ФормаРасшифровки = Расшифровка.ПолучитьФорму(,,ИмяЯчейки);
			Если Расшифровка.ПолучитьФорму().Открыта() Тогда
				ФормаРасшифровки.ТолькоПросмотр = Истина;
			КонецЕсли;
			ФормаРасшифровки.ОткрытьМодально();  						
			ИмяГруппы = Строка[0].ИмяГруппы;
			ОбработкаПодбораРегОтчета(мФорма, Расшифровка, ИмяЯчейки, ИмяГруппы, НомерЯчейки);
		Иначе			
			Если СписокВыбора <> Неопределено Тогда 
				ВыбранноеЗначение = СписокВыбора.ВыбратьЭлемент("Выберите расшифровку", СписокВыбора[0]);
				Если ВыбранноеЗначение <> Неопределено Тогда 
					Элемент = ВыбранноеЗначение.Значение;
					ФормаВыбора = Элемент.ПолучитьФормуВыбора(,мФорма);
					ФормаВыбора.ОткрытьМодально();  				
				Иначе
					Возврат;
				КонецЕсли;  				
			Иначе
				Форма.ОткрытьМодально();  				
			КонецЕсли; 		
		КонецЕсли;
	КонецЕсли;        
	
КонецПроцедуры // ОткрытьРасшифровкуЯчейкиРегОтчета()

// Процедура выполняет выбор в зависимости от имени формы процедуры ОбработкаПодбора,
// которая в свою очередь заполняет данными ячейки табличных документов формы
// значениями из формы подбора
//
Процедура ОбработкаПодбораРегОтчета(Форма, Расшифровка, ИмяЯчейки, ИмяГруппы, НомерСтроки) Экспорт    
	
	НазваниеПроцедуры = "Форма." + Форма.ИмяФормы + "ОбработкаПодбора(Расшифровка, ИмяЯчейки, ИмяГруппы, НомерСтроки)";
	Выполнить(НазваниеПроцедуры);
 	 
КонецПроцедуры // ОбработкаПодбора()

// Процедура осуществляет поиск форм для передачи данных
// из любого уровня вложенности
Процедура НайтиСписокФормСамогоНизкогоУровняПоДеревуПередачиДанных(КодФормы, СписокФормИсточников, ТаблицаПоказателей) Экспорт
	
	Отбор = Новый Структура();
	Отбор.Вставить("КодФормыПриемник",КодФормы);
	Строки = ТаблицаПоказателей.НайтиСтроки(Отбор);

	Добавлено = Ложь;
	
	Для Каждого Строка Из Строки Цикл
		Если СписокФормИсточников.НайтиПоЗначению(Строка.КодФормыИсточник) = Неопределено Тогда
			СписокФормИсточников.Добавить(Строка.КодФормыИсточник);
			Добавлено = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если Добавлено Тогда
		НайденныйЭлемент = СписокФормИсточников.НайтиПоЗначению(КодФормы);
		Если НайденныйЭлемент <> Неопределено Тогда
			СписокФормИсточников.Удалить(НайденныйЭлемент);
		КонецЕсли;
		Для Каждого Источник Из СписокФормИсточников Цикл
			НайтиСписокФормСамогоНизкогоУровняПоДеревуПередачиДанных(Источник.Значение,СписокФормИсточников,ТаблицаПоказателей);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Подсчитывает итоги и передает из в структуру
//  
// Параметры: Объект - передаваемая форма
//
Функция  ПередатьИтоги(Объект, ТекИмяФормы) Экспорт
	
	ТаблицаПД = Объект.мТаблицаПоказателейДляПередачиДанных;
			
	Отбор = Новый Структура();
	Отбор.Вставить("КодФормыИсточник",ТекИмяФормы);
	СтрокиПередачи = ТаблицаПД.НайтиСтроки(Отбор);
	
	// проверим существует лим данная область
	Если СтрокиПередачи <> Неопределено Тогда
		// производим передачу итогов
		Пока СтрокиПередачи <> Неопределено Цикл
			
			СписокФормПриемников = Новый СписокЗначений;
			Для Каждого Строка Из СтрокиПередачи Цикл
				// перебираем строки области
				КодФормыИсточник    = Строка.КодФормыИсточник;
				ИмяОбластиИсточник  = Строка.ИмяОбластиИсточник;
				КодФормыПриемник    = Строка.КодФормыПриемник;
				ИмяОбластиПриемник  = Строка.ИмяОбластиПриемник;
				
				Форма = Объект.мСписокФормБезИерархии.Строки.Найти(КодФормыПриемник,"КодФормы");
				Если Форма <> Неопределено Тогда
					
					//проверим признак автополучения итогов для формы приемника
					Если Форма.АвтополучениеИтогов = 1 Тогда
						ПолучатьИтоги = Истина;
					Иначе
						ПолучатьИтоги = Ложь;
					КонецЕсли;
					
					Если ПолучатьИтоги Тогда
						
						//-------расчет данных---------
						// найдем формы из которых также передается значение				
						ОтборПоПриемнику = Новый Структура();
						ОтборПоПриемнику.Вставить("КодФормыПриемник",КодФормыПриемник);
						ОтборПоПриемнику.Вставить("ИмяОбластиПриемник",ИмяОбластиПриемник);
						СтрокиПриемника = ТаблицаПД.НайтиСтроки(ОтборПоПриемнику);
					
						ПередаваемоеЗначение = 0;
						Для Каждого СтрокаПоПриемнику Из СтрокиПриемника Цикл
							ЗначениеДляПередачи = ПолучитьЗначениеИзСтруктурыДляПередачиИтогов(Объект,
						    	          СтрокаПоПриемнику.КодФормыИсточник,СтрокаПоПриемнику.ИмяОбластиИсточник);
							Если ЗначениеДляПередачи = Неопределено Тогда
								Возврат Ложь;
							КонецЕсли;
							ПередаваемоеЗначение = ПередаваемоеЗначение + ЗначениеДляПередачи;
						КонецЦикла;
				  				
						//-------прием данных---------
						Если Форма.Многострочность = 1 Тогда
							
							ТаблицаДанных = Форма.Значение;
							мМногострочнаяСтруктура = ТаблицаДанных[0].Данные;
							ОбластьНайдена = Ложь;
							Для Каждого Страница Из мМногострочнаяСтруктура Цикл  	
			     
								ИмяГруппы = Страница.Ключ;
								СтруктураГруппы = Неопределено; 						
								мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы);
								ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;           
								ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;        	 	
							 	
								// Ищем область приемника в общих элементах группы (областях шапки и подвала мног.формы)
								СтрокаОбластиПриемника = ОбщиеЭлементыГруппы.Найти(ИмяОбластиПриемник,"ИмяОбласти");
								Если СтрокаОбластиПриемника <> Неопределено Тогда
									Если НЕ СтрокаОбластиПриемника.Итог = Истина Тогда
										СтрокаОбластиПриемника.Значение = ПередаваемоеЗначение; 
										ОбластьНайдена = Истина;						
									КонецЕсли;
								КонецЕсли;
								
								// Ищем область приемника в таблице строк группы (в колонках)
								// если находим, то добавляем в первую строку передаваемое значение
								// Если в таблице строк нет ни одной строки, то добавляем 1 строку
								// и в колонку с именем "ИмяОбластиПриемник" записываем передаваемое значение
								КолонкаОбластиПриемника = ТаблицаСтрокГруппы.Колонки.Найти(ИмяОбластиПриемник);
								Если КолонкаОбластиПриемника <> Неопределено Тогда
									// проверяем наличие строк
									Если ТаблицаСтрокГруппы.Количество() = 0 Тогда
										// добавляем строку
										Для Каждого Стр Из мМногострочнаяСтруктура Цикл  				     
											ИмяГр = Стр.Ключ;
											СтрГр = Неопределено; 						
											мМногострочнаяСтруктура.Свойство(ИмяГр, СтрГр);
											ТаблицаСтрок = СтрГр.Строки;        	 	
											Строка = ТаблицаСтрок.Добавить();
										КонецЦикла;
										Объект.ЗаполнитьПараметры(КодФормыПриемник);
									КонецЕсли;
									ПерваяСтрока = ТаблицаСтрокГруппы[0];
									ПерваяСтрока[ИмяОбластиПриемник] = ПередаваемоеЗначение;																			
								    ОбластьНайдена = Истина;
							    КонецЕсли;
												            		 	 
								//заполняем данные итогов		 
								ЗаполнитьДанныеИтоговВСтруктуре(ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы); 
							КонецЦикла;
							
							// если область приемника нигде в структуре многострочной формы не была найдена
							// выводим соответствующее сообщение о неккоректном имени области приемника в 
							// макете "ПередачаДанных".
							Если НЕ ОбластьНайдена Тогда
							    Сообщить("Неверное имя области приемника """ + ИмяОбластиПриемник + """ для кода формы приемника """ + КодФормыПриемник + """.");							
								Возврат Ложь;								
							КонецЕсли;
							
						Иначе // если обычная
							ТаблицаДанных = Форма.Значение;
							СтрокаОбластиПриемника = ТаблицаДанных.Найти(ИмяОбластиПриемник,"ИмяОбласти");
							Если СтрокаОбластиПриемника <> Неопределено Тогда
								СтрокаОбластиПриемника.Значение = ПередаваемоеЗначение; 
							Иначе
								Сообщить("Неверное имя области приемника """ + ИмяОбластиПриемник + """ для кода формы приемника """ + КодФормыПриемник + """.");							
								Возврат Ложь;
							КонецЕсли;
								
						КонецЕсли;
							
						// смотрим есть ли уже такая форма приемник в списке форм приемников
						// и если нет, то добавляем в список
						НайденныйЭлемент = СписокФормПриемников.НайтиПоЗначению(КодФормыПриемник);
						Если НайденныйЭлемент = Неопределено Тогда
							СписокФормПриемников.Добавить(КодФормыПриемник);
							Если КодФормыПриемник = ТекИмяФормы Тогда
								Сообщить("Цикличная передача итогов");
								Возврат Ложь;
							КонецЕсли;							
						КонецЕсли;
					КонецЕсли;
				Иначе
					Сообщить("Неверный код формы приемника """ + КодФормыПриемник + """ для передачи данных");
					Возврат Ложь;
				КонецЕсли;
								 				
			КонецЦикла;
			
			//для каждой формы приемника производим процедуру расчета
			Для Каждого Элемент из СписокФормПриемников Цикл
				ФормаПриемник = Элемент.Значение;
				Объект.ВыборРасчета(ФормаПриемник);
			КонецЦикла;
			
			Если СписокФормПриемников.Количество() = 0 Тогда
				СтрокиПередачи = Неопределено;
			КонецЕсли;
			
			Пока СписокФормПриемников.Количество() <> 0 Цикл 
				ФормаПриемник = СписокФормПриемников[0].Значение;
				Отбор = Новый Структура();
				Отбор.Вставить("КодФормыИсточник",ФормаПриемник);
				СтрокиПередачи = ТаблицаПД.НайтиСтроки(Отбор);
				СписокФормПриемников.Удалить(0);
				Если СтрокиПередачи <> Неопределено Тогда
					Прервать;
				КонецЕсли;			
			КонецЦикла;
				
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // ПередатьИтоги()

// Функция получает из общей структуры хранения данных
// значение для передачи итогов.
//
Функция ПолучитьЗначениеИзСтруктурыДляПередачиИтогов(Объект, КодФормыИсточник, ТекПоказательПередачи)
	
	ПередаваемоеЗначение = Неопределено;
	
	ФормаИсточник = Объект.мСписокФормБезИерархии.Строки.Найти(КодФормыИсточник,"КодФормы");
	Если ФормаИсточник <> Неопределено Тогда
		// если форма источник многострочная
		Если ФормаИсточник.Многострочность = 1 Тогда
			ТаблицаДанных = ФормаИсточник.Значение;
			МногСтруктура = ТаблицаДанных[0].Данные;
			Найдено = Ложь;
			Для Каждого Строка Из МногСтруктура Цикл
				СтруктураГруппы = Строка.Значение;
				ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
				Если ОбщиеЭлементыГруппы.Найти(ТекПоказательПередачи,"ИмяОбласти") <> Неопределено Тогда
					ПередаваемоеЗначение = ОбщиеЭлементыГруппы.Найти(ТекПоказательПередачи,"ИмяОбласти").Значение;
					Найдено = Истина;
				КонецЕсли;
			КонецЦикла;
			// Преверяем, если вообще ни на одном листе не нашли данное имя области,
			// то сообщаем пол-лю и возвращаем Неопределено.
			Если Не Найдено Тогда
				Сообщить("Неверное имя области """ + ТекПоказательПередачи +""" формы источника """ 
					+ КодФормыИсточник + """ для передачи данных");
				Возврат Неопределено;
			КонецЕсли;							
		Иначе // если форма источник обычная
			ТаблицаДанных = ФормаИсточник.Значение;
			СтрокаОбластиИсточника = ТаблицаДанных.Найти(ТекПоказательПередачи,"ИмяОбласти");
			Если СтрокаОбластиИсточника <> Неопределено Тогда
				 ПередаваемоеЗначение = СтрокаОбластиИсточника.Значение;								
			Иначе
				 Сообщить("Неверное имя области """ + ТекПоказательПередачи +""" формы источника """ 
					+ КодФормыИсточник + """ для передачи данных");
				 Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		Если ПередаваемоеЗначение = Неопределено Тогда
			ПередаваемоеЗначение = 0;
		КонецЕсли;							 					
	Иначе
		Сообщить("Неверный код формы источника """ + КодФормыИсточник + """ для передачи данных");
		Возврат Неопределено;
	КонецЕсли;	
	
	Возврат ПередаваемоеЗначение;
	
КонецФункции

// Функция осуществляет проверку заполнять форму или нет и 
// осуществляет очистку формы и первоначальное заполнение основных 
// параметров формы с помощью процедуры ЗаполнитьПараметры()
//
// Параметры:  Объект - форма регламентированного отчета,
//             КодФормы - код заполняемой формы
// 			   Перезаполнить - признак перезаполнения формы, 
//                             устанавливается в значение Истина при непосредственном заполнении формы
//                             при нажатии на кнопку "Заполнить",
//                             Устанавливается в значение Ложь при заполнении формы из родительской формы
//
Функция ПересчитыватьДанныеФормы(Форма, КодФормы, Перезаполнить) Экспорт
	
	Если Не Перезаполнить Тогда
		ПризнакАвтоЗаполнения = ОпределитьПризнакАвтоЗаполненияФормы(КодФормы,Форма.мСписокФормБезИерархии);
		Если Не ПризнакАвтоЗаполнения Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;

	Если Перезаполнить И ФормаЗаполнена(КодФормы,Форма.мСписокФормБезИерархии) Тогда
		ТекФорма = Форма.СписокФормДерева.Строки.Найти(КодФормы,"КодФормы",Истина);
		Если ТекФорма.Строки.Количество() > 0 Тогда
			ТекстВопроса = "Пересчитать данные формы и ее дополнительных форм?";
		Иначе
			ТекстВопроса = "Пересчитать данные формы?";
		КонецЕсли;
		Ответ = Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет, ,КодВозвратаДиалога.Да);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Форма.Очистить(КодФормы,Истина);		 
		
	Возврат Истина;
	
КонецФункции // ПересчитыватьДанныеФормы()

// Процедура выполняет основные действия по заполнению формы
// или приложения регламентированного отчета
//
// Параметры: Объект - передаваемая форма
Процедура ЗаполнитьФорму(Форма, ТекущееИмяФормы, ПризнакПерезаполнения) Экспорт
	
	Перем СтруктураГруппы;
	
	ТекФорма = Форма.мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы, "КодФормы");
	
	Если ТекФорма.Многострочность = 1 Тогда
	
		мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(ТекущееИмяФормы, Форма.мСписокФормБезИерархии);
		
		Для Каждого Страница Из мМногострочнаяСтруктура Цикл  	
			     
			ИмяГруппы = Страница.Ключ;
			 						
			мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы);
			ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;           
			ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;        	 	
				
			// Очищаем таблицу значений, для записи значений шапки(подвала)
			Для Каждого ЭлГруппы Из ОбщиеЭлементыГруппы Цикл
				ЭлГруппы.Значение = Неопределено;			 
			КонецЦикла;
							            		 	 
			//заполняем данные итогов		 
			ЗаполнитьДанныеИтоговВСтруктуре(ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы); 
		КонецЦикла;                                               
		
		// заполняем шапку и повал многострочной формы
		Форма.ЗаполнитьПараметры(ТекущееИмяФормы);
			
	Иначе
		
		//рассчитаем из приложений данные	 
		Форма.ВыборРасчета(ТекущееИмяФормы); 
			
	КонецЕсли;
	
	Если Не ПризнакПерезаполнения Тогда
		//здесь нужно передать объект отчета мФормы
		 СформироватьПризнакиФормыИПередатьИтоги(Форма, ТекущееИмяФормы, Ложь);
	КонецЕсли;
	 
	Форма.Модифицированность = Истина;
	
КонецПроцедуры

// Процедура вызывается при закрытии формы 				
// или при заполнении текущей формы из родительской формы. 
//
// Параметры:
//           Объект - передаваемая форма рег.отчета
//           ТекИмяФормы - представляет имя текущей формы (мФорма.ИмяФормы)
//           ПризнакПередачиИтогов - определяет режим вызова данной процедуры
//                равен Истина, если процедура вызвана при закрытии формы
//              и равен ложь, если процедура вызвана при заполнении приложения из родительской формы.
//
Процедура СформироватьПризнакиФормыИПередатьИтоги(Форма, ТекИмяФормы, ПризнакПередачиИтогов = Истина) Экспорт
	
	Если ФормаЗаполнена(ТекИмяФормы, Форма.мСписокФормБезИерархии) Тогда 
			
		//устанавливаем признак выгружать в форме настройки страниц
		ФормаНС = Форма.мСписокФормБезИерархии;
		Строка  = ФормаНС.Строки.Найти(ТекИмяФормы, "КодФормы");
		
		Если Строка <> Неопределено Тогда
        	Строка.Выгружать = 1;
		КонецЕсли;
				
	Иначе // форма не заполнена
		
		Если ПризнакПередачиИтогов Тогда
			Сообщить("Форма """ + Форма.Заголовок + """ не заполнена. Данные не переданы", СтатусСообщения.Внимание);
		КонецЕсли;
		ФормаНС = Форма.мСписокФормБезИерархии;
		Строка = ФормаНС.Строки.Найти(ТекИмяФормы, "КодФормы");
		Если Строка <> Неопределено Тогда
			Строка.Выгружать = 0;  
		КонецЕсли;
				
	КонецЕсли;
	
	ПереданыИтоги = ПередатьИтоги(Форма,ТекИмяФормы);
	Если Не ПереданыИтоги Тогда
		Сообщить("Данные из формы """ + ТекИмяФормы + """ не переданы.");
	КонецЕсли;
		
КонецПроцедуры // СформироватьПризнакиФормыИПередатьИтоги()

// Процедура устанавливает ориентацию страниц для полей табличного документа
// на каждой странице панели формы
//
Процедура УстановитьНастройкиПечатиФормы(Форма, ТекущееИмяФормы) Экспорт
	
	// определим ориентацию страниц для формы
	Для Каждого Страница Из Форма.ЭлементыФормы["Панель"+ТекущееИмяФормы].Страницы Цикл
		Форма.ЭлементыФормы[ТекущееИмяФормы + "ПолеТабличногоДокумента" + Страница.Имя].ОриентацияСтраницы = ОпределитьОриентациюСтраницы(ТекущееИмяФормы,Форма.мСписокФормБезИерархии);
		Форма.ЭлементыФормы[ТекущееИмяФормы + "ПолеТабличногоДокумента" + Страница.Имя].ЧерноБелаяПечать = Ложь;
		Форма.ЭлементыФормы[ТекущееИмяФормы + "ПолеТабличногоДокумента" + Страница.Имя].АвтоМасштаб = Истина;		
	КонецЦикла;
	
КонецПроцедуры

//Управляет видимостью страниц основной панели формы.
// Применяется только для многострочных форм
//Параметры:
//          ТекущаяСтраница - номер страницы
//          ВсегоСтраниц - общее количество страниц формы
//
Процедура ПоказатьСтраницыМногострочнойФормы(Форма) Экспорт   
	
	ТекущаяСтраница = Форма.ТекущаяСтраница;
	ВсегоСтраниц = Форма.ВсегоСтраниц;
	
	//добавлена "мФорма." для вызова из основной формы
    Если ТекущаяСтраница > 1 И ТекущаяСтраница < ВсегоСтраниц Тогда
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.ПредыдущаяСтр.Доступность = Истина;
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.СледующаяСтр.Доступность  = Истина;
	ИначеЕсли ТекущаяСтраница = 1 И ТекущаяСтраница < ВсегоСтраниц Тогда		
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.ПредыдущаяСтр.Доступность = Ложь;
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.СледующаяСтр.Доступность  = Истина;
	ИначеЕсли ТекущаяСтраница = ВсегоСтраниц И ТекущаяСтраница = 1 Тогда		
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.ПредыдущаяСтр.Доступность = Ложь;
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.СледующаяСтр.Доступность  = Ложь;		
	ИначеЕсли ТекущаяСтраница = ВсегоСтраниц Тогда		
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.ПредыдущаяСтр.Доступность = Истина;
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.СледующаяСтр.Доступность  = Ложь;
	КонецЕсли;
	
	Если ТекущаяСтраница <> 0 Тогда	
		ПредставлениеНадписи = Строка(ТекущаяСтраница) + " из " + Строка(ВсегоСтраниц);
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.КоличествоСтраниц.Текст = ПредставлениеНадписи;
	Иначе
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.КоличествоСтраниц.Текст   = "1 из 1";
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.ПредыдущаяСтр.Доступность = Ложь;
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.СледующаяСтр.Доступность  = Ложь;
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.Перейти.Доступность       = Ложь;
	КонецЕсли; 
	
	Если ВсегоСтраниц <> Неопределено И ВсегоСтраниц > 1 Тогда
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.Перейти.Доступность       = Истина;
	Иначе
		Форма.ЭлементыФормы.КоманднаяПанель.Кнопки.Перейти.Доступность       = Ложь;
	КонецЕсли;
	
КонецПроцедуры // ПоказатьСтраницыМногострочнойФормы()

// Процедура производит очистку данных.
// Параметры:
//  ВидОчистки - строка, задающая способ очистки:
//               "ОчиститьФорму" - Очистить текущую форму
//				 "ОчиститьФормуИПриложения" - Очистить форму и приложения к ней
//
Процедура ОчиститьРеглОтчет(Форма, ВидОчистки) Экспорт	
	
	ФормаЗаполнена = ФормаЗаполнена(Форма.ИмяФормы, Форма.мСписокФормБезИерархии);
	Вложенность = Ложь;
	
	Если ВидОчистки = "ОчиститьФорму" Тогда 
		
		Если ФормаЗаполнена Тогда
			Ответ = Вопрос("Очистить данные формы?", РежимДиалогаВопрос.ДаНет, ,КодВозвратаДиалога.Да,);
			Если Ответ = КодВозвратаДиалога.Нет Тогда
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
		Вложенность = Ложь;   
					
	ИначеЕсли ВидОчистки = "ОчиститьФормуИПриложения" Тогда
				
		Если ФормаЗаполнена Тогда      
			Текст = ?(Форма.ИмяФормы = Лев(Форма.мВыбраннаяФорма,СтрДлина(Форма.мВыбраннаяФорма)-7),"Полностью очистить декларацию?","Очистить форму и ее приложения?");
			Ответ = Вопрос(Текст, РежимДиалогаВопрос.ДаНет, ,КодВозвратаДиалога.Да,);
			Если Ответ = КодВозвратаДиалога.Нет Тогда
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
		Вложенность = Истина;
							
	КонецЕсли;
	
	ОчиститьДанныеРегОтчета(Форма, Форма.ИмяФормы, Форма.ПризнакМногострочности,Вложенность);
			 	
КонецПроцедуры // ОчиститьРеглОтчет()

// Очищает данные в структурах: мСписокСохранения, 
// мСписокВычисляемыхЯчеек, мСтруктураОтчета
// Параметры:
//     ИмяОчищаемойФормы - имя формы, подлежащей очистке
//     ТекПризнакМногострочности - признак многострочности формы
//     Вложенность - признак очистки доп.форм данной формы
//
Процедура ОчиститьДанныеРегОтчета(Форма, ИмяОчищаемойФормы, ТекПризнакМногострочности, Вложенность = Ложь)
	
	Если ИмяОчищаемойФормы = Лев(Форма.мВыбраннаяФорма, СтрДлина(Форма.мВыбраннаяФорма)-7) Тогда 
		
		Если Вложенность Тогда 
			Форма.Очистить(ИмяОчищаемойФормы,Истина);
			Форма.мСписокСохранения.Очистить();
			//очищаем данные для выгрузки
			ЗаполнитьСтруктуруФормРегОтчета(Форма.ЭтотОбъект);
			Предупреждение("Данные в приложениях очищены!");			
		Иначе
			Форма.Очистить(ИмяОчищаемойФормы);
			Если Форма.мСписокСохранения.Свойство("ПоказателиОтчета") Тогда
				Форма.мСписокСохранения.Удалить("ПоказателиОтчета");
			КонецЕсли;
		КонецЕсли;                                          		
		
	ИначеЕсли ТекПризнакМногострочности = Истина Тогда 
		
		Форма.Очистить(ИмяОчищаемойФормы);
		
		ФормаНС = Форма.мСписокФормБезИерархии;
		Строка = ФормаНС.Строки.Найти(ИмяОчищаемойФормы, "КодФормы");
		Если Строка <> Неопределено Тогда
			Строка.Выгружать = 0;  
		КонецЕсли;
		
		Если Вложенность Тогда 
			
			НайденнаяМногСтрокаВДереве = Форма.СписокФормДерева.Строки.Найти(ИмяОчищаемойФормы,"КодФормы",Истина);
			Если НайденнаяМногСтрокаВДереве <> Неопределено И НайденнаяМногСтрокаВДереве.Строки.Количество() > 0 Тогда
				Для Каждого ПодчиненнаяСтрока2 Из НайденнаяМногСтрокаВДереве.Строки Цикл
					ОчиститьДанныеРегОтчета(Форма,ПодчиненнаяСтрока2.КодФормы,ПодчиненнаяСтрока2.Многострочность,Истина);
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;
						
	Иначе //для обычных форм
		
		Форма.Очистить(ИмяОчищаемойФормы);
		
		ФормаНС = Форма.мСписокФормБезИерархии;
		Строка = ФормаНС.Строки.Найти(ИмяОчищаемойФормы, "КодФормы");
		Если Строка <> Неопределено Тогда
			Строка.Выгружать = 0;  
		КонецЕсли;
				
		Если Вложенность Тогда 
			
			НайденнаяСтрокаВДереве = Форма.СписокФормДерева.Строки.Найти(ИмяОчищаемойФормы,"КодФормы",Истина);
			Если НайденнаяСтрокаВДереве <> Неопределено И НайденнаяСтрокаВДереве.Строки.Количество() > 0 Тогда
				Для Каждого ПодчиненнаяСтрока Из НайденнаяСтрокаВДереве.Строки Цикл
					ОчиститьДанныеРегОтчета(Форма,ПодчиненнаяСтрока.КодФормы,ПодчиненнаяСтрока.Многострочность,Истина);
				КонецЦикла;
			КонецЕсли;
                    			
		КонецЕсли;	
				
	КонецЕсли;	
	
КонецПроцедуры // ОчиститьДанныеРегОтчета()

// Процедура очищает данные поля табличного документа формы
// и данные формы в структуре хранения данных регламентированного отчета
// мСписокФормБезИерархии.
//
// Параметры:      Форма - текущая открытая форма отчета
//                 ТекИмяФормы - имя очищаемой формы регламентированного отчета
//                 ОчиститьВсе - признак вида очистки формы
//                               Значение равно "Истина" - очищаются все ячейки формы
//                               Значение равно "Ложь" - очищаются ячейки, не находящиеся в 
//                               списке значений СписокПоказателейНеПодлежащихОчистке.
//                 СписокПоказателейНеПодлежащихОчистке - (тип:СписокЗначений)
//								 список имен областей формы, не подлежащих очистке
//
Процедура ОчиститьСтруктуруДанныхИТабличноеПолеФормы(Форма, ТекИмяФормы, ОчиститьВсе,СписокПоказателейНеПодлежащихОчистке) Экспорт

	Перем СтруктураГруппы;
	
	СтрокаФормы = Форма.мСписокФормБезИерархии.Строки.Найти(ТекИмяФормы,"КодФормы");	
	ТекущаяПанель = Форма.ЭлементыФормы["Панель"+ТекИмяФормы];
	
	Если Не СтрокаФормы.Многострочность = 1 Тогда
		
		ТаблицаДанных = СтрокаФормы.Значение;                 		
		
		Для Каждого Страница Из ТекущаяПанель.Страницы Цикл
			мФормаОтчета = Форма.ЭлементыФормы[ТекИмяФормы+"ПолеТабличногоДокумента" + Страница.Имя];
			Для Инд = 0 По мФормаОтчета.Области.Количество() - 1 Цикл
				ТекущаяОбласть = мФормаОтчета.Области[Инд];

				// Ячейки, не подлежащие очистке
				Если СписокПоказателейНеПодлежащихОчистке.НайтиПоЗначению(ТекущаяОбласть.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Если Не ВРЕГ(Лев(ТекущаяОбласть.Имя,2))= "S_" Тогда
					Если ОчиститьВсе Тогда
						Если Лев(ТекущаяОбласть.Имя,8)= "Страница" Тогда
							Продолжить;
						КонецЕсли;
					Иначе
						Если Лев(ТекущаяОбласть.Имя,8)= "Страница" Или ТекущаяОбласть.Защита Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				Строка = ТаблицаДанных.Найти(ТекущаяОбласть.Имя,"ИмяОбласти");
				Если ТипЗнч(ТекущаяОбласть) = Тип("РисунокТабличногоДокумента") Тогда
					Если Строка <> Неопределено Тогда
						Строка.Значение = "";
					КонецЕсли;
					// если очищаемая форма - это та, которая в данный момент открыта, то очищаем и на форме
					Если Форма.ИмяФормы = ТекИмяФормы Тогда
						ТекущаяОбласть.Значение = "";
					КонецЕсли;
				Иначе
					Если Форма.ИмяФормы = ТекИмяФормы Тогда
						ТекущаяОбласть.Очистить();
					КонецЕсли;
					Если ТекущаяОбласть.СодержитЗначение Тогда
						Если Строка <> Неопределено Тогда
							Строка.Значение = ТекущаяОбласть.Значение;
						КонецЕсли;
					Иначе
						Если Строка <> Неопределено Тогда
							Строка.Значение = ТекущаяОбласть.Текст;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
						
		// ЗаполнитьПараметры() должно осуществляться только после передачи данных в структуру
		Если ОчиститьВсе Тогда 
			Форма.ЗаполнитьПараметры(ТекИмяФормы);
		КонецЕсли;
					
	Иначе                           //Если форма многострочная
		//очищаем структуру из которой берутся данные 	
	 
	 	Для Каждого Страница Из ТекущаяПанель.Страницы Цикл
			ИмяГруппы = Страница.Имя;
			Имя = ТекИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
		 	Форма.ЭлементыФормы[Имя].Очистить();

			мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(ТекИмяФормы,Форма.мСписокФормБезИерархии);
			Если мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы) Тогда
				 ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
				 ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
				 ТаблицаСтрокГруппы.Очистить();			 
				 Для Каждого ОбщийЭлемент Из ОбщиеЭлементыГруппы Цикл
					 ОбщийЭлемент.Значение = Неопределено;
				 КонецЦикла;
		 	КонецЕсли;		 	 
		КонецЦикла;
		
		ТаблицаРасшифровки = ПолучитьТаблицуРасшифровки(ТекИмяФормы,Форма.мСписокФормБезИерархии);
		ТаблицаРасшифровки.Очистить();
		
		Если Форма.ИмяФормы = ТекИмяФормы Тогда
	 		Форма.ТекущаяСтраница = 0;
			Форма.ВсегоСтраниц = 1;
	 		ПоказатьСтраницыМногострочнойФормы(Форма);
		КонецЕсли;
		
	КонецЕсли;
	
	// если форма не главная, то ставим признак Выгружать = 0;
	ВыбраннаяФорма = Форма.мВыбраннаяФорма;
	Если СтрокаФормы.КодФормы <> Лев(ВыбраннаяФорма,СтрДлина(ВыбраннаяФорма)-7) Тогда
		СтрокаФормы.Выгружать = 0;  
	КонецЕсли;
		
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ СВЯЗАННЫЕ С ОБРАБОТКОЙ МНОГОСТРОЧНОЙ ЧАСТИ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

//Процедура выводит в табличные документы области макета
//
//Параметры:
// ИмяГруппы       - Имя текущего табличного документа
// СтруктураГруппы - Тип: ТаблицаЗначений, содержит данные для текущего листа
// Страница        - Номер страницы
//
//Возврат
//   ТабличныйДокумент.
//
Функция ВывестиОбластиВТабличныйДокумент(Форма, ИмяГруппы, СтруктураГруппы, Страница, ВыводитьСтроки = Истина, ТекущееИмяФормы) 
	
	ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
	ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;          
												  
	//вычисляем количество страниц
	КоличествоЗаписей = ТаблицаСтрокГруппы.Количество();
	
	мКоличествоНаЛисте = ПолучитьКоличествоНаЛисте(ТекущееИмяФормы,Форма.мСписокФормБезИерархии);
	 
	Стр =  Цел(КоличествоЗаписей/мКоличествоНаЛисте);
	Если Стр = КоличествоЗаписей/мКоличествоНаЛисте  Тогда
		Форма.ВсегоСтраниц = Стр;
	Иначе
		Форма.ВсегоСтраниц = Стр + 1;
	КонецЕсли;
	 
	Если Страница > Форма.ВсегоСтраниц И Форма.ВсегоСтраниц <> 0 Тогда
		Страница = Форма.ВсегоСтраниц;		 
	КонецЕсли;

	//заполняем области из макета в табличные документы	
	Поле = ТекущееИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
	ТекТабличноеПоле = Форма.ЭлементыФормы[Поле];
 	ТекТабличноеПоле.Очистить();     
	
	ОбластьШапка  = Неопределено;
	ОбластьИтог   = Неопределено;
	ОбластьСтрока = Неопределено;
	ОбластьПодвал = Неопределено;
		
	Макет = Форма.мМакет;
	
	Если Макет.Области.Найти("Шапка" + ТекущееИмяФормы + ИмяГруппы) <> Неопределено Тогда
		ОбластьШапка  = Макет.ПолучитьОбласть("Шапка"  + ТекущееИмяФормы + ИмяГруппы);	 
	КонецЕсли;
	Если Макет.Области.Найти("Итог" + ТекущееИмяФормы + ИмяГруппы) <> Неопределено Тогда
		ОбластьИтог   = Макет.ПолучитьОбласть("Итог"   + ТекущееИмяФормы + ИмяГруппы);	
	КонецЕсли;
	Если Макет.Области.Найти("Строка" + ТекущееИмяФормы + ИмяГруппы) <> Неопределено Тогда
		ОбластьСтрока = Макет.ПолучитьОбласть("Строка" + ТекущееИмяФормы + ИмяГруппы);
	КонецЕсли;
	Если Макет.Области.Найти("Подвал" + ТекущееИмяФормы + ИмяГруппы) <> Неопределено Тогда
		ОбластьПодвал = Макет.ПолучитьОбласть("Подвал" + ТекущееИмяФормы + ИмяГруппы);
	КонецЕсли;
	
	Если ОбластьШапка <> Неопределено Тогда
		СписокПараметровШапки = Новый СписокЗначений;
		Для Каждого Область Из ОбластьШапка.Области Цикл			 
		   	Если Область.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Параметр Тогда
				СписокПараметровШапки.Добавить(Область.Параметр);
			КонецЕсли;
		КонецЦикла;
		Если Найти(СписокПараметровШапки,"Стр")<>0 Тогда
			ОбластьШапка.Параметры.Стр = Страница;
		КонецЕсли;
			 
		ТекТабличноеПоле.Вывести(ОбластьШапка);
	КонецЕсли;
	
	Если ОбластьИтог <> Неопределено Тогда
		 // итог выводиться только на первой странице
		Если Страница = 1 И ВыводитьСтроки Тогда		 
			ТекТабличноеПоле.Вывести(ОбластьИтог);
			ЗаполнитьДанныеИтоговВСтруктуре(ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы);
		КонецЕсли;
	КонецЕсли;
	
	Если ОбластьСтрока <> Неопределено Тогда
		Если ВыводитьСтроки Тогда		 		 
			//вставляем порядковый номер для строки			
			Для Каждого Область Из ОбластьСтрока.Области Цикл			 
				Если Область.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Параметр Тогда
					Если Область.Параметр = "НомерСтроки" Тогда
						НачальноеЗначение = Область.ПараметрРасшифровки;	                	
						Если ЗначениеЗаполнено(НачальноеЗначение) Тогда
							НомерПервойЗаписи = Число(Прав(НачальноеЗначение,1));
						Иначе
						    НомерПервойЗаписи = 2;
						КонецЕсли;
						ИмяКолонки = ТаблицаСтрокГруппы.Колонки[0].Имя; 
			 			НовыйПорядковыйНомер = КоличествоЗаписей + НомерПервойЗаписи - 1;
			 			ТаблицаСтрокГруппы[КоличествоЗаписей - 1][ИмяКолонки] = Формат(НовыйПорядковыйНомер,Форма.мФорматНомераСтроки);						
						Прервать;
					КонецЕсли;					
	          	КонецЕсли;
			КонецЦикла;   			 				

			ТекТабличноеПоле.Вывести(ОбластьСтрока);
		КонецЕсли;
	КонецЕсли;
	
	Если ОбластьПодвал <> Неопределено Тогда
	
		ТекТабличноеПоле.Вывести(ОбластьПодвал);
		
	КонецЕсли;
	 
	// выводим сохраненные значения шапки, итога и подвала из ТЗ в поле табличного документа
	Для Каждого Элемент Из ОбщиеЭлементыГруппы Цикл
		Если ТекТабличноеПоле.Области.Найти(Элемент.ИмяОбласти) <> Неопределено И Элемент.Значение <> Неопределено Тогда 
			ТекОбласть = ТекТабличноеПоле.Области[Элемент.ИмяОбласти];
			Если ТекОбласть.СодержитЗначение Тогда
				ТекОбласть.Значение = Элемент.Значение;
			Иначе
				ТекОбласть.Текст = Элемент.Значение;
			КонецЕсли;
		КонецЕсли;                                                                  		 
	КонецЦикла;
	        	 
	Возврат ТекТабличноеПоле;
	 
КонецФункции // ВывестиОбластиВТабличныйДокумент()

// Процедура выводит строки многострочного раздела в табличный документ.
// При отсутствии в табличном документе необходимого количества строк
// добавляет отсутствующие строки.
//
// Параметры:
//  ИмяГруппы       - строка, имя многострочного раздела;
//  СтруктураГруппы - таблица значений, содержащая значения показателей многострочного раздела.
//
Процедура ВывестиРазделВТабличныйДокументФормы(Форма, Страница, ИмяГруппы, СтруктураГруппы, ТекИмяФормы) Экспорт     
	                                                                                                 
	 ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
	 ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
	 
	 мКоличествоНаЛисте = ПолучитьКоличествоНаЛисте(ТекИмяФормы,Форма.мСписокФормБезИерархии);
		
	 ТекущееКоличество = ТаблицаСтрокГруппы.Количество();                                        
	 Если ТекущееКоличество = 0 Тогда
		  Поле = ТекИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
	 	  ТекТабличноеПоле = Форма.ЭлементыФормы[Поле];
 	 	  ТекТабличноеПоле.Очистить();
		  // ТекТабличноеПоле = ВывестиОбластиВТабличныйДокумент(Форма, ИмяГруппы, СтруктураГруппы,Страница, Ложь,ТекИмяФормы);
		  Возврат;		
	 КонецЕсли;
	 
	 ТекТабличноеПоле = ВывестиОбластиВТабличныйДокумент(Форма, ИмяГруппы, СтруктураГруппы,Страница,,ТекИмяФормы);
	 
	 НомерСтроки       = 1;
	 
	 Если Форма.ВсегоСтраниц = 1  Тогда	//если всего одна страница	
		 ТекущееКоличествоСтрокГруппы = ТаблицаСтрокГруппы.Количество();
		 ИсходноеКоличествоСтрокГруппы = 1;
	 ИначеЕсли Страница = 1 Тогда     //если первая страница из множества
		 ТекущееКоличествоСтрокГруппы = мКоличествоНаЛисте;
		 ИсходноеКоличествоСтрокГруппы = 1;
	 Иначе //все другие страницы, кроме первой			
		 ИсходноеКоличествоСтрокГруппы = Цел((Страница) * мКоличествоНаЛисте) - мКоличествоНаЛисте;
		 КоличествоНаЛисте = Страница * мКоличествоНаЛисте;
		 Если КоличествоНаЛисте < ТекущееКоличество Тогда
			 ТекущееКоличествоСтрокГруппы = КоличествоНаЛисте;
		 Иначе
			 ТекущееКоличествоСтрокГруппы = ТекущееКоличество;
		 КонецЕсли;
	 КонецЕсли;	
	 
	 //если всего строк = 1 на странице, то вставлять новые области не надо
	 //нужно только переименовать их соотвественно со страницей
	 Если мКоличествоНаЛисте = 1 Тогда
		 НомНовойСтроки = Страница;
		 // переопределяем имена вставленной области
		 Для Каждого Колонка Из ТаблицаСтрокГруппы.Колонки Цикл
			 
			 ИмяКолонки          = Колонка.Имя;
			 ИмяОбластиЯчейки    = ИмяКолонки + "__" + 1;
			 ИмяНовОбластиЯчейки = ИмяКолонки + "__" + НомНовойСтроки;
			 
			 ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяОбластиЯчейки];
			 ОбластьЯчейки.Имя = ИмяНовОбластиЯчейки;
			 
			 // очищаем значения ячеек вставленной области
			 Если ОбластьЯчейки.СодержитЗначение Тогда
				 ОбластьЯчейки.Очистить();
			 КонецЕсли;
		 КонецЦикла; 
	 Иначе
		 // Выводим данные, относящиеся к данной странице		
		 Для  НомСтроки = ИсходноеКоличествоСтрокГруппы + 1  По ТекущееКоличествоСтрокГруппы  Цикл
			 
			 НомИсходнойСтроки = НомСтроки - 1;
			 НомНовойСтроки    = НомСтроки;
			 
			 // определяем имя первой ячейки последней из исходных строк
			 ИмяПервойЯчейкиПоследнейСтроки = ТаблицаСтрокГруппы.Колонки[0].Имя + "__" + НомИсходнойСтроки;
			 
			 // область первой ячейки последней из исходных строк
			 Если ТекТабличноеПоле.Области.Найти(ИмяПервойЯчейкиПоследнейСтроки) = Неопределено Тогда
				 ВставитьНовуюСтраницу(ТекТабличноеПоле,ТаблицаСтрокГруппы,1, НомНовойСтроки);
			 Иначе
				 
				 ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяПервойЯчейкиПоследнейСтроки];
				 // номера строк исходной области
				 НомерВерхЯчейкиОбласти = ОбластьЯчейки.Верх;
				 НомерНижнЯчейкиОбласти = ОбластьЯчейки.Низ + 1;
				 
				 СдвигСтрок = НомерНижнЯчейкиОбласти - НомерВерхЯчейкиОбласти + 1;
				 
				 // Строки многострочного раздела должны входят в именованную секцию
				 // для предотвращения вывода на печать пустых строк.
				 // Определим именованую секцию, куда входит добавляемая строка.
				 ИмяПервойЯчейкиПервойСтроки = ТаблицаСтрокГруппы.Колонки[0].Имя + "__" + 1;
				 // область первой ячейки первой строки многострочного раздела
				 ОбластьЯчейки               = ТекТабличноеПоле.Области[ИмяПервойЯчейкиПервойСтроки];
				 // номер первой строки именованной секции
				 НомерВерхЯчейкиСекции       = ОбластьЯчейки.Верх;
				 // область именованной секции
				 ОбластьИменованСекции       = ТекТабличноеПоле.Область(НомерВерхЯчейкиСекции, , НомерНижнЯчейкиОбласти, );
				 ИмяСекции                   = ОбластьИменованСекции.Имя;
				 // предварительно очищаем прежнюю секцию, так как она смещается вниз вместе с добавляемой строкой
				 ОбластьИменованСекции.Имя   = "";
				 
				 // номера строк вставляемой области
				 НомерВерхЯчейкиНовойОбласти = НомерВерхЯчейкиОбласти + СдвигСтрок;
				 НомерНижнЯчейкиНовойОбласти = НомерНижнЯчейкиОбласти + СдвигСтрок;
				 
				 // определяем вставляемую область
				 ВставляемаяОбласть = ТекТабличноеПоле.Область(НомерВерхЯчейкиОбласти, , НомерНижнЯчейкиОбласти, );
				 //ВставляемаяОбласть.Защита = Защита;
				 // добавляем в таблицу новую строку
				 ТекТабличноеПоле.ВставитьОбласть(ВставляемаяОбласть, ,ТипСмещенияТабличногоДокумента.ПоВертикали);
				 // переопределяем имена вставленной области
				 Для Каждого Колонка Из ТаблицаСтрокГруппы.Колонки Цикл
					 
					 ИмяКолонки          = Колонка.Имя;
					 ИмяОбластиЯчейки    = ИмяКолонки + "__" + НомИсходнойСтроки;
					 ИмяНовОбластиЯчейки = ИмяКолонки + "__" + НомНовойСтроки;
					                                      
					 ОбластьЯчейки     = ТекТабличноеПоле.Области[ИмяОбластиЯчейки];
					 ОбластьЯчейки.Имя = ИмяНовОбластиЯчейки;
					 
					 // определяем границы ячейки исходной области
					 НомерВерхСтрокиЯчейки  = ОбластьЯчейки.Верх - СдвигСтрок;
					 НомерНижнСтрокиЯчейки  = ОбластьЯчейки.Низ  - СдвигСтрок;
					 НомерЛевоКолонкиЯчейки = ОбластьЯчейки.Лево;
					 НомерПравКолонкиЯчейки = ОбластьЯчейки.Право;
					 
					 // Назначаем имя ячейки исходной области,
					 // (т.к. в результате вставки новой области оно было очищено)
					 ОбластьЯчейкиИсходнойОбласти = ТекТабличноеПоле.Область(НомерВерхСтрокиЯчейки, НомерЛевоКолонкиЯчейки, НомерНижнСтрокиЯчейки, НомерПравКолонкиЯчейки);
					 ОбластьЯчейкиИсходнойОбласти.Имя = ИмяОбластиЯчейки;
					 
					 // очищаем значения ячеек вставленной области
					 Если ОбластьЯчейки.СодержитЗначение Тогда
						 ОбластьЯчейки.Очистить();
					 КонецЕсли;
				 КонецЦикла;
				 
				 НомерСтроки = НомерСтроки + 1;
			 КонецЕсли;
			 
		 КонецЦикла;
	 КонецЕсли;
 
	 ИндексПоследнейСтрокиНаСтранице = Страница * мКоличествоНаЛисте - 1;
	 ИндексПервойСтрокиНаСтранице = ИндексПоследнейСтрокиНаСтранице - мКоличествоНаЛисте + 1;
	 
	 Если ИндексПоследнейСтрокиНаСтранице > ТаблицаСтрокГруппы.Количество() - 1 Тогда
		   ИндексПоследнейСтрокиНаСтранице = ТаблицаСтрокГруппы.Количество() - 1;
	 КонецЕсли;
	 Для ИндексТекущейСтроки = ИндексПервойСтрокиНаСтранице По ИндексПоследнейСтрокиНаСтранице Цикл
		 СтрокаТаблицы = ТаблицаСтрокГруппы[ИндексТекущейСтроки];

		 Для Каждого КолонкаТаблицы Из ТаблицаСтрокГруппы.Колонки Цикл
			 
			 НомерСтрокиВТаблице      = ТаблицаСтрокГруппы.Индекс(СтрокаТаблицы);
			 НомерСтрокиВФормеТаблицы = НомерСтрокиВТаблице + 1 ;
			 ИмяЯчейки                = КолонкаТаблицы.Имя + "__" + НомерСтрокиВФормеТаблицы;
			 Если  ТекТабличноеПоле.Области.Найти(ИмяЯчейки) <> Неопределено Тогда
				 ОбластьЯчейкиТаблицы = ТекТабличноеПоле.Области[ИмяЯчейки];
			 Иначе
				 Продолжить;
			 КонецЕсли;
			 
			 ЗначениеЯчейки           = СтрокаТаблицы[КолонкаТаблицы.Имя];
			 
			 Если ОбластьЯчейкиТаблицы.СодержитЗначение Тогда
				 // задаем значение ячейки
				 ОбластьЯчейкиТаблицы.Значение = ЗначениеЯчейки;
			 Иначе
				 // задаем текст для ячейки
				 ОбластьЯчейкиТаблицы.Текст    = ЗначениеЯчейки;
			 КонецЕсли;
			 
			 ОбластьЯчейкиТаблицы.Защита = Истина;
			
		 КонецЦикла;
	 КонецЦикла;
	 
 КонецПроцедуры // ВывестиРазделВТабличныйДокумент()
 
 //Процедура  заполняет итоговые данные  табличного документа
//
//Параметры:
//  ТаблицаСтрокГруппы - Тип: ТаблицаЗначений, по данным которой
//                    вычисляються итоговые данные
//  ОбщиеЭлементыГруппы - Тип: ТаблицаЗначений, куда записываются итоговые данные
//                        в строки, где в колонке "Итог" значение строки равно Истина
//
Процедура ЗаполнитьДанныеИтоговВСтруктуре(ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы) 
	
	Отбор = Новый Структура();
	Отбор.Вставить("Итог",Истина);
	СтрокиИтоговыхЯчеек = ОбщиеЭлементыГруппы.НайтиСтроки(Отбор);
	Для Каждого Строка Из СтрокиИтоговыхЯчеек Цикл
		ТекЗначение = Строка.ИмяОбласти;
		Если ТаблицаСтрокГруппы.Колонки.Найти(ТекЗначение) <> Неопределено Тогда
		    Строка.Значение = ТаблицаСтрокГруппы.Итог(ТекЗначение);
		КонецЕсли;                                		
	КонецЦикла;
	 
КонецПроцедуры //ЗаполнитьДанныеИтоговВСтруктуре()

Процедура ВставитьНовуюСтраницу(ТекТабличноеПоле, СтруктураГруппы, НомИсходнойСтроки, НомНовойСтроки)
	 
	 // переопределяем имена вставленной области
	 
	 ИмяПервойЯчейкиПоследнейСтроки = СтруктураГруппы.Колонки[0].Имя + "__" + НомИсходнойСтроки;
	 ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяПервойЯчейкиПоследнейСтроки]; 
	 НомерВерхЯчейкиОбласти = ОбластьЯчейки.Верх;
	 НомерНижнЯчейкиОбласти = ОбластьЯчейки.Низ + 1;
	 СдвигСтрок = НомерНижнЯчейкиОбласти - НомерВерхЯчейкиОбласти + 1;
	 
	 Для Каждого Колонка Из СтруктураГруппы.Колонки Цикл
		 
		 ИмяКолонки          = Колонка.Имя;
		 ИмяОбластиЯчейки    = ИмяКолонки + "__" + НомИсходнойСтроки;
		 ИмяНовОбластиЯчейки = ИмяКолонки + "__" + НомНовойСтроки;
		 
		 ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяОбластиЯчейки];
		 ОбластьЯчейки.Имя = ИмяНовОбластиЯчейки;
		 
		 // определяем границы ячейки исходной области
		 НомерВерхСтрокиЯчейки  = ОбластьЯчейки.Верх - СдвигСтрок;
		 НомерНижнСтрокиЯчейки  = ОбластьЯчейки.Низ  - СдвигСтрок;
		 НомерЛевоКолонкиЯчейки = ОбластьЯчейки.Лево;
		 НомерПравКолонкиЯчейки = ОбластьЯчейки.Право;
		 
		 // Назначаем имя ячейки исходной области,
		 // (т.к. в результате вставки новой области оно было очищено)
		 ОбластьЯчейкиИсходнойОбласти = ТекТабличноеПоле.Область(НомерВерхСтрокиЯчейки, НомерЛевоКолонкиЯчейки, НомерНижнСтрокиЯчейки, НомерПравКолонкиЯчейки);
		 ОбластьЯчейкиИсходнойОбласти.Имя = ИмяОбластиЯчейки;
		 
		 Если ОбластьЯчейки.СодержитЗначение Тогда
			 ОбластьЯчейки.Очистить();					
		 КонецЕсли; 		
	 КонецЦикла;
	 
 КонецПроцедуры // ВставитьНовуюСтраницу()
 
 //Процедура инициализирует текущую страницу
//Параметры:
//     Порядок - управляет порядком обхода страница
//     может принимать значения "+1" - вверх по страницам
//                              "-1" - вниз по страницам
//
Процедура ВывестиСтраницуМногострочнойФормы(Форма) Экспорт
	
	Если Форма.ПризнакМногострочности Тогда
			
		ПередатьДанныеИзСтруктурыВТабличноеПоле(Форма);
		ПоказатьСтраницыМногострочнойФормы(Форма); 
		
	КонецЕсли;
	                      		
КонецПроцедуры   //ВывестиСтраницуМногострочнойФормы()

 // Создает новую строку многострочной формы.
//
Процедура ДобавитьСтрокуМногострочнойФормы(Форма) Экспорт
	 
	 Перем СтруктураГруппы;
	 
	 ТекущееИмяФормы = Форма.ИмяФормы;
	 
	 СтраницыПанели = Форма.ЭлементыФормы["Панель" + ТекущееИмяФормы].Страницы;	
	 Для Каждого Страница Из СтраницыПанели Цикл
		 
		 ИмяГруппы = Страница.Имя;
		 мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(ТекущееИмяФормы,Форма.мСписокФормБезИерархии);
		 мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы);
		 ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
		 ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
		 Строка = ТаблицаСтрокГруппы.Добавить();
				 
		 //если мы добавили первую строку и в шапке не содержится данных
		 //Если ТаблицаСтрокГруппы.Количество() = 1 Тогда
		 	// Заполним шапку и подвал текущего листа
		 	Форма.ЗаполнитьПараметры(ТекущееИмяФормы);
		 //Иначе // сохраняем шапку и подвал текущего листа
		 //	Поле = ТекущееИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
		 //	Поле = Форма.ЭлементыФормы[Поле];
		 //	Для Каждого Область Из Поле.Области Цикл
		 //   	 Строка = ОбщиеЭлементыГруппы.Найти(Область.Имя,"ИмяОбласти");
		 //   	 Если Строка <> Неопределено Тогда
		 //   		 Если Область.СодержитЗначение Тогда
		 //   		 	Строка.Значение = Область.Значение;
		 //   		 Иначе
		 //   			Строка.Значение = Область.Текст;
		 //   		 КонецЕсли;				 
		 //   	 КонецЕсли;
		 //	КонецЦикла;
			 // перенесем итоговые данные в ТЗ
			 ЗаполнитьДанныеИтоговВСтруктуре(ТаблицаСтрокГруппы,ОбщиеЭлементыГруппы); 			 
		 //КонецЕсли;
		 
		 ВывестиРазделВТабличныйДокументФормы(Форма, Форма.ВсегоСтраниц, ИмяГруппы, СтруктураГруппы, ТекущееИмяФормы);
		 
	 КонецЦикла; 	
	 Форма.ТекущаяСтраница = Форма.ВсегоСтраниц;
	 ПоказатьСтраницыМногострочнойФормы(Форма);
	 Форма.Модифицированность = Истина;	
	 
КонецПроцедуры  //ВставитьСтроку()

// Процедура удаляет строку из многострочной части
//
Процедура УдалитьСтрокуМногострочнойФормы(Форма) Экспорт
	
	Перем СтруктураГруппы;
	
	ИмяФормы = Форма.ИмяФормы;
	мСписокФормБезИерархии = Форма.мСписокФормБезИерархии;
	ТекущаяПанель = Форма.ЭлементыФормы["Панель" + ИмяФормы];	
	ТекСтраница  = ТекущаяПанель.ТекущаяСтраница;
	 
	 	 	 
	мКоличествоНаЛисте = ПолучитьКоличествоНаЛисте(ИмяФормы, мСписокФормБезИерархии);  
	мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(ИмяФормы, мСписокФормБезИерархии);
	ТаблицаРасшифровки = ПолучитьТаблицуРасшифровки(ИмяФормы, мСписокФормБезИерархии); 
	мМногострочнаяСтруктура.Свойство(ТекСтраница.Имя, СтруктураГруппы);
	ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
	ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
			 
	Если мКоличествоНаЛисте > 1 Тогда
		ИмяПоля = ИмяФормы + "ПолеТабличногоДокумента" + ТекСтраница.Имя;
	 	ТекОбласть = Форма.ЭлементыФормы[ИмяПоля].ТекущаяОбласть;
		 
		Если Найти(ТекОбласть.Имя, "__") <> 0 Тогда
			 
			НомерСтроки = Сред(ТекОбласть.Имя, Найти(ТекОбласть.Имя, "__") + 2);
			
			Попытка
				ПерваяСтрока 		   = ТаблицаСтрокГруппы.Получить(0); 
				НомерДляУдаленияСтроки = Число(ПерваяСтрока[0]);
				
				Если НомерДляУдаленияСтроки = 3 Тогда 
					НомерДляУдаленияСтроки = 2;
				ИначеЕсли НомерДляУдаленияСтроки = 2 Тогда  
					НомерДляУдаленияСтроки = 1;
				Иначе 
					НомерДляУдаленияСтроки = 1;
				КонецЕсли;
				
			Исключение
				НомерДляУдаленияСтроки = 1;
			КонецПопытки;

			Номер = Формат(Число(НомерСтроки) + НомерДляУдаленияСтроки,  Форма.мФорматНомераСтроки);
			Строка = ТаблицаСтрокГруппы.Найти(Номер);
			Если Строка <> Неопределено Тогда
				ИндексСтроки = ТаблицаСтрокГруппы.Индекс(Строка) ; 
			Иначе
				Возврат;
			КонецЕсли;
			 
			//перезаполним таблицу расшифровки
			ПерезаполнитьТаблицуРасшифровкиФормы(ТаблицаРасшифровки, НомерСтроки);
			 
			Для Каждого Страница Из ТекущаяПанель.Страницы Цикл                 		 
				ИмяГруппы = Страница.Имя;
				мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы);
				ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
	 			ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
				СтрокаГруппы = ТаблицаСтрокГруппы.Получить(ИндексСтроки);
				
				Попытка
					ПерваяСтрока = ТаблицаСтрокГруппы.Получить(0); 
					НомерСтроки  = Число(ПерваяСтрока[0]);
				Исключение
					НомерСтроки = 2;
				КонецПопытки;

				ТаблицаСтрокГруппы.Удалить(СтрокаГруппы); 
				
				Для Каждого Элемент Из ТаблицаСтрокГруппы Цикл
					Элемент[0] = Формат(НомерСтроки, Форма.мФорматНомераСтроки);
					НомерСтроки = НомерСтроки + 1;				  
				КонецЦикла;
				//если удалены все данные с листа
				//то продолжаем выполнение процедуры
				Если ТаблицаСтрокГруппы.Количество() = 0 Тогда
					// очистим значения шапки (подвала) в Таблице значений
					Для Каждого Элемент Из ОбщиеЭлементыГруппы Цикл
						Элемент.Значение = Неопределено;						 
					КонецЦикла;
					Форма.ТекущаяСтраница = 0;
					Форма.ВсегоСтраниц = 0;
				Иначе
					// перенесем итоговые данные в ТЗ
					ЗаполнитьДанныеИтоговВСтруктуре(ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы); 			 
				КонецЕсли; 			  
				ВывестиРазделВТабличныйДокументФормы(Форма, Форма.ТекущаяСтраница, ИмяГруппы, СтруктураГруппы, ИмяФормы);
			КонецЦикла; 	
		Иначе
			Сообщить("Удаление невозможно, не выбрана строка многострочной части формы!", СтатусСообщения.Важное);
		КонецЕсли;
		 
		Если Форма.ТекущаяСтраница > Форма.ВсегоСтраниц И Форма.ВсегоСтраниц <> 0 Тогда
		 	Форма.ТекущаяСтраница = Форма.ВсегоСтраниц;
	  	КонецЕсли;
	  
	Иначе // если на листе 1 страница, то удаляем страницу
		 
		НомерСтроки = Форма.ТекущаяСтраница -1;
		Если ТаблицаСтрокГруппы.Количество() < Форма.ТекущаяСтраница Тогда
			Возврат;
		КонецЕсли;
		
		Если ТаблицаСтрокГруппы.Количество() = 0 Тогда
		 	Возврат;
		КонецЕсли;
		
		Строка = ТаблицаСтрокГруппы[НомерСтроки];
		Если Строка <> Неопределено Тогда
			 ИндексСтроки = ТаблицаСтрокГруппы.Индекс(Строка) ; 
		Иначе
			 Возврат;
		КонецЕсли;
		 
		//перезаполним таблицу расшифровки
		ПерезаполнитьТаблицуРасшифровкиФормы(ТаблицаРасшифровки, НомерСтроки + 1);
		 
		Для Каждого Страница Из ТекущаяПанель.Страницы Цикл                 		 
			 ИмяГруппы = Страница.Имя;
			 мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы);
			 ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
	 		 ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
 			
			 СтрокаГруппы = ТаблицаСтрокГруппы.Получить(ИндексСтроки);
			 ТаблицаСтрокГруппы.Удалить(СтрокаГруппы); 
				 
			 //если удалены все данные с листа
			 //то продолжаем выполнение процедуры
			 Если ТаблицаСтрокГруппы.Количество() = 0 Тогда
				  // очистим значения шапки (подвала) в Таблице значений
				  Для Каждого Элемент Из ОбщиеЭлементыГруппы Цикл
					 Элемент.Значение = Неопределено;						 
				  КонецЦикла;
				  Форма.ТекущаяСтраница = 0;
				  Форма.ВсегоСтраниц = 0;
			  Иначе
				  // перенесем итоговые данные в ТЗ
				  ЗаполнитьДанныеИтоговВСтруктуре(ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы); 			 
			  КонецЕсли; 
			  ВывестиРазделВТабличныйДокументФормы(Форма, Форма.ТекущаяСтраница, ИмяГруппы, СтруктураГруппы, ИмяФормы);
		 КонецЦикла;
	  
	КонецЕсли;
	      	 	
	ПоказатьСтраницыМногострочнойФормы(Форма);
	Форма.Модифицированность = Истина;   

КонецПроцедуры // УдалитьСтрокуМногострочнойФормы()

// Обновляет структуру многострочных частей формы.
// Заполняет таблицу значений значениями соответствующих ячеек.
//
//Параметры:
//  ИмяГруппы          - строка, имя текущего табличного поля
//  ИмяПоказателя      - строка, имя именованнй ячейки
//  ЗначениеПоказателя - значение, которое было изменено в данной ячейки и его нужно
//                       перезаписать в структуру
//
Процедура ОбновитьМногострочнуюСтруктуруФормы(Форма, ИмяГруппы, ИмяПоказателя, ЗначениеПоказателя, Расчет = Ложь) Экспорт
	
	Перем СтруктураГруппы;
	
	ИмяФормы = Форма.ИмяФормы;
	мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(ИмяФормы, Форма.мСписокФормБезИерархии);
	мМногострочнаяСтруктура.Свойство(ИмяГруппы,СтруктураГруппы);
	ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
	ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
	
	// Определим показатель ли это шапки(подвала) или многострочной части
	НайденнаяСтрока = ОбщиеЭлементыГруппы.Найти(ИмяПоказателя,"ИмяОбласти");
	Если НайденнаяСтрока <> Неопределено Тогда // это шапка, сохраняем значение
		НайденнаяСтрока.Значение = ЗначениеПоказателя;
		Если Расчет Тогда  			 
			Форма.ВыборРасчета(ИмяФормы, 0, ИмяПоказателя);						 
		КонецЕсли;
	Иначе
	 	Инд = Сред(ИмяПоказателя, Найти(ИмяПоказателя, "__")+2);
		Индекс = Инд-1;
		Колонка = Лев(ИмяПоказателя, СтрДлина(ИмяПоказателя) - (СтрДлина(Инд) + 2));
	  
	 	Строка = ТаблицаСтрокГруппы.Получить(Индекс);
		//Заносим новое значение в структуру группы
		Строка[Колонка] = ЗначениеПоказателя;
		
		Если Расчет Тогда 
			 
			Форма.ВыборРасчета(ИмяФормы, Инд, Колонка);
						 
		КонецЕсли;
				
		ИмяТПоле = ИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
		ТПоле = Форма.ЭлементыФормы[ИмяТПоле];
	 	Если тПоле.Области.Найти(Колонка) <> Неопределено Тогда 
			тПоле.Области[Колонка].Значение = ТаблицаСтрокГруппы.Итог(Колонка);				
	 	КонецЕсли;
	 
		//Заносим итоговое значение в общие элементы группы
		Для Каждого Группа Из мМногострочнаяСтруктура Цикл
			СтруктураГруппы     = Группа.Значение;
			ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
			ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
			ЗаполнитьДанныеИтоговВСтруктуре(ТаблицаСтрокГруппы,ОбщиеЭлементыГруппы);
		КонецЦикла;                                                                 	
		
	КонецЕсли;
	
	Форма.Модифицированность = Истина;
	 
КонецПроцедуры  //ОбновитьМногострочнуюСтруктуруФормы()
 
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТРУКТУРОЙ ХРАНЕНИЯ ДАННЫХ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

// Процедура перезаполняет сохраненную общую структуру хранения данных
// а именно мСписокФормБезИерархии, храняющуюся в структуре СписокСохранения.
//
// Параметры: Объект - объект отчет
//            СписокСохранения - структура, хранящая сохраненные данные отчета
//
Процедура ПерезаполнитьСохраненнуюСтруктуруФормРегОтчета(Объект, СписокСохранения) Экспорт

	СписокФормБезИерархии = Неопределено;
	СписокСохранения.Свойство("ПоказателиОтчета", СписокФормБезИерархии);
	
	Если СписокФормБезИерархии <> Неопределено И ТипЗнч(СписокФормБезИерархии) = Тип("ДеревоЗначений") Тогда
		
		Для Каждого Строка Из Объект.мСписокФормБезИерархии.Строки Цикл
			СтрокаИсточник = СписокФормБезИерархии.Строки.Найти(Строка.КодФормы,"КодФормы");
			Если СтрокаИсточник <> Неопределено Тогда
				Строка.Автозаполнение = СтрокаИсточник.Автозаполнение;
				Строка.АвтополучениеИтогов = СтрокаИсточник.АвтополучениеИтогов;
				Строка.Выгружать = СтрокаИсточник.Выгружать;
				Строка.ПоказатьСтраницу = СтрокаИсточник.ПоказатьСтраницу;
				//Перенесем сохраненные значения в дерево значений
				ЗначениеСтроки = Строка.Значение;
				ЗначениеИсточника = СтрокаИсточник.Значение;
				Если Строка.Многострочность = 1 Тогда
					ДанныеСтроки = ЗначениеСтроки[0].Данные;					
					ДанныеСтрокиИсточника = ЗначениеИсточника[0].Данные;
					ТаблицаРасшифровкиСтрокиИсточника = ЗначениеИсточника[0].ТаблицаРасшифровки;
					// данные (структура)
					Для Каждого Элемент Из ДанныеСтроки Цикл
						КлючЛиста = Элемент.Ключ;
						ЗначениеЛиста = Элемент.Значение;
						//найдем по ключу сохраненные данные для данного листа многостр.формы
						Если ДанныеСтрокиИсточника.Свойство(КлючЛиста) Тогда
							ЗначениеЛистаИсточника = Неопределено; // также тип "Структура"
							ДанныеСтрокиИсточника.Свойство(КлючЛиста,ЗначениеЛистаИсточника);
							СтрокиЛистаИсточника = ЗначениеЛистаИсточника.Строки; // тип "ТаблицаЗначений"
							ШапкаИПодвалЛистаИсточника = ЗначениеЛистаИсточника.ШапкаИПодвал; // тип "ТаблицаЗначений"
							
							// перенесем сохраненные данные по листу
							// заменим СТРОКИ многострочной формы данного листа сохраненными данными
							ЗначениеЛиста.Строки = СтрокиЛистаИсточника;
							
							// заменим ШАПКАиПОДВАЛ многострочной формы данного листа сохраненными данными
							Для Каждого СтрокаШапки Из ЗначениеЛиста.ШапкаИПодвал Цикл
								// ищем сохраненное значение в таблице ШапкаИПодвалЛистаИсточника
								НайденнаяСтрокаШапки = ШапкаИПодвалЛистаИсточника.Найти(СтрокаШапки.ИмяОбласти,"ИмяОбласти");
								Если НайденнаяСтрокаШапки <> Неопределено Тогда
									СтрокаШапки.Значение = НайденнаяСтрокаШапки.Значение;							
								КонецЕсли;                  							
							КонецЦикла;
						
						КонецЕсли;
					КонецЦикла;
					
					// таблица расшифровки (таблица значений)
					ЗначениеСтроки[0].ТаблицаРасшифровки = ТаблицаРасшифровкиСтрокиИсточника.Скопировать();
					               				
				Иначе // форма обычная
					ЗначениеИсточника.Индексы.Добавить("ИмяОбласти");
					Для Каждого СтрокаТаблицы Из ЗначениеСтроки Цикл
						// ищем сохраненное значение в таблице ЗначениеИсточника
						НайденнаяСтрока = ЗначениеИсточника.Найти(СтрокаТаблицы.ИмяОбласти,"ИмяОбласти");
						Если НайденнаяСтрока <> Неопределено Тогда
							СтрокаТаблицы.Значение = НайденнаяСтрока.Значение;							
						КонецЕсли;
					КонецЦикла;					
				КонецЕсли;			
			КонецЕсли;    	
		КонецЦикла;
		
		СписокСохранения.Вставить("ПоказателиОтчета", Объект.мСписокФормБезИерархии.Скопировать());
		Если Объект.мСохраненныйДок <> Неопределено Тогда						
			ХранилищеДанных = Новый ХранилищеЗначения(СписокСохранения);
			Объект.мСохраненныйДок.ДанныеОтчета = ХранилищеДанных;
		КонецЕсли;
		
	КонецЕсли;              
		
КонецПроцедуры // ПерезаполнитьСохраненнуюСтруктуруФормРегОтчета()

// Процедура создает общую структуру хранения данных
// 
// Параметры: Объект - объект регламентированного отчета
//
Процедура ЗаполнитьСтруктуруФормРегОтчета(Объект) Экспорт
	
	СписокФормБезИерархии = Объект.СписокФормДерева.Скопировать();
	СписокФормБезИерархии.Строки.Очистить();
	мВыбраннаяФорма = Объект.мВыбраннаяФорма;
	
	ЗаполнитьДеревоСтраниц(Объект);
	
	ЗаполнитьТаблицуПередачиДанных(Объект);
	
	//также создадим дерево значений  без иерархии, для выгрузки данных
	//и отображения в форме настройки страниц
	
	Для Каждого Строка Из Объект.СписокФормДерева.Строки Цикл                
		НоваяСтрока = СписокФормБезИерархии.Строки.Добавить();       
		НоваяСтрока.КодФормы            = Строка.КодФормы;
		НоваяСтрока.ПоказатьСтраницу    = Строка.ПоказатьСтраницу;
		НоваяСтрока.Выгружать           = Строка.Выгружать;
		НоваяСтрока.АвтополучениеИтогов = Строка.АвтополучениеИтогов;  
		НоваяСтрока.АвтоЗаполнение      = Строка.АвтоЗаполнение;  
		НоваяСтрока.Страницы            = Строка.Страницы;
		НоваяСтрока.ИмяФормы            = Строка.ИмяФормы;
		НоваяСтрока.Многострочность     = Строка.Многострочность;
		НоваяСтрока.КоличествоНаЛисте   = Строка.КоличествоНаЛисте; 
		НоваяСтрока.ОриентацияСтр       = Строка.ОриентацияСтр; 
		НоваяСтрока.ПризнакОсновной     = Строка.ПризнакОсновной; 
		НоваяСтрока.ЗаголовокФормы      = Строка.ЗаголовокФормы;  		
		Если Строка.Строки.Количество() > 0 Тогда
			Для Каждого ПодчиненнаяСтрока Из Строка.Строки Цикл
				НоваяСтрока = СписокФормБезИерархии.Строки.Добавить();
				НоваяСтрока.КодФормы            = ПодчиненнаяСтрока.КодФормы;
				НоваяСтрока.ПоказатьСтраницу    = ПодчиненнаяСтрока.ПоказатьСтраницу;
				НоваяСтрока.Выгружать           = ПодчиненнаяСтрока.Выгружать;
				НоваяСтрока.АвтополучениеИтогов = ПодчиненнаяСтрока.АвтополучениеИтогов;  
				НоваяСтрока.АвтоЗаполнение      = ПодчиненнаяСтрока.АвтоЗаполнение;  
				НоваяСтрока.Страницы            = ПодчиненнаяСтрока.Страницы;
				НоваяСтрока.ИмяФормы            = ПодчиненнаяСтрока.ИмяФормы;
				НоваяСтрока.Многострочность     = ПодчиненнаяСтрока.Многострочность;				
				НоваяСтрока.КоличествоНаЛисте   = ПодчиненнаяСтрока.КоличествоНаЛисте;				
				НоваяСтрока.ОриентацияСтр       = ПодчиненнаяСтрока.ОриентацияСтр; 
				НоваяСтрока.ПризнакОсновной     = ПодчиненнаяСтрока.ПризнакОсновной;
				НоваяСтрока.ЗаголовокФормы      = ПодчиненнаяСтрока.ЗаголовокФормы;
				Если ПодчиненнаяСтрока.Строки.Количество() > 0 Тогда
					Для Каждого ПодчиненнаяСтрока2 Из ПодчиненнаяСтрока.Строки Цикл
						НоваяСтрока = СписокФормБезИерархии.Строки.Добавить();
						НоваяСтрока.КодФормы            = ПодчиненнаяСтрока2.КодФормы;
						НоваяСтрока.ПоказатьСтраницу    = ПодчиненнаяСтрока2.ПоказатьСтраницу;
						НоваяСтрока.Выгружать           = ПодчиненнаяСтрока2.Выгружать;
						НоваяСтрока.АвтополучениеИтогов = ПодчиненнаяСтрока2.АвтополучениеИтогов; 
						НоваяСтрока.АвтоЗаполнение      = ПодчиненнаяСтрока2.АвтоЗаполнение; 
						НоваяСтрока.Страницы            = ПодчиненнаяСтрока2.Страницы;
						НоваяСтрока.ИмяФормы            = ПодчиненнаяСтрока2.ИмяФормы;
						НоваяСтрока.Многострочность     = ПодчиненнаяСтрока2.Многострочность;
						НоваяСтрока.КоличествоНаЛисте   = ПодчиненнаяСтрока2.КоличествоНаЛисте;
						НоваяСтрока.ОриентацияСтр       = ПодчиненнаяСтрока2.ОриентацияСтр; 
						НоваяСтрока.ПризнакОсновной     = ПодчиненнаяСтрока2.ПризнакОсновной;
						НоваяСтрока.ЗаголовокФормы      = ПодчиненнаяСтрока2.ЗаголовокФормы;
					КонецЦикла; 
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;
	КонецЦикла; 
	
	ФормаПериода = Объект.ПолучитьФорму(мВыбраннаяФорма);
	// заполним структуру значений для всех заполняемых форм из макетов
	Попытка 
		Макет = Объект.ПолучитьМакет("Макет"+мВыбраннаяФорма);    
	Исключение
		Макет = Неопределено; // для форм, в которых нет многострочных форм, в них не создаются макеты
	КонецПопытки;
	Объект.мМакет = Макет;
	Для Каждого Форма Из СписокФормБезИерархии.Строки Цикл
		    		
		Если Форма.Многострочность = 1 Тогда
			ТекСтраница = Форма.КодФормы;
			// формируем многострочную структуру и записываем в "Значение" данной формы
			МногСтруктура = ФормированиеСтруктурыМногострочнойФормы(ТекСтраница,ФормаПериода,Макет);
			ТаблицаРасшифровки = Новый ТаблицаЗначений;         
			ТаблицаРасшифровки.Колонки.Добавить("ИмяГруппы");   
			ТаблицаРасшифровки.Колонки.Добавить("ИмяЯчейки");   
			ТаблицаРасшифровки.Колонки.Добавить("ПолеПоиска");  
			ТаблицаРасшифровки.Колонки.Добавить("НомерСтроки");
			ТаблицаРасшифровки.Индексы.Добавить("НомерСтроки");
			ТаблицаРасшифровки.Индексы.Добавить("ИмяЯчейки");
			ТаблицаДанных = Новый ТаблицаЗначений;
			ТаблицаДанных.Колонки.Добавить("Данные");
			ТаблицаДанных.Колонки.Добавить("ТаблицаРасшифровки");
			Строка = ТаблицаДанных.Добавить();
			Строка.Данные = МногСтруктура;
			Строка.ТаблицаРасшифровки = ТаблицаРасшифровки;
			Форма.Значение = ТаблицаДанных;
			Если МногСтруктура = Неопределено Тогда
				Сообщить("Для формы " + Форма.КодФормы + " не сформирована структура хранения данных");
			КонецЕсли;
		Иначе
			Если ФормаПериода.ЭлементыФормы.Найти("Панель" + Форма.КодФормы) = Неопределено Тогда
				Сообщить("Для формы " + Форма.КодФормы + " не сформирована структура хранения данных");
			Иначе    
				ТаблицаИмен = Новый ТаблицаЗначений;
				ТаблицаИмен.Колонки.Добавить("ИмяОбласти");
				ТаблицаИмен.Колонки.Добавить("Значение");
				ТаблицаИмен.Индексы.Добавить("ИмяОбласти");
				Для Каждого Страница Из ФормаПериода.ЭлементыФормы["Панель" + Форма.КодФормы].Страницы Цикл
					Если ФормаПериода.ЭлементыФормы.Найти(Форма.КодФормы + "ПолеТабличногоДокумента" + Страница.Имя) = Неопределено Тогда
						Сообщить("Для формы " + Форма.КодФОрмы + " не сформирована структура хранения данных");
						Прервать;
					Иначе
						ТекПоле = ФормаПериода.ЭлементыФормы[Форма.КодФормы + "ПолеТабличногоДокумента" + Страница.Имя];
						Для Каждого Область Из ТекПоле.Области Цикл
							Если Лев(Врег(Область.Имя),8) = Врег("Страница") Тогда
								Продолжить;
							КонецЕсли;
							// проверяем добавлялась ли строка ранее с таким же названием области
							СуществующаяСтрока = ТаблицаИмен.Найти(Область.Имя,"ИмяОбласти");
							Если СуществующаяСтрока = Неопределено Тогда
								Строка = ТаблицаИмен.Добавить();
								Строка.ИмяОбласти = Область.Имя;					
								Если Область.СодержитЗначение Тогда
									Строка.Значение = Область.Значение;
								Иначе
									Строка.Значение = Область.Текст;
								КонецЕсли;
							//Иначе
							//	Сообщить("Для формы """ + Форма.КодФормы + """ имеются области с одинаковым названием");
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;   				
				Форма.Значение = ТаблицаИмен;				
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;	
	
	Объект.мСписокФормБезИерархии = СписокФормБезИерархии;
	
КонецПроцедуры

//Процедура заполняет дерево значений списком форм данного приложения
// 
// Параметры: Объект - объект регламентированного отчета
// 
Процедура ЗаполнитьДеревоСтраниц(Объект)
	
	Префикс = Прав(Объект.мВыбраннаяФорма, 7);
	
	СписокФорм = Объект.СписокФормДерева;
	//очищаем все данные
	СписокФорм.Строки.Очистить();
		
	ТаблицаУпорядочивания = Новый ТаблицаЗначений;
	ТаблицаУпорядочивания.Колонки.Добавить("Страницы");                     
	ТаблицаУпорядочивания.Колонки.Добавить("КодФормы");
	ТаблицаУпорядочивания.Колонки.Добавить("ИмяФормы");
	ТаблицаУпорядочивания.Колонки.Добавить("ПоказатьСтраницу");
	ТаблицаУпорядочивания.Колонки.Добавить("Выгружать");
	ТаблицаУпорядочивания.Колонки.Добавить("Многострочность");
	ТаблицаУпорядочивания.Колонки.Добавить("ПризнакОсновной");
	ТаблицаУпорядочивания.Колонки.Добавить("ЗаголовокФормы");   
	ТаблицаУпорядочивания.Колонки.Добавить("АвтополучениеИтогов");  
	ТаблицаУпорядочивания.Колонки.Добавить("АвтоЗаполнение");  
	ТаблицаУпорядочивания.Колонки.Добавить("КоличествоНаЛисте");  
	ТаблицаУпорядочивания.Колонки.Добавить("ОриентацияСтр");  
	ТаблицаУпорядочивания.Колонки.Добавить("Верх"); 
	ТаблицаУпорядочивания.Колонки.Добавить("ФормаРодитель"); 
		
	Макет = Объект.ПолучитьМакет("Показатели");
	                                                            	
	Для  НомерОбласти = 0 По  Макет.Области.Количество() -1 Цикл
		Область = Макет.Области[НомерОбласти];
		
		Если Прав(Область.Имя,7) = Префикс Тогда
			
			ИмяФормыXML      	= СокрП(Макет.Область(Область.Верх, 1).Текст);
			ИмяСтраницы      	= СокрП(Макет.Область(Область.Верх, 2).Текст);
			ПоказатьСтраницу 	= СокрП(Макет.Область(Область.Верх, 3).Текст);
			Выгружать        	= СокрП(Макет.Область(Область.Верх, 4).Текст);
			Признакосновной  	= СокрП(Макет.Область(Область.Верх, 5).Текст);
			Многострочность  	= СокрП(Макет.Область(Область.Верх, 6).Текст);
			КодФормы        	= СокрП(Макет.Область(Область.Верх, 7).Текст);
			ФормаРодитель    	= СокрП(Макет.Область(Область.Верх, 8).Текст);  
			ЗаголовокФормы      = СокрП(Макет.Область(Область.Верх, 9).Текст);  
			КоличествоНаЛисте   = СокрП(Макет.Область(Область.Верх, 10).Текст);  		
			ОриентацияСтр       = СокрП(Макет.Область(Область.Верх, 11).Текст);  
		
			НоваяСтрока = ТаблицаУпорядочивания.Добавить();
			НоваяСтрока.Верх = Область.Верх;	
			НоваяСтрока.ИмяФормы            = ИмяФормыXML;
			НоваяСтрока.КодФормы            = КодФормы;
			НоваяСтрока.Страницы            = ИмяСтраницы;
			НоваяСтрока.Многострочность     = Многострочность;
			НоваяСтрока.Выгружать           = Выгружать;
			НоваяСтрока.Признакосновной     = ПризнакОсновной;
			НоваяСтрока.ПоказатьСтраницу    = ПоказатьСтраницу;	
			НоваяСтрока.ФормаРодитель       = ФормаРодитель;	
			НоваяСтрока.ЗаголовокФормы      = ЗаголовокФормы;  
			НоваяСтрока.АвтополучениеИтогов = 1;           
			НоваяСтрока.АвтоЗаполнение      = 1;           
			НоваяСтрока.КоличествоНаЛисте   = КоличествоНаЛисте;           
			НоваяСтрока.ОриентацияСтр       = ОриентацияСтр;           
		КонецЕсли;
	КонецЦикла;  	
	ТаблицаУпорядочивания.Сортировать("Верх");
	Для Каждого СтрокаТаблицы ИЗ ТаблицаУпорядочивания Цикл
		
		Если СтрокаТаблицы.ФормаРодитель = "Дерево" Тогда
			Строка = СписокФорм.Строки.Добавить();
		Иначе
			СтрокаРодитель = СписокФорм.Строки.Найти(СтрокаТаблицы.ФормаРодитель, "КодФормы", Истина);
			Если СтрокаРодитель <> Неопределено Тогда
				Строка = СтрокаРодитель.Строки.Добавить();
			Иначе
				Строка = СписокФорм.Строки.Добавить();			
			КонецЕсли;
		КонецЕсли;   	
		Строка.ИмяФормы              = СтрокаТаблицы.ИмяФормы;
		Строка.КодФормы        		 = СтрокаТаблицы.КодФормы;
		Строка.Страницы       		 = СтрокаТаблицы.Страницы;
		Строка.ЗаголовокФормы  		 = СтрокаТаблицы.ЗаголовокФормы; 
		Строка.КоличествоНаЛисте     = Число(СтрокаТаблицы.КоличествоНаЛисте); 
		Строка.ОриентацияСтр         = СтрокаТаблицы.ОриентацияСтр; 
		Строка.АвтополучениеИтогов   = СтрокаТаблицы.АвтополучениеИтогов; 
		Строка.АвтоЗаполнение        = СтрокаТаблицы.АвтоЗаполнение; 
		Строка.Многострочность 		 = Число(СтрокаТаблицы.Многострочность);
		Строка.Выгружать       		 = Число(СтрокаТаблицы.Выгружать);
		Строка.Признакосновной 		 = Число(СтрокаТаблицы.ПризнакОсновной);
		Строка.ПоказатьСтраницу		 = Число(СтрокаТаблицы.ПоказатьСтраницу);			
	КонецЦикла;
		
КонецПроцедуры

// Процедура заполняет таблицу значений списком показателей
// для передачи данных из форм в формы
//
// Параметры: Объект - объект регламентированного отчета
//
Процедура ЗаполнитьТаблицуПередачиДанных(Объект)
	
	Префикс = Прав(Объект.мВыбраннаяФорма, 7);
	
	ТаблицаПоказателей = Объект.мТаблицаПоказателейДляПередачиДанных;
	//очищаем все данные
	ТаблицаПоказателей.Очистить();
		
	ТаблицаУпорядочивания = Новый ТаблицаЗначений;
	ТаблицаУпорядочивания.Колонки.Добавить("КодФормыИсточник");                     
	ТаблицаУпорядочивания.Колонки.Добавить("ИмяОбластиИсточник");
	ТаблицаУпорядочивания.Колонки.Добавить("КодФормыПриемник");
	ТаблицаУпорядочивания.Колонки.Добавить("ИмяОбластиПриемник");
	ТаблицаУпорядочивания.Колонки.Добавить("Верх");
		
	Макет = Объект.ПолучитьМакет("ПередачаДанных");
	                                                            	
	Для  НомерОбласти = 0 По  Макет.Области.Количество() -1 Цикл
		Область = Макет.Области[НомерОбласти];
		
		Если Прав(Область.Имя,7) = Префикс Тогда
			
			Для Ном = Область.Верх По Область.Низ Цикл
				// перебираем строки области
				ФормаИсточник      	= СокрП(Макет.Область(Ном, 1).Текст);
				ОбластьИсточник    	= СокрП(Макет.Область(Ном, 2).Текст);
				ФормаПриемник		= СокрП(Макет.Область(Ном, 3).Текст);
				ОбластьПриемник    	= СокрП(Макет.Область(Ном, 4).Текст);
			
				НоваяСтрока = ТаблицаУпорядочивания.Добавить();
				НоваяСтрока.Верх = Ном;	
				НоваяСтрока.КодФормыИсточник    = ФормаИсточник;
				НоваяСтрока.ИмяОбластиИсточник  = ОбластьИсточник;
				НоваяСтрока.КодФормыПриемник    = ФормаПриемник;
				НоваяСтрока.ИмяОбластиПриемник  = ОбластьПриемник;
			КонецЦикла;
			
		КонецЕсли;
	КонецЦикла;  	
	ТаблицаУпорядочивания.Сортировать("Верх");
	Для Каждого СтрокаТаблицы ИЗ ТаблицаУпорядочивания Цикл
		
		Строка = ТаблицаПоказателей.Добавить();
		
		Строка.КодФормыИсточник    = СтрокаТаблицы.КодФормыИсточник;
		Строка.ИмяОбластиИсточник  = СтрокаТаблицы.ИмяОбластиИсточник;
		Строка.КодФормыПриемник    = СтрокаТаблицы.КодФормыПриемник;
		Строка.ИмяОбластиПриемник  = СтрокаТаблицы.ИмяОбластиПриемник; 
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьТаблицуПередачиДанных()

// Процедура формирует структуру хранения данных
// для многострочных форм
//
Функция ФормированиеСтруктурыМногострочнойФормы(мТекущаяЗакладка, ФормаПериода,Макет) 
	
	Если Макет = Неопределено Тогда
		Сообщить("Не найден макет для многострочных форм!!!");
		Возврат Новый Структура;
	КонецЕсли;
		
	//Формируем структуры групп для многострочных форм 
	
	// структура многострочных разделов формы              	
 	мМногострочнаяСтруктура = Новый Структура;
	
	Для Каждого Страница Из ФормаПериода.ЭлементыФормы["Панель" + мТекущаяЗакладка].Страницы Цикл
			
		ИмяГруппы = Страница.Имя;							
		ОбластьШапка  = Неопределено;
		ОбластьИтог   = Неопределено;
		ОбластьСтрока = Неопределено;
		ОбластьПодвал = Неопределено;
		Если Макет.Области.Найти("Шапка"   + мТекущаяЗакладка + ИмяГруппы) <> Неопределено Тогда
			ОбластьШапка  = Макет.ПолучитьОбласть("Шапка"  + мТекущаяЗакладка + ИмяГруппы);	 
		КонецЕсли;
		Если Макет.Области.Найти("Итог"   + мТекущаяЗакладка + ИмяГруппы) <> Неопределено Тогда
			ОбластьИтог   = Макет.ПолучитьОбласть("Итог"   + мТекущаяЗакладка + ИмяГруппы);	
		КонецЕсли;
		Если Макет.Области.Найти("Строка"   + мТекущаяЗакладка + ИмяГруппы) <> Неопределено Тогда
			ОбластьСтрока = Макет.ПолучитьОбласть("Строка" + мТекущаяЗакладка + ИмяГруппы);
		КонецЕсли;
		Если Макет.Области.Найти("Подвал"   + мТекущаяЗакладка + ИмяГруппы) <> Неопределено Тогда
			ОбластьПодвал = Макет.ПолучитьОбласть("Подвал" + мТекущаяЗакладка + ИмяГруппы); 
		КонецЕсли;
		
		ТаблицаСтрокГруппы = Новый ТаблицаЗначений;
		Если ОбластьСтрока <> Неопределено Тогда
			Для каждого Область Из ОбластьСтрока.Области Цикл
				// Область может включать саму себ. исключаем ее из структуры
				Если Врег(Область.Имя) = Врег("Строка" + мТекущаяЗакладка + ИмяГруппы) Тогда
					Продолжить;
				КонецЕсли;
			    //отсекаем 3 последних символа "__1"
				ИмяКолонки = Лев(Область.Имя,СтрДлина(Область.Имя) - 3);
				ТаблицаСтрокГруппы.Колонки.Добавить(ИмяКолонки);
			КонецЦикла;
		КонецЕсли;
		
		// заполняем именами областей подвала, шапки и итогов таблицу значений ОбщиеЭлементыГруппы
		ОбщиеЭлементыГруппы = Новый ТаблицаЗначений;
		ОбщиеЭлементыГруппы.Колонки.Добавить("ИмяОбласти");
		ОбщиеЭлементыГруппы.Колонки.Добавить("ИмяПараметра");
		ОбщиеЭлементыГруппы.Колонки.Добавить("Итог");
		ОбщиеЭлементыГруппы.Колонки.Добавить("Значение");
		ОбщиеЭлементыГруппы.Индексы.Добавить("ИмяОбласти");
		ОбщиеЭлементыГруппы.Индексы.Добавить("ИмяПараметра");
		Если ОбластьШапка <> Неопределено Тогда
			Для каждого Область Из ОбластьШапка.Области Цикл
				// Область может включать саму себ. исключаем ее из структуры
				Если Врег(Область.Имя) = Врег("Шапка" + мТекущаяЗакладка + ИмяГруппы) Тогда
					Продолжить;
				КонецЕсли;
				Если Врег(Область.Параметр) = Врег("Стр") Тогда
					Продолжить;
				КонецЕсли;
	            ТекИмяОбласти       = Область.Имя;
				ТекИмяПараметра     = Область.Параметр;
				Строка = ОбщиеЭлементыГруппы.Добавить();
				Строка.ИмяОбласти   = ТекИмяОбласти;
				Строка.ИмяПараметра = ТекИмяПараметра;
				Строка.Итог = Ложь;
			КонецЦикла;
		КонецЕсли;
		Если ОбластьИтог <> Неопределено Тогда
			Для каждого Область Из ОбластьИтог.Области Цикл
				// Область может включать саму себ. исключаем ее из структуры
				Если Врег(Область.Имя) = Врег("Итог" + мТекущаяЗакладка + ИмяГруппы) Тогда
					Продолжить;
				КонецЕсли;
	            ТекИмяОбласти       = Область.Имя;
				ТекИмяПараметра     = Область.Параметр;
				Строка = ОбщиеЭлементыГруппы.Добавить();
				Строка.ИмяОбласти   = ТекИмяОбласти;
				Строка.ИмяПараметра = ТекИмяПараметра;
				Если ТаблицаСтрокГруппы.Колонки.Найти(ТекИмяОбласти) <> Неопределено Тогда 
		    		Строка.Итог = Истина;
				Иначе
					Строка.Итог = Ложь;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если ОбластьПодвал <> Неопределено Тогда
			Для каждого Область Из ОбластьПодвал.Области Цикл
				// Область может включать саму себ. исключаем ее из структуры
				Если Врег(Область.Имя) = Врег("Подвал" + мТекущаяЗакладка + ИмяГруппы) Тогда
					Продолжить;
				КонецЕсли;
	            ТекИмяОбласти       = Область.Имя;
				ТекИмяПараметра     = Область.Параметр;
				Строка = ОбщиеЭлементыГруппы.Добавить();
				Строка.ИмяОбласти   = ТекИмяОбласти;
				Строка.ИмяПараметра = ТекИмяПараметра;
				Строка.Итог = Ложь;
			КонецЦикла;
		КонецЕсли;	         		
		ОбщиеЭлементыГруппы.Индексы.Добавить("ИмяОбласти,ИмяПараметра,Итог");
		ДанныеСтраницы = Новый Структура;
		ДанныеСтраницы.Вставить("ШапкаИПодвал", ОбщиеЭлементыГруппы);
		ДанныеСтраницы.Вставить("Строки",       ТаблицаСтрокГруппы);
					
	    //записываем данные страницы в многострочную структуру
 		мМногострочнаяСтруктура.Вставить(ИмяГруппы, ДанныеСтраницы);
				
	КонецЦикла;
	
	Возврат мМногострочнаяСтруктура;
	   
КонецФункции // ФормированиеСтруктурыМногострочнойФормы()

// Функция определяет была ли заполнена форма.
// Параметры:
//           ТекИмяФормы - представляет имя текущей формы (ИмяФормы)
//
Функция ФормаЗаполнена(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт
	
	Строка = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы,"КодФормы");
		
	Если Строка.Многострочность = 1 Тогда
		
		мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(ТекущееИмяФормы,мСписокФормБезИерархии);
		// проверим заполненность по первой встретивщейся странице?
		// она может иметь разное имя - ЛистA, Страница1 и т.д.
		
		Для Каждого КлючИЗначение Из мМногострочнаяСтруктура Цикл
		
			ТаблицаСтрокГруппы = КлючИЗначение.Значение.Строки;
			Если ТаблицаСтрокГруппы.Количество()>0 Тогда
				Возврат Истина;
			Иначе
				Возврат Ложь;
			КонецЕсли;
		
		КонецЦикла;
		
	Иначе
		
		ТаблицаДанных = Строка.Значение;
		Для Каждого СтрокаТаблицы Из ТаблицаДанных Цикл
			Если ВРЕГ(Лев(СтрокаТаблицы.ИмяОбласти,2)) = "S_" И ТипЗнч(СтрокаТаблицы.Значение) = Тип("Число") Тогда
				Если СтрокаТаблицы.Значение <> 0 Тогда 
					Возврат Истина;
				КонецЕсли;
			КонецЕсли;			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Функция определяет признак получения итогов из дополнительных форм,
// если у формы есть дополнительные формы
//
Функция ОпределитьПризнакПолученияИтоговФормой(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт
	
	Форма = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы, "КодФормы");
	Если Форма <> Неопределено Тогда
		Если Форма.АвтополучениеИтогов = 1 Тогда
			ПризнакПолучения = Истина;
		Иначе
			ПризнакПолучения = Ложь;
		КонецЕсли;
	Иначе
		ПризнакПолучения = Ложь;
	КонецЕсли;
	
	Возврат ПризнакПолучения;
	
КонецФункции

// Функция опеределяет признак автозаполнения для форм,
// который устанавливается в форме настройки страниц
//
Функция ОпределитьПризнакАвтоЗаполненияФормы(ТекущееИмяФормы, мСписокФормБезИерархии) 
	
	Форма = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы, "КодФормы");
	Если Форма <> Неопределено Тогда
		Если Форма.Автозаполнение = 1 Тогда
			ПризнакАвтоЗаполнения = Истина;
		Иначе
			ПризнакАвтоЗаполнения = Ложь;
		КонецЕсли;
	Иначе
		ПризнакАвтоЗаполнения = Ложь;
	КонецЕсли;
	
	Возврат ПризнакАвтоЗаполнения;
	
КонецФункции // ОпределитьПризнакАвтоЗаполненияФормы()

// Функция получает структуру хранения данных
// для многострочной формы
//
Функция ПолучитьМногострочнуюСтруктуру(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт            
	
	Строка = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы,"КодФормы");
	ТаблицаДанных = Строка.Значение;
	Возврат ТаблицаДанных[0].Данные;
	
КонецФункции

// Функция получает таблицу расшифровки для многострочной формы
//
Функция ПолучитьТаблицуРасшифровки(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт    
	
	Строка = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы,"КодФормы");
	ТаблицаДанных = Строка.Значение;
	Возврат ТаблицаДанных[0].ТаблицаРасшифровки;
	
КонецФункции

// Функция получает таблицу данных обычной формы из
// общей структуры хранения данных
//
Функция ПолучитьТаблицуДанныхОбычнойФормы(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт
	
	Строка = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы,"КодФормы");
	ТаблицаДанных = Строка.Значение;

	Возврат ТаблицаДанных;
	
КонецФункции

// Функция получает значение таблицы данных обычной формы
//
Функция ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, ИмяОбласти) Экспорт    
	
	СтрокаОбласти = ТаблицаДанных.Найти(ИмяОбласти,"ИмяОбласти");
	Если СтрокаОбласти <> Неопределено Тогда
		ЗначениеОбласти = СтрокаОбласти.Значение;
	Иначе
		ЗначениеОбласти = 0;
	КонецЕсли;
	
	Возврат ЗначениеОбласти;
	
КонецФункции

// Функция формирует структуру многострочной формы для ее последующего
// заполнения в форме. Данная структура заполняется в форме
// и впоследствии передается с помощью процедуры ЗаполнитьФорму()
// в общую структуру хранения данных
//
Функция ПолучитьСтруктуруДляЗаполненияМногострочнойФормы(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт            
	
	Строка = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы,"КодФормы");
	ТаблицаДанных = Строка.Значение;
	МногострочнаяСтруктура = ТаблицаДанных[0].Данные;
	СтруктураФормы = Новый Структура;
	Для Каждого Лист Из МногострочнаяСтруктура Цикл
		ТаблицаСтрокГруппы = Лист.Значение.Строки;
		СтруктураФормы.Вставить(Лист.Ключ,ТаблицаСтрокГруппы);		
	КонецЦикла;
	 	
	Возврат СтруктураФормы;
	
КонецФункции

// Функция получает из общей структуры хранения данных
// количество строк на листе. Используется для многострочных форм.
//
Функция ПолучитьКоличествоНаЛисте(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт
	
	НайденнаяСтрока = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы, "КодФормы");
	
	Если НайденнаяСтрока <> Неопределено Тогда 
		Возврат НайденнаяСтрока.КоличествоНаЛисте;
	Иначе
		Возврат 1;
	КонецЕсли;
	
КонецФункции

// Функция определяет ориентацию страницы для формы.
// Используется при печати форм.
//
Функция ОпределитьОриентациюСтраницы(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт 
	
	НайденнаяСтрока = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы, "КодФормы");
	
	Если НайденнаяСтрока <> Неопределено Тогда 
		Если НайденнаяСтрока.ОриентацияСтр = "Портрет" Тогда
			ТекОриентация = ОриентацияСтраницы.Портрет;
		Иначе
			ТекОриентация = ОриентацияСтраницы.Ландшафт;
		КонецЕсли;
		Возврат ТекОриентация;
	Иначе
		Возврат ОриентацияСтраницы.Портрет;
	КонецЕсли;
	
КонецФункции

// Процедура обеспечивает передачу данных и в поле табличного документа, и в 
// структуру хранения данных для обычных форм и для многострочных форм
// для реквизитов шапки, итога и подвала по именам параметров в макете
//
// Параметры:       Форма - форма регламентированного отчета
//                  КодФормы - имя формы передаваемой или код формы
//                  ИмяОбласти - имя области поля табличного документа
//                  Значение - значение
//                  ПередаватьВТабличноеПоле - отображать ли переданное значение на форме
//                  ПередаватьВМногострочнуюЧасть - значение передается во все строки Таблиц строк каждой группы
//  
Процедура ПередатьЗначениеВСтруктуру(Форма, КодФормы, ИмяОбласти, Значение = "", ПередаватьВТабличноеПоле = Истина, ПередаватьВМногострочнуюЧасть = Ложь) Экспорт
	
	НайденнаяСтрока = Форма.мСписокФормБезИерархии.Строки.Найти(КодФормы,"КодФормы");
	ТаблицаДанных = НайденнаяСтрока.Значение;
	
	Если НайденнаяСтрока.Многострочность = 1 Тогда
		// параметр ИмяОбласти выступает в качестве параметра
		МногострСтруктура = ТаблицаДанных[0].Данные;
		Для Каждого Элемент Из МногострСтруктура Цикл
			СтруктураГруппы = Элемент.Значение;
			Если НЕ ПередаватьВМногострочнуюЧасть Тогда
				ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
				СтруктураПоиска = Новый Структура("ИмяПараметра",ИмяОбласти);
				Строки = ОбщиеЭлементыГруппы.НайтиСтроки(СтруктураПоиска);
				Если Строки.Количество() <> 0 Тогда
					Для каждого Строка Из Строки Цикл
						Строка.Значение = Значение;					
					КонецЦикла;                                             
				КонецЕсли;			
			Иначе
				ТаблицаСтрокГруппы = СтруктураГруппы.Строки;
				Если ТаблицаСтрокГруппы.Колонки.Найти(ИмяОбласти) <> Неопределено Тогда
					Для Каждого Строка Из ТаблицаСтрокГруппы Цикл
						Строка[ИмяОбласти] = Значение;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Если ПередаватьВТабличноеПоле Тогда	
			ПередатьДанныеИзСтруктурыВТабличноеПоле(Форма);
		КонецЕсли;				
		
	Иначе // обычная форма
			
		Строка = ТаблицаДанных.Найти(ИмяОбласти,"ИмяОбласти");
		Если Строка <> Неопределено Тогда
			Строка.Значение = Значение;
		Иначе
			Сообщить("В структуре формы """ + КодФормы + """ не найдена область """ + ИмяОбласти + """.");
		КонецЕсли;
		
		Если ПередаватьВТабличноеПоле Тогда
			// передаем значение из структуры в табличное поле, если в данный момент активна форма под именем "КодФормы"
			Если Форма.ИмяФормы = КодФормы Тогда
				Для Каждого Страница Из Форма.ЭлементыФормы["Панель" + КодФормы].Страницы Цикл
					ТекПоле = Форма.ЭлементыФормы[КодФормы + "ПолеТабличногоДокумента" + Страница.Имя];
					ТекОбласть = ТекПоле.Области.Найти(ИмяОбласти);
					Если ТекОбласть <> Неопределено Тогда 
						Если ТекОбласть.СодержитЗначение Тогда
							ТекОбласть.Значение = Значение;
						Иначе
							ТекОбласть.Текст = Значение;
						КонецЕсли;
						//Прервать; 
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;	
		КонецЕсли;
	КонецЕсли;
		
КонецПроцедуры

// Процедура обеспечивает передачу всех данных из табличного документа
// в структуру хранения данных для обычных форм
// Данную процедуру можно использовать только когда активная закладка 
// главной панели регламентированного отчета, имеющая имя Форма.ИмяФормы
//
Процедура ПередатьДанныеИзТабличногоПоляВСтруктуру(Форма) Экспорт        
	
	НайденнаяСтрока = Форма.мСписокФормБезИерархии.Строки.Найти(Форма.ИмяФормы,"КодФормы");
	ТаблицаДанных = НайденнаяСтрока.Значение;
	
	Для Каждого Страница Из Форма.ЭлементыФормы["Панель" + Форма.ИмяФормы].Страницы Цикл
		ТекПоле = Форма.ЭлементыФормы[Форма.ИмяФормы + "ПолеТабличногоДокумента" + Страница.Имя];
	
		Для Каждого ТекОбласть Из ТекПоле.Области Цикл
			Если Лев(Врег(ТекОбласть.Имя),8) = Врег("Страница") Тогда
				Продолжить;
			КонецЕсли;
			Строка = ТаблицаДанных.Найти(ТекОбласть.Имя, "ИмяОбласти");
			Если Строка <> Неопределено Тогда 
				Если ТекОбласть.СодержитЗначение Тогда
					Строка.Значение = ТекОбласть.Значение;
				Иначе
					Строка.Значение = ТекОбласть.Текст;
				КонецЕсли;
			КонецЕсли;		
		КонецЦикла;
	КонецЦикла;   
		
КонецПроцедуры

// Процедура обеспечивает передачу данных из структуры хранения данных
// в поле табличного документа для форм
//
Процедура ПередатьДанныеИзСтруктурыВТабличноеПоле(Форма)  Экспорт 
	                                                       
    Перем СтруктураГруппы;
	
	НайденнаяСтрока = Форма.мСписокФормБезИерархии.Строки.Найти(Форма.ИмяФормы,"КодФормы");
	ТаблицаДанных = НайденнаяСтрока.Значение;
	
	Если НайденнаяСтрока.Многострочность = 1 Тогда
		
		мМногострочнаяСтруктура = ТаблицаДанных[0].Данные;		
		Для Каждого Страница Из Форма.ЭлементыФормы["Панель" + Форма.ИмяФормы].Страницы Цикл  		 
	 		ИмяГруппы = Страница.Имя;
			мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы);
            //уже выводим записанные значения в табличный документ
			
	 		ВывестиРазделВТабличныйДокументФормы(Форма, Форма.ТекущаяСтраница, ИмяГруппы, СтруктураГруппы, Форма.ИмяФормы);
	 	КонецЦикла; 
		  		
	Иначе
		
		Для Каждого Страница Из Форма.ЭлементыФормы["Панель" + Форма.ИмяФормы].Страницы Цикл
			ТекПоле = Форма.ЭлементыФормы[Форма.ИмяФормы + "ПолеТабличногоДокумента" + Страница.Имя];
		
			Для Каждого Строка Из ТаблицаДанных Цикл
				ТекОбласть = ТекПоле.Области.Найти(Строка.ИмяОбласти);
				Если ТекОбласть <> Неопределено Тогда 
					Если ТекОбласть.СодержитЗначение Тогда
						ТекОбласть.Значение = Строка.Значение;
					Иначе
						ТекОбласть.Текст = Строка.Значение;
					КонецЕсли;
				КонецЕсли;									      
			КонецЦикла;
		КонецЦикла;   
	КонецЕсли;
	
	Форма.ИзменитьОтображениеДанныхФормы();
	
КонецПроцедуры

// Функция возвращает число.
//
// Параметры:
//	ПроверяемоеЗначение - число для проверки на длину.
//	КоличествоСимволовЦелогоЧисла - количество символов целого числа.
//	КоличествоСимволовВДроби - количество символов после запятой.
//
// Возвращаемое значение:
//	Число - если проверяемое значение удовлетворяет условию то оно возвращается без изменений 
//			иначе оно забивается символом "9"
//
Функция ПроверитьЗначениеНаСоответствиеФорматуЯчейки (ПроверяемоеЗначение, КоличествоСимволовЦелогоЧисла, КоличествоСимволовВДроби = Неопределено) Экспорт 
	
	ПараметрыФорматирования = "";
	СтрокаВозвращаемогоЗначения = "";
		
	Если КоличествоСимволовВДроби <> Неопределено И КоличествоСимволовВДроби <> 0 Тогда 
		ПараметрыФорматирования = "; ЧДЦ="+КоличествоСимволовВДроби;
		КоличествоСимволовДляПроверки = КоличествоСимволовЦелогоЧисла + КоличествоСимволовВДроби + 1; 
	Иначе 
		КоличествоСимволовДляПроверки = КоличествоСимволовЦелогоЧисла;
		КоличествоСимволовВДроби = 0;
	КонецЕсли;
	
	ПроверяемоеЗначение = Окр(ПроверяемоеЗначение, КоличествоСимволовВДроби);
	
	КоличествоСимволовПроверяемогоЗнач = СтрДлина(Формат(ПроверяемоеЗначение, "ЧГ=0"+ПараметрыФорматирования));
		
	Если КоличествоСимволовДляПроверки < КоличествоСимволовПроверяемогоЗнач Тогда 
		Для Н=1 По КоличествоСимволовЦелогоЧисла Цикл 
			СтрокаВозвращаемогоЗначения = СтрокаВозвращаемогоЗначения + "9";
		КонецЦикла;
		ЗначениеВозврата = Число(СтрокаВозвращаемогоЗначения);
	Иначе 
		ЗначениеВозврата = ПроверяемоеЗначение;
	КонецЕсли;
	
	Возврат ЗначениеВозврата;
	
КонецФункции

//Создает таблицу для отражения в учете из многострочной формы
//
Функция ПодготовитьТаблицуДляОтражениеВУчете(Форма, ВнешнийОтчет = Ложь) Экспорт
	
	Перем СтруктураГруппы;
	
	мВыбраннаяФорма = Форма.мВыбраннаяФорма;
	МакетОтражениевУчете = ПолучитьМакетРеглОтчета(Форма.Метаданные().Имя, "ОтражениеВУчете");
	
	ОбластьМакета = МакетОтражениевУчете.Область(мВыбраннаяФорма);
	мСписокФормБезИерархии = Форма.мСписокФормБезИерархии;
	
	ДополнительныеПоля = Новый Массив();
	ДополнительныеПоля.Добавить("НалоговыйКомитет");
	ТаблицаДляОтражениеВУчете = ПолучитьСтруктуруТаблицыОтраженияВУчете(ДополнительныеПоля);
	
	Для Ном = ОбластьМакета.Верх По ОбластьМакета.Низ Цикл
		ВидНалога 				 = СокрП(МакетОтражениевУчете.Область(Ном, 1).Текст);
		Если ПустаяСтрока(ВидНалога) Тогда
			Прервать;
		КонецЕсли;
		ДатаУплаты      	   	 = СокрП(МакетОтражениевУчете.Область(Ном, 2).Текст);
		КБК                    	 = СокрП(МакетОтражениевУчете.Область(Ном, 3).Текст);
		ДатаОтражения          	 = СокрП(МакетОтражениевУчете.Область(Ном, 4).Текст);
		ДатаНачалаОтчета       	 = СокрП(МакетОтражениевУчете.Область(Ном, 5).Текст);
		ДатаОкончанияОтчета    	 = СокрП(МакетОтражениевУчете.Область(Ном, 6).Текст);  
		ТекИмяФормы    		   	 = СокрП(МакетОтражениевУчете.Область(Ном, 7).Текст);  
		ИсточникЗначения	   	 = СокрП(МакетОтражениевУчете.Область(Ном, 8).Текст);  		
		ИсточникДляОрганизации 	 = СокрП(МакетОтражениевУчете.Область(Ном, 9).Текст);  
		РННПлательщика		   	 = СокрП(МакетОтражениевУчете.Область(Ном, 10).Текст);  
		КомментарийФормы       	 = СокрП(МакетОтражениевУчете.Область(Ном, 11).Текст);
		ИсточникНалоговыйКомитет = СокрП(МакетОтражениевУчете.Область(Ном, 12).Текст);  		
		ИсточникДанных 			 = СокрП(МакетОтражениевУчете.Область(Ном, 13).Текст); 
		ИмяЛИста 			 	 = СокрП(МакетОтражениевУчете.Область(Ном, 14).Текст);
		
		НайденнаяСтрока = мСписокФормБезИерархии.Строки.Найти(ТекИмяФормы,"КодФормы");
		ТаблицаДанных = НайденнаяСтрока.Значение;
		ФормаМногострочная = НайденнаяСтрока.Многострочность = 1;
		
		Если Не ФормаМногострочная Тогда
			Продолжить;
		КонецЕсли;	
		МногострочнаяСтруктура 	= ПолучитьМногострочнуюСтруктуру(ТекИмяФормы, мСписокФормБезИерархии);					
		МногострочнаяСтруктура.Свойство(ИмяЛИста, СтруктураГруппы);
		ТаблицаШапкаИПодвал 	= СтруктураГруппы.ШапкаИПодвал;
		ТаблицаСтрок 			= СтруктураГруппы.Строки;
		ТаблицаРасшифровки 		= ПолучитьТаблицуРасшифровки(ТекИмяФормы, мСписокФормБезИерархии); 
		Если ИсточникДанных = "ШапкаИПодвал" Тогда
			МассивСтрок = ТаблицаШапкаИПодвал.НайтиСтроки(Новый Структура("ИмяОбласти", ИсточникЗначения));
			Если МассивСтрок.Количество() = 0 Тогда
				Значение = 0;
			Иначе
				Значение = ?(ЗначениеЗаполнено(МассивСтрок[0].Значение), МассивСтрок[0].Значение, 0);	
			КонецЕсли;
				
			Если Значение <> 0 Тогда
				СтрокаОтражения 					= ТаблицаДляОтражениеВУчете.Добавить();
				СтрокаОтражения.ВидНалога 			= ВидНалога;                     
				СтрокаОтражения.ДатаУплаты 			= ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаУплаты);
				СтрокаОтражения.КБК 				= КБК;
				СтрокаОтражения.ДатаОтражения 		= ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаОтражения);
				СтрокаОтражения.ДатаНачалаОтчета 	= ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаНачалаОтчета);
				СтрокаОтражения.ДатаОкончанияОтчета = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаОкончанияОтчета);
				СтрокаОтражения.Организация 		= Форма.Налогоплательщик;
				СтрокаОтражения.СтруктурнаяЕдиница 	= Форма.Налогоплательщик;
				СтрокаОтражения.НалоговыйКомитет 	= Форма.НалоговыйКомитет;
				СтрокаОтражения.РННПлательщика 		= 0;
				СтрокаОтражения.Комментарий 		= КомментарийФормы;	
				СтрокаОтражения.Значение			= Значение;
				СтрокаОтражения.ИмяФормы			= ТекИмяФормы;
			КонецЕсли;
		Иначе
			НомерСтроки = 1;
			Для Каждого СтрокаТЧ ИЗ ТаблицаСтрок Цикл
				Значение = СтрокаТЧ[ИсточникЗначения];
				Если Значение <> 0 Тогда
					СтрокаОтражения 					= ТаблицаДляОтражениеВУчете.Добавить();
					СтрокаОтражения.ВидНалога 			= ВидНалога;                     
					СтрокаОтражения.ДатаУплаты 			= ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаУплаты);
					СтрокаОтражения.КБК 				= КБК;
					СтрокаОтражения.ДатаОтражения 		= ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаОтражения);
					СтрокаОтражения.ДатаНачалаОтчета 	= ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаНачалаОтчета);
					СтрокаОтражения.ДатаОкончанияОтчета = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаОкончанияОтчета);
					СтрокаОтражения.Организация 		= Форма.Налогоплательщик;
					СтрокаОтражения.СтруктурнаяЕдиница 	= Форма.Налогоплательщик;
					Попытка
						СтруктураПоиска =  Новый Структура;
						СтруктураПоиска.Вставить("ИмяЯчейки"	, ИсточникНалоговыйКомитет);
						СтруктураПоиска.Вставить("НомерСтроки"	, НомерСтроки);
						Строка = ТаблицаРасшифровки.НайтиСтроки(СтруктураПоиска);
						Если Строка.Количество() <> 0  Тогда
							СтрокаОтражения.НалоговыйКомитет 	= Строка[0].ПолеПоиска;
						КонецЕсли;				 
			
					Исключение
					КонецПопытки;	
					СтрокаОтражения.РННПлательщика 		= 0;//РегламентированнаяОтчетность.ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных,РННПлательщика);;
					СтрокаОтражения.Комментарий 		= КомментарийФормы;	
					СтрокаОтражения.Значение			= Значение;
					СтрокаОтражения.ИмяФормы			= ТекИмяФормы;
				КонецЕсли;
				НомерСтроки = НомерСтроки + 1;
			КонецЦикла;
		КонецЕсли;	
	КонецЦикла;
	
	Возврат ТаблицаДляОтражениеВУчете;
	
КонецФункции

// Функция возвращает структуру таблицу значений, построенную по макету "Отражение в учете"
Функция ПолучитьСтруктуруТаблицыОтраженияВУчете(ДополнительныеПоля = Неопределено) Экспорт 
	ТаблицаОтраженияВУчете = Новый ТаблицаЗначений;	
	ТаблицаОтраженияВУчете.Колонки.Добавить("ВидНалога");                     
	ТаблицаОтраженияВУчете.Колонки.Добавить("ДатаУплаты");
	ТаблицаОтраженияВУчете.Колонки.Добавить("КБК");	
	ТаблицаОтраженияВУчете.Колонки.Добавить("ДатаОтражения");	
	ТаблицаОтраженияВУчете.Колонки.Добавить("ДатаНачалаОтчета");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ДатаОкончанияОтчета");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ИмяФормы");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ИсточникЗначения");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ИсточникДляОрганизации");
	ТаблицаОтраженияВУчете.Колонки.Добавить("Организация"); // сюда запишем ссылку на организацию
	ТаблицаОтраженияВУчете.Колонки.Добавить("СтруктурнаяЕдиница"); // сюда запишем ссылку на структурную единицу
	ТаблицаОтраженияВУчете.Колонки.Добавить("РННПлательщика"); // сюда запишем РНН плательщика
	ТаблицаОтраженияВУчете.Колонки.Добавить("Комментарий");	
	ТаблицаОтраженияВУчете.Колонки.Добавить("Значение"); // сюда запишем значение из структуры данных
	
	Если ДополнительныеПоля <>  Неопределено Тогда
		Для Каждого СтрокаМассива Из ДополнительныеПоля Цикл
			ТаблицаОтраженияВУчете.Колонки.Добавить(СтрокаМассива);	
		КонецЦикла;	
	КонецЕсли;
	
	Возврат ТаблицаОтраженияВУчете;
КонецФункции	

// Функция возвращает таблицу значений, построенную по макету "Отражение в учете"
// 
// Параметры: РеглОтчет - ссылка на документ "Регламентированный отчет"
Функция ПолучитьТаблицуОтраженияВУчете(РеглОтчет, Макет, СписокФормБезИерархии, СписокСтруктурныхЕдиниц, ДополнительныеПараметрыОтражения = Неопределено) Экспорт
	
	// Получим данные для отражения в учете
	ТаблицаОтраженияВУчете = ПолучитьСтруктуруТаблицыОтраженияВУчете();	
	
	// Для обработки дополнительных данных
	ПоказателиОтчета = Новый Структура;
	ПараметрыОтчета = Новый Структура;
	ТаблицаДобавленныхПриложенийДляОтражения = Новый Массив();
	
	Если ДополнительныеПараметрыОтражения <> Неопределено Тогда
		// Определим числовые данные
		ДополнительныеПараметрыОтражения.Свойство("ПоказателиОтчета", ПоказателиОтчета);
		
		Для Каждого ПоказательОтчета Из ПоказателиОтчета Цикл
			ТаблицаОтраженияВУчете.Колонки.Добавить(ПоказательОтчета.Ключ);	
		КонецЦикла;
		
		// Определим прочие колонки
		ДополнительныеПараметрыОтражения.Свойство("ПараметрыОтчета", ПараметрыОтчета);
		
		Для Каждого ПараметрОтчета Из ПараметрыОтчета Цикл
			ТаблицаОтраженияВУчете.Колонки.Добавить(ПараметрОтчета.Ключ);	
		КонецЦикла;
		
		ДополнительныеПараметрыОтражения.Свойство("ТаблицаДобавленныхПриложенийДляОтражения", ТаблицаДобавленныхПриложенийДляОтражения);
		
		Если ТаблицаДобавленныхПриложенийДляОтражения  = Неопределено Тогда
			ТаблицаДобавленныхПриложенийДляОтражения = Новый Массив();
		КонецЕсли;
		
	КонецЕсли;
	
	ТаблицаОтраженияВУчетеФормаМногострочная = ТаблицаОтраженияВУчете.СкопироватьКолонки();
	МассивОтработаныхФорм = НОвый Массив;
	
	Попытка
		ОбластьМакета = Макет.Область(РеглОтчет.ВыбраннаяФорма);
	Исключение
		// такой области в макете нет.
		// возможно документ был создан из отчета не подключенного в настоящий момент к информационной базе.		
		Возврат ТаблицаОтраженияВУчете;
	КонецПопытки;
	
	Если Найти(РеглОтчет.ВыбраннаяФорма, "700") И РеглОтчет.ДатаОкончания >= Дата("31.12.2018 00:00:00") Тогда
		//700.01 
		Ном = ОбластьМакета.Низ - 1;						
		ВидНалога			   = СокрП(Макет.Область(Ном, 1).Текст);
		
		ДатаУплаты      	   = СокрП(Макет.Область(Ном, 2).Текст);
		КБК 			 	   = СокрП(Макет.Область(Ном, 3).Текст);
		ДатаОтражения          = СокрП(Макет.Область(Ном, 4).Текст);
		ДатаНачалаОтчета       = СокрП(Макет.Область(Ном, 5).Текст);
		ДатаОкончанияОтчета    = СокрП(Макет.Область(Ном, 6).Текст);  
		ТекИмяФормы    		   = СокрП(Макет.Область(Ном, 7).Текст);  
		ИсточникЗначения	   = СокрП(Макет.Область(Ном, 8).Текст);  		
		ИсточникДляОрганизации = СокрП(Макет.Область(Ном, 9).Текст);  
		РННПлательщика		   = СокрП(Макет.Область(Ном, 10).Текст);  
		КомментарийФормы       = СокрП(Макет.Область(Ном, 11).Текст);
		
		НоваяСтрока = ТаблицаОтраженияВУчете.Добавить();		
		НоваяСтрока.ВидНалога		       = ВидНалога;
		НоваяСтрока.ДатаУплаты             = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаУплаты);
		НоваяСтрока.КБК            		   = КБК;
		НоваяСтрока.ДатаОтражения          = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаОтражения);
		НоваяСтрока.ДатаНачалаОтчета       = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаНачалаОтчета);	
		НоваяСтрока.ДатаОкончанияОтчета    = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаОкончанияОтчета);	
		НоваяСтрока.ИмяФормы     		   = ТекИмяФормы;  
		НоваяСтрока.ИсточникЗначения	   = ИсточникЗначения;           
		НоваяСтрока.Организация            = Справочники.Организации.ПустаяСсылка();
		НоваяСтрока.СтруктурнаяЕдиница     = Справочники.Организации.ПустаяСсылка();
		НоваяСтрока.ИсточникДляОрганизации = ИсточникДляОрганизации;           
		НоваяСтрока.РННПлательщика		   = РННПлательщика;           
		НоваяСтрока.Комментарий   		   = КомментарийФормы;           
		
		Для Каждого ПоказательОтчета Из ПоказателиОтчета Цикл
			НоваяСтрока[ПоказательОтчета.Ключ] = СокрП(Макет.Область(Ном, ПоказательОтчета.Значение).Текст);			
		КонецЦикла;
		
		Для Каждого ПараметрОтчета Из ПараметрыОтчета Цикл
			НоваяСтрока[ПараметрОтчета.Ключ] = СокрП(Макет.Область(Ном, ПараметрОтчета.Значение).Текст);			
		КонецЦикла;
		
	Иначе
		
		Для Ном = ОбластьМакета.Верх По ОбластьМакета.Низ Цикл
			
			ВидНалога			   = СокрП(Макет.Область(Ном, 1).Текст);
			
			Если ПустаяСтрока(ВидНалога) Тогда
				// Не считываем пустую строку в области, если она есть по первой колонке.			
				Прервать;
			КонецЕсли;
			
			ДатаУплаты      	   = СокрП(Макет.Область(Ном, 2).Текст);
			КБК 			 	   = СокрП(Макет.Область(Ном, 3).Текст);
			ДатаОтражения          = СокрП(Макет.Область(Ном, 4).Текст);
			ДатаНачалаОтчета       = СокрП(Макет.Область(Ном, 5).Текст);
			ДатаОкончанияОтчета    = СокрП(Макет.Область(Ном, 6).Текст);  
			ТекИмяФормы    		   = СокрП(Макет.Область(Ном, 7).Текст);  
			ИсточникЗначения	   = СокрП(Макет.Область(Ном, 8).Текст);  		
			ИсточникДляОрганизации = СокрП(Макет.Область(Ном, 9).Текст);  
			РННПлательщика		   = СокрП(Макет.Область(Ном, 10).Текст);  
			КомментарийФормы       = СокрП(Макет.Область(Ном, 11).Текст);
			
			НоваяСтрока = ТаблицаОтраженияВУчете.Добавить();		
			НоваяСтрока.ВидНалога		       = ВидНалога;
			НоваяСтрока.ДатаУплаты             = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаУплаты);
			НоваяСтрока.КБК            		   = КБК;
			НоваяСтрока.ДатаОтражения          = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаОтражения);
			НоваяСтрока.ДатаНачалаОтчета       = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаНачалаОтчета);	
			НоваяСтрока.ДатаОкончанияОтчета    = ОбщегоНазначения.ПолучитьДатуИзСтроки(ДатаОкончанияОтчета);	
			НоваяСтрока.ИмяФормы     		   = ТекИмяФормы;  
			НоваяСтрока.ИсточникЗначения	   = ИсточникЗначения;           
			НоваяСтрока.Организация            = Справочники.Организации.ПустаяСсылка();
			НоваяСтрока.СтруктурнаяЕдиница     = Справочники.Организации.ПустаяСсылка();
			НоваяСтрока.ИсточникДляОрганизации = ИсточникДляОрганизации;           
			НоваяСтрока.РННПлательщика		   = РННПлательщика;           
			НоваяСтрока.Комментарий   		   = КомментарийФормы;           
			
			Для Каждого ПоказательОтчета Из ПоказателиОтчета Цикл
				НоваяСтрока[ПоказательОтчета.Ключ] = СокрП(Макет.Область(Ном, ПоказательОтчета.Значение).Текст);			
			КонецЦикла;
			
			Для Каждого ПараметрОтчета Из ПараметрыОтчета Цикл
				НоваяСтрока[ПараметрОтчета.Ключ] = СокрП(Макет.Область(Ном, ПараметрОтчета.Значение).Текст);			
			КонецЦикла;
		КонецЦикла;  
	КонецЕсли;

	Налогоплательщик = РеглОтчет.Организация;	
		
	ТекущееИмяФормы = Неопределено;

	ЕстьНалоговыйКомитет = ?(ТаблицаОтраженияВУчете.Колонки.Найти("НалоговыйКомитет")= Неопределено, Ложь, Истина);
	
	// заполним значения в полученной таблице	
	Для Каждого Элемент Из ТаблицаОтраженияВУчете Цикл
		КодФормы = Элемент.ИмяФормы;
		Если ТекущееИмяФормы <> КодФормы Тогда
			НайденнаяСтрока = СписокФормБезИерархии.Строки.Найти(КодФормы,"КодФормы");
			ТаблицаДанных = НайденнаяСтрока.Значение;
			ФормаМногострочная = НайденнаяСтрока.Многострочность = 1;
		КонецЕсли;
		
		Если ФормаМногострочная И Не ДополнительныеПараметрыОтражения.Свойство("ТаблицаДобавленныхПриложенийДляОтражения") Тогда // форма многострочная					
			Если МассивОтработаныхФорм.Найти(КодФормы) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;	
			ДанныеОтчета = РеглОтчет.ДанныеОтчета.Получить();
			Если ДанныеОтчета.Свойство("ТаблицаДляОтражениеВУчете") Тогда
				ТаблицаДляОтраженияВУчете = ДанныеОтчета.ТаблицаДляОтражениеВУчете;
				ПараметрОтбораСтрок = Новый Структура("ИмяФормы", КодФормы);
				МассивОтработаныхФорм.Добавить(КодФормы);
				МассивСтрок =  ТаблицаДляОтраженияВУчете.НайтиСтроки(ПараметрОтбораСтрок);
				Для Каждого СтрокаМассива Из МассивСтрок Цикл
					НоваяСтрокаТЧ = ТаблицаОтраженияВУчетеФормаМногострочная.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрокаТЧ,СтрокаМассива);
				КонецЦикла;	
			КонецЕсли;	
			
		Иначе // форма обычная
			// получим значение ячейки - источника
			Если Найти(РеглОтчет.ВыбраннаяФорма, "910") Тогда
				Если Элемент.ДатаНачалаОтчета >= РеглОтчет.ДатаНачала 
					И Элемент.ДатаОкончанияОтчета <= РеглОтчет.ДатаОкончания Тогда
					
					ЗначениеОбласти = ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, Элемент.ИсточникЗначения);			
					Элемент.Значение = ЗначениеОбласти;
				Иначе 
					Элемент.Значение = 0;
				КонецЕсли;
			Иначе
				ЗначениеОбласти = ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, Элемент.ИсточникЗначения);			
				Элемент.Значение = ЗначениеОбласти;
			КонецЕсли;	
			
			// получим значение РНН плательщика
			ЗначениеРНН = ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, Элемент.РННПлательщика);			
			Элемент.РННПлательщика = ЗначениеРНН;
			
			// получим организацию
			Элемент.Организация = Налогоплательщик;
			
			// получим структурную единицу
			Если СписокСтруктурныхЕдиниц.Количество() = 1 Тогда
				Элемент.СтруктурнаяЕдиница = СписокСтруктурныхЕдиниц[0].Значение;			
			Иначе //по нескольким структ.единицам
				Элемент.СтруктурнаяЕдиница = Налогоплательщик;			
			КонецЕсли;
		КонецЕсли;
		
		Для Каждого ПоказательОтчета Из ПоказателиОтчета Цикл
			ЗначениеПоказателя = ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, Элемент[ПоказательОтчета.Ключ]);			
			Элемент[ПоказательОтчета.Ключ] = ЗначениеПоказателя;
		КонецЦикла;
		
		Для Каждого ПараметрОтчета Из ПараметрыОтчета Цикл
			Если ЕстьНалоговыйКомитет Тогда
				Если  Элемент.НалоговыйКомитет = "НалоговыйКомитет"   Тогда 
					ЗначениеПараметра = Вычислить("РеглОтчет." + Элемент[ПараметрОтчета.Ключ]);	
					Элемент[ПараметрОтчета.Ключ] = ЗначениеПараметра;
				КонецЕсли; 				
			Иначе
				ЗначениеПараметра = Вычислить("РеглОтчет." + Элемент[ПараметрОтчета.Ключ]);	
				Элемент[ПараметрОтчета.Ключ] = ЗначениеПараметра;
			КонецЕсли;					
		КонецЦикла;
		
		ТекущееИмяФормы = КодФормы;		
	КонецЦикла;
	
	//Для Формы 700. Заполнение многострочных приложений 700.02 по таблице ТаблицаДляОтражениеВУчете.
	Если ДополнительныеПараметрыОтражения <> Неопределено Тогда
		Если ДополнительныеПараметрыОтражения.Свойство("ТаблицаДобавленныхПриложенийДляОтражения") Тогда	
			ДанныеОтчета = РеглОтчет.ДанныеОтчета.Получить();
			Если ДанныеОтчета.Свойство("ТаблицаДляОтражениеВУчете") Тогда
				ТаблицаДляОтраженияВУчете = ДанныеОтчета.ТаблицаДляОтражениеВУчете;
				Для Каждого СтрокаМассива Из ТаблицаДляОтраженияВУчете Цикл
					НоваяСтрокаТЧ = ТаблицаОтраженияВУчетеФормаМногострочная.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрокаТЧ, СтрокаМассива);
				КонецЦикла;	
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из ТаблицаОтраженияВУчетеФормаМногострочная Цикл
		НоваяСтрокаТЧ = ТаблицаОтраженияВУчете.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрокаТЧ,СтрокаТЧ);
	КонецЦикла;	
	
	Возврат ТаблицаОтраженияВУчете;
	
КонецФункции // ПолучитьТаблицуОтраженияВУчете()
                        
// Функция создает документ отражения
// налоговой отчетности в регламентированном учете
//
// Параметры:  РегОтчет - ссылка на документ "РегламентированныйОтчет", если из вызвана из списка отчетов
//                      - объект-отчет "Регламентированный отчет", если вызван из отчета.
//            Форма - форма для определения владельца
//
// Возвращаемое значение: ПроцедураЗавершена = Истина, в случае если не требуются 
//							дальнейшие действия
//                        ПроцедураЗавершена = ложь, если необходимо продолжить процедуру, которая вызвала фунцию
//
Функция СоздатьДокументОтраженияНалОтчетностиВУчете(РеглОтчет, Форма, ДополнительныеПараметрыОтражения = Неопределено) Экспорт
	
	// ключ структуры должен полностью соответствовать значениям в колонке "Вид налога"
	// ключ - может принимать значение одного из предопред.элементов справочника "Налоги, сборы и отчисления"
	// значение - соответствующий счет налога
	// макета "Отражене в учете"
	СоответствиеВидовНалоговСчетам = Новый Структура;
	СоответствиеВидовНалоговСчетам.Вставить("ЗемельныйНалог",ПланыСчетов.Типовой.ЗемельныйНалог);
	СоответствиеВидовНалоговСчетам.Вставить("НалогНаИмущество",ПланыСчетов.Типовой.НалогНаИмущество);
	СоответствиеВидовНалоговСчетам.Вставить("ИндивидуальныйПодоходныйНалог",ПланыСчетов.Типовой.ИндивидуальныйПодоходныйНалог);
	СоответствиеВидовНалоговСчетам.Вставить("ИндивидуальныйПодоходныйНалогИностранныеГраждане",ПланыСчетов.Типовой.ИндивидуальныйПодоходныйНалог);
	СоответствиеВидовНалоговСчетам.Вставить("НалогНаДобавленнуюСтоимость",ПланыСчетов.Типовой.НалогНаДобавленнуюСтоимость);
	СоответствиеВидовНалоговСчетам.Вставить("НалогНаДобавленнуюСтоимостьСИзмененнымСрокомУплаты",ПланыСчетов.Типовой.НалогНаДобавленнуюСтоимость);
	СоответствиеВидовНалоговСчетам.Вставить("Акциз",ПланыСчетов.Типовой.Акцизы);
	СоответствиеВидовНалоговСчетам.Вставить("НалогНаПрибыль",ПланыСчетов.Типовой.КорпоративныйПодоходныйНалогПодлежащийУплате);
	СоответствиеВидовНалоговСчетам.Вставить("НалогНаТранспорт",ПланыСчетов.Типовой.НалогНаТранспортныеСредства);	
	СоответствиеВидовНалоговСчетам.Вставить("ОбязательныеСоциальныеОтчисления",ПланыСчетов.Типовой.ОбязательстваПоСоциальномуСтрахованию);
	СоответствиеВидовНалоговСчетам.Вставить("ОбязательныеПенсионныеВзносы",ПланыСчетов.Типовой.ОбязательстваПоПенсионнымОтчислениям);
	СоответствиеВидовНалоговСчетам.Вставить("СоциальныйНалог",ПланыСчетов.Типовой.СоциальныйНалог);
	СоответствиеВидовНалоговСчетам.Вставить("СоциальныйНалогИнвалиды",ПланыСчетов.Типовой.СоциальныйНалог);
	СоответствиеВидовНалоговСчетам.Вставить("СоциальныйНалогИностранныеСпециалисты",ПланыСчетов.Типовой.СоциальныйНалог);
	
	Если ТипЗнч(РеглОтчет) = Тип("ДокументСсылка.РегламентированныйОтчет") Тогда
		
		СохраненныйДок = РеглОтчет;
		
		НазваниеОтчета = СохраненныйДок.ИсточникОтчета;
		
		Макет = ПолучитьМакетРеглОтчета(НазваниеОтчета, "ОтражениевУчете");
		
		мСписокСохранения = СохраненныйДок.ДанныеОтчета.Получить();
		СписокФормБезИерархии = Неопределено;
		мСписокСохранения.Свойство("ПоказателиОтчета", СписокФормБезИерархии);
		
		СписокСтруктурныхЕдиниц = Неопределено;
		Если НЕ мСписокСохранения.Свойство("СписокСтруктурныхЕдиниц", СписокСтруктурныхЕдиниц) 
			ИЛИ СписокСтруктурныхЕдиниц = Неопределено Тогда
			СписокСтруктурныхЕдиниц = Новый СписокЗначений;
		КонецЕсли;
		
	Иначе // тип ОтчетОбъект - вызван из отчета
		
		СохраненныйДок = РеглОтчет.мСохраненныйДок;
		
		Макет = РеглОтчет.ПолучитьМакет("ОтражениеВУчете");
		
		СписокФормБезИерархии = РеглОтчет.мСписокФормБезИерархии;
		
		Попытка 
			СписокСтруктурныхЕдиниц = РеглОтчет.мСписокСтруктурныхЕдиниц;
		Исключение
			СписокСтруктурныхЕдиниц = Новый СписокЗначений;
		КонецПопытки;
		
	КонецЕсли;	
	                                                 
	ОбластьОтражениеВУчетеДляТекущегоОтчета = Макет.Области.Найти(СохраненныйДок.ВыбраннаяФорма);
	
	Если ОбластьОтражениеВУчетеДляТекущегоОтчета = Неопределено Тогда 
		Предупреждение("Документ «Отражение в регламентированном учете» не предназначен для текущего отчета.");
		Возврат Истина;
	КонецЕсли;
				
	ТаблицаОтраженияВУчете = РегламентированнаяОтчетность.ПолучитьТаблицуОтраженияВУчете(СохраненныйДок, Макет, СписокФормБезИерархии, СписокСтруктурныхЕдиниц, ДополнительныеПараметрыОтражения);
	
	
	КолонкиГруппировок = "";
	КолонкиСуммирования = "";
	
	Если ДополнительныеПараметрыОтражения <> Неопределено Тогда
		
		// Для обработки дополнительных данных
		ПоказателиОтчета = Новый Структура;
		ПараметрыОтчета = Новый Структура;
		
		ДополнительныеПараметрыОтражения.Свойство("ПоказателиОтчета", ПоказателиОтчета);
		ДополнительныеПараметрыОтражения.Свойство("ПараметрыОтчета", ПараметрыОтчета);
		
		
		Для Каждого Показатель Из ПоказателиОтчета Цикл
			КолонкиСуммирования = КолонкиСуммирования + ", " + Показатель.Ключ;			
		КонецЦикла;
		
		Для Каждого Параметр Из ПараметрыОтчета Цикл
			КолонкиГруппировок = КолонкиГруппировок + ", " + Параметр.Ключ;
		КонецЦикла;
		
	КонецЕсли;
	
	// проверим есть ли данные для отражения
	ОбщаяСуммаОтраженияВУчете = ТаблицаОтраженияВУчете.Итог("Значение");	                                      
		
	Если ОбщаяСуммаОтраженияВУчете <> Неопределено И ОбщаяСуммаОтраженияВУчете <> 0 Тогда
		// создадим документ и покажем пользователю
		Если ДополнительныеПараметрыОтражения = Неопределено ИЛИ Не ДополнительныеПараметрыОтражения.Свойство("ТаблицаДобавленныхПриложенийДляОтражения") Тогда
			ТаблицаОтраженияВУчете.Свернуть("ВидНалога, ДатаУплаты, КБК, ДатаНачалаОтчета, 
			|ДатаОкончанияОтчета, Организация, СтруктурнаяЕдиница, РННПлательщика, Комментарий" + КолонкиГруппировок, "Значение" + КолонкиСуммирования);
			ТаблицаОтраженияВУчете.Сортировать("ДатаУплаты Возр, КБК Возр");
		Иначе
			//Для Формы 700 
			ТаблицаОтраженияВУчете.Сортировать("ДатаУплаты Возр, КБК Возр");
		КонецЕсли;
		
		// здесь передадим данные в документ
		
		ДокументОбъект = Документы.ОтражениеНалоговойОтчетностиВРеглУчете.СоздатьДокумент();
		ДокументОбъект.Дата = ТекущаяДата();
		ТекущийПользователь = ОбщегоНазначения.ПолучитьЗначениеПеременной("глТекущийПользователь");
		ЗаполнениеДокументов.ЗаполнитьШапкуДокумента(ДокументОбъект, ТекущийПользователь);
		ДокументОбъект.Организация = СохраненныйДок.Организация;
		ДокументОбъект.ДокументОснование = СохраненныйДок.Ссылка;
		ДокументОбъект.УчитыватьКПН = Истина;
		ДокументОбъект.ВидУчетаНУ   = Справочники.ВидыУчетаНУ.НУ;		
		ДокументОбъект.СуммаДокумента = ОбщаяСуммаОтраженияВУчете;
		ТабЧастьОтражениеВУчете = ДокументОбъект.ОтражениеВУчете;		
		ПредыдущийВидНалога = Неопределено;
		ПредыдущийКБК = Неопределено;
		ТекущийВидНалога = Справочники.НалогиСборыОтчисления.ПустаяСсылка();
		// получим подразделение для регламентных операций		
		ПодразделениеДляРеглОпераций = ПроцедурыБухгалтерскогоУчета.ПолучитьПодразделениеДляРеглОпераций(ДокументОбъект.Дата, Ложь, ДокументОбъект.Организация);
		Для Каждого СтрокаДанных Из ТаблицаОтраженияВУчете Цикл
			Если СтрокаДанных.Значение = 0 Тогда
				Продолжить;
			КонецЕсли;
			Состояние("Заполняется строка документа по КБК: " + СтрокаДанных.КБК);	
			НоваяСтрока = ТабЧастьОтражениеВУчете.Добавить();
			НоваяСтрока.Период = СтрокаДанных.ДатаУплаты;
			Если ПредыдущийВидНалога <> СтрокаДанных.ВидНалога ИЛИ ПредыдущийКБК <> СтрокаДанных.КБК Тогда
				ТекущийВидНалога = ПроцедурыНалоговогоУчета.ПолучитьВидНалогаПоКБК(СтрокаДанных.ВидНалога, СтрокаДанных.КБК);
			КонецЕсли;
			НоваяСтрока.ВидНалога = ТекущийВидНалога;
			НоваяСтрока.КодБК = СтрокаДанных.КБК;
			
			Если ТекущийВидНалога = Справочники.НалогиСборыОтчисления.НалогНаПрибыль Тогда
				СчетЗатратБУ = ПланыСчетов.Типовой.РасходыПоКорпоративномуПодоходномуНалогу; //7710
			Иначе	
				СчетЗатратБУ = ПланыСчетов.Типовой.АдминистративныеРасходы; //7210
			КонецЕсли;
			
			НоваяСтрока.СчетЗатратБУ = СчетЗатратБУ;
			
			// Назначение типа			
			Для Индекс = 1 По СчетЗатратБУ.ВидыСубконто.Количество() Цикл
				Если НоваяСтрока["СубконтоЗатратБУ" + Индекс] = Неопределено Тогда
					НоваяСтрока["СубконтоЗатратБУ" + Индекс] = Новый(СчетЗатратБУ.ВидыСубконто[Индекс-1].ВидСубконто.ТипЗначения.Типы()[0]);
				КонецЕсли;
			КонецЦикла;
			
			Если ПредыдущийВидНалога <> СтрокаДанных.ВидНалога ИЛИ ПредыдущийКБК <> СтрокаДанных.КБК Тогда
				ТаблицаДанныхПоНалогу = ПроцедурыНалоговогоУчета.ПолучитьДанныеПоВидуНалога(СоответствиеВидовНалоговСчетам, СтрокаДанных.ВидНалога, ТекущийВидНалога);			
			КонецЕсли;
			
			НоваяСтрока.СубконтоЗатратБУ1 = ТаблицаДанныхПоНалогу[0].СтатьяЗатрат;			
			
			Если ЗначениеЗаполнено(ПодразделениеДляРеглОпераций) Тогда
				НоваяСтрока.СубконтоЗатратБУ2 = ПодразделениеДляРеглОпераций;
			КонецЕсли;
						
			СчетНалога = ТаблицаДанныхПоНалогу[0].СчетНалога;
			НоваяСтрока.СчетНалогаБУ = СчетНалога;
											 
			НоваяСтрока.ВидПлатежаВБюджет = Перечисления.ВидыПлатежейВБюджетИФонды.Налог;
			
			// заполним данные по налоговому учету
			НоваяСтрока.СчетЗатратНУ = ПроцедурыБухгалтерскогоУчета.ПреобразоватьСчетаБУвСчетНУ(Новый Структура("СчетБУ", НоваяСтрока.СчетЗатратБУ), , , КонецМесяца(НоваяСтрока.Период));
	
			ПроцедурыБухгалтерскогоУчета.ЗаменитьСубконтоНУВСтроке(НоваяСтрока, НоваяСтрока.СчетЗатратБУ, НоваяСтрока.СчетЗатратНУ, 1, НоваяСтрока.СубконтоЗатратБУ1, "СубконтоЗатратНУ");
			ПроцедурыБухгалтерскогоУчета.ЗаменитьСубконтоНУВСтроке(НоваяСтрока, НоваяСтрока.СчетЗатратБУ, НоваяСтрока.СчетЗатратНУ, 2, НоваяСтрока.СубконтоЗатратБУ2, "СубконтоЗатратНУ");
			ПроцедурыБухгалтерскогоУчета.ЗаменитьСубконтоНУВСтроке(НоваяСтрока, НоваяСтрока.СчетЗатратБУ, НоваяСтрока.СчетЗатратНУ, 3, НоваяСтрока.СубконтоЗатратБУ3, "СубконтоЗатратНУ");
						
			НоваяСтрока.СчетНалогаНУ = ПроцедурыБухгалтерскогоУчета.ПреобразоватьСчетаБУвСчетНУ(Новый Структура("СчетБУ", НоваяСтрока.СчетНалогаБУ), , , КонецМесяца(НоваяСтрока.Период));
			
			НоваяСтрока.НалоговыйКомитет = СохраненныйДок.НалоговыйКомитет;			
			НоваяСтрока.СтруктурнаяЕдиница = СтрокаДанных.СтруктурнаяЕдиница;
		
			НоваяСтрока.Содержание   = СтрокаДанных.Комментарий + " за " 
							+ ПредставлениеПериода(СтрокаДанных.ДатаНачалаОтчета,КонецДня(СтрокаДанных.ДатаОкончанияОтчета),"ФП = истина") 
							+ " (КБК:" + СтрокаДанных.КБК + ")";
			НоваяСтрока.Сумма     	 = СтрокаДанных.Значение;
			
			ПредыдущийВидНалога = СтрокаДанных.ВидНалога;
			ПредыдущийКБК = СтрокаДанных.КБК;
			
			Если ДополнительныеПараметрыОтражения <> Неопределено Тогда
				
				Для Каждого Показатель Из ПоказателиОтчета Цикл
					НоваяСтрока[Показатель.Ключ] = СтрокаДанных[Показатель.Ключ];
				КонецЦикла;
				
				Для Каждого Параметр Из ПараметрыОтчета Цикл
					НоваяСтрока[Параметр.Ключ] = СтрокаДанных[Параметр.Ключ];
				КонецЦикла;
			
			КонецЕсли;
			
		КонецЦикла;	
		
		ФормаДокументаОтраженияВУчете = ДокументОбъект.ПолучитьФорму( , Форма);
		ФормаДокументаОтраженияВУчете.Открыть();
				
	Иначе
		Предупреждение("Нет данных для отражения в учете!");
		Возврат Истина;
	КонецЕсли;	
		
	Возврат Ложь;
	
КонецФункции // СоздатьДокументОтраженияНалОтчетностиВУчете()

// Функция открывает уже имеющийся документ отражения
// налоговой отчетности в регламентированном учете
//
// Параметры: РегОтчет - ссылка на документ "РегламентированныйОтчет"
//            Форма - форма для определения владельца
//
// Возвращаемое значение: ПроцедураЗавершена = Истина, в случае если открыли документ
//                        ПроцедураЗавершена = ложь, если документ не открыт и необходимо продолжить процедуру, которая вызвала функцию
//
Функция ОткрытьДокументОтраженияНалОтчетностиВУчете(РеглОтчет, Форма) Экспорт
	
	// проверим есть ли записанный документ отражения в учете
	Если РеглОтчет <> Неопределено И НЕ РеглОтчет.ДокументОтраженияВУчете.Пустая() Тогда
		// открываем раннее сохраненный документ
		ДокументОтраженияВУчете = РеглОтчет.ДокументОтраженияВУчете;		
		ФормаДокумента = ДокументОтраженияВУчете.ПолучитьФорму( , Форма);
		Если ФормаДокумента.Открыта() Тогда
			ФормаДокумента.Активизировать();
		Иначе		
			ФормаДокумента.Открыть();
		КонецЕсли;
		Возврат Истина;
	КонецЕсли;
	
 	Возврат Ложь;

КонецФункции // ОткрытьДокументОтраженияНалОтчетностиВУчете()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ДЛЯ ЗАПИСИ РЕГЛАМЕНТИРОВАННОГО ОТЧЕТА В ФОРМАТ XML

//Выгружает данные отчета в формат XML
// Параметры:
//   ИмяФайла - файл, куда будет идти запись текста XML.
//   Объект - объект регламентированного отчета.
//   ИмяПакета - имя пакета для идентификации модели типов
//
Процедура ВыгрузитьДанныеРеглОтчетаВXML(ИмяФайла, Объект, ИмяПакета, ВыдаватьСообщение = Истина)  Экспорт
	
	// сформируем таблицу форматов для данного отчета
	мТаблицаФорматов = Объект.мТаблицаФорматов;
	мВыбраннаяФорма = Объект.мВыбраннаяФорма;
	
	мТаблицаФорматов.Очистить();
	МакетФорматов = Объект.ПолучитьМакет("Форматы");
		
	ОбластьФорматов = МакетФорматов.Область(мВыбраннаяФорма);
	Для Ном = ОбластьФорматов.Верх По ОбластьФорматов.Низ Цикл
		Строка = мТаблицаФорматов.Добавить();
		Строка.ИмяФормы 		  = СокрП(МакетФорматов.Область(Ном, 1).Текст);
		Строка.ИмяСтраницы 		  = СокрП(МакетФорматов.Область(Ном, 2).Текст);
		Строка.Элемент 			  = СокрП(МакетФорматов.Область(Ном, 3).Текст);
		Строка.Тип 			      = СокрП(МакетФорматов.Область(Ном, 4).Текст);
		Строка.ПроверкаНаПустое   = СокрП(МакетФорматов.Область(Ном, 6).Текст);
		Строка.НеРедактируется    = СокрП(МакетФорматов.Область(Ном, 7).Текст);
		Строка.Мин 				  = СокрП(МакетФорматов.Область(Ном, 8).Текст);
		Строка.Макс 			  = СокрП(МакетФорматов.Область(Ном, 9).Текст);
		Строка.ФиксированнаяДлина = СокрП(МакетФорматов.Область(Ном, 10).Текст);
		Строка.Длина 			  = СокрП(МакетФорматов.Область(Ном, 11).Текст);
		Строка.Дополнение 		  = СокрП(МакетФорматов.Область(Ном, 12).Текст);
		Строка.НаименованиеФормы  = СокрП(МакетФорматов.Область(Ном, 13).Текст);
	КонецЦикла;

	Чтение = Новый ЧтениеXML;
	Префикс = Прав(мВыбраннаяФорма,7);
	Макет = Объект.ПолучитьМакет("Модель" + Префикс);
	Чтение.УстановитьСтроку(Макет.ПолучитьТекст());
	НовОбъект = ФабрикаXDTO.ПрочитатьXML(Чтение);
	
	ФабрикаОтчета = Новый ФабрикаXDTO(НовОбъект);
	
	КорневоеСвойство = ФабрикаОтчета.Пакеты.Получить(ИмяПакета).КорневыеСвойства.Получить(мВыбраннаяФорма);
	мДокументXDTO = ФабрикаОтчета.Создать(КорневоеСвойство.Тип);
	
	//очистим объект XDTO
	ТекСвойства = мДокументXDTO.Свойства();
	Для каждого Свойство Из ТекСвойства Цикл
		Если Свойство.Форма = ФормаXML.Атрибут  Тогда
			Если Свойство.Имя = "id" Тогда
			 	КлючУникальности = Новый УникальныйИдентификатор;
			 	ЗначениеАтрибута = "{" + ВРег(Строка(КлючУникальности)) + "}";				
				мДокументXDTO.Установить(Свойство,ЗначениеАтрибута);
			Иначе
				УстановкаАтрибутовИЭлементов(мДокументXDTO,Свойство);
			КонецЕсли;
		ИначеЕсли Свойство.Форма = ФормаXML.Элемент Тогда
			СоздатьОбъектXDTO(мДокументXDTO,Свойство,Свойство,ИмяПакета,ФабрикаОтчета);			
		КонецЕсли;
	КонецЦикла;
        		
	// передадим данные из структуры в объект XDTO
	Для Каждого Форма Из Объект.мСписокФормБезИерархии.Строки Цикл
		Если Форма.Выгружать = 1 Тогда
			ТекущаяФорма = Форма.ИмяФормы;
			
			Состояние("Выгружается форма " + ТекущаяФорма);
						
			ОсновныеСвойства = мДокументXDTO.Свойства();
			СвойствоФорма = ОсновныеСвойства.Получить(ТекущаяФорма);
			ОбъектФормы = мДокументXDTO[ТекущаяФорма];
		                		
			ТекСвойства = ОбъектФормы.Свойства();
			Для каждого Св Из ТекСвойства Цикл
				// атрибуты не перезаполняем, потому что они были заполнены при открытии формы
				// необходимо только передать данные из поля табличного документа в объект XDTO
				Если Св.Форма = ФормаXML.Элемент Тогда
					ВыгрузитьДанныеВОбъектXDTO(ОбъектФормы,Св,СвойствоФорма,Форма,ИмяПакета,ФабрикаОтчета,мТаблицаФорматов,,Новый Структура);				
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;	
	                                              	 	
	Запись = Новый ЗаписьXML;
	Запись.ОткрытьФайл(ИмяФайла,"UTF-8");
	Запись.ЗаписатьОбъявлениеXML();
	ФабрикаОтчета.ЗаписатьXML(Запись,мДокументXDTO,"document",,,НазначениеТипаXML.Неявное);
		
	Запись.Закрыть();
	
	Если ВыдаватьСообщение Тогда
		//выдаем пользователю сообщение о конце выгрузки
		ВыдатьОтветПриВыгрузке();	
	КонецЕсли;

КонецПроцедуры   //ВыгрузитьДанныеВXML()

// Процедура устанавливает значение для свойства объекта.
// 
// Параметры: Объект - объект (тип: ОбъектXDTO)
//            Атрибут - атрибут или элемент (тип: СвойствоXDTO)
//
Процедура УстановкаАтрибутовИЭлементов(Объект, Атрибут)
	
	Если Атрибут.ЗначениеПоУмолчанию = Неопределено Тогда
		 Объект.Установить(Атрибут,"");
	Иначе 
		 Объект.Установить(Атрибут,Атрибут.ЗначениеПоУмолчанию.Значение);
	КонецЕсли;
		
КонецПроцедуры

// Процедура используется для первоначального заполнения и создания объекта XDTO.
//
// параметры: Объект - текущий Объект XDTO для добавления свойств
//			  Свойство - добавляемое свойство
//            ТекущицЭлементДокумента - используется для идентификации объекта XDTO,
//                                      в который добавляются свойства (определенная форма отчета).
//            ИмяПакета - имя пакета для идентификации модели типов (имя пространства имен).
//            ФабрикаОтчета - программно созданная фабрика XDTO, которая содержит
//                            описание всех типов модели регламентированного отчета.
//
Процедура СоздатьОбъектXDTO(Объект, Свойство, ТекущийЭлементДокумента, ИмяПакета, ФабрикаОтчета) 
	
	ТипСвойства = Свойство.Тип;
	
	Попытка
		// если ТипСвойства - ТипОбъектаXDTO, то создаем объект	
		Если ТипЗнч(ТипСвойства) = Тип("ТипОбъектаXDTO") Тогда
			
			Если ТипСвойства.URIПространстваИмен = ИмяПакета Тогда
				
				Если ТипЗнч(Объект[Свойство.Имя]) = Тип("СписокXDTO") Тогда
					КоличествоЭлементовСписка = ПолучитьКоличествоЭлементовСписка(Свойство);
					Если КоличествоЭлементовСписка = Неопределено ИЛИ КоличествоЭлементовСписка = 0 Тогда
						КоличествоЭлементовСписка = 1;
					КонецЕсли;
					Для Н = 1 По КоличествоЭлементовСписка Цикл
						ДочернийОбъект = ФабрикаОтчета.Создать(ТипСвойства);
						ТекСвойства = ДочернийОбъект.Свойства();
						Для каждого Св Из ТекСвойства Цикл
							Если Св.Форма = ФормаXML.Атрибут  Тогда
								УстановкаАтрибутовИЭлементов(ДочернийОбъект,Св);
							ИначеЕсли Св.Форма = ФормаXML.Элемент Тогда
								СоздатьОбъектXDTO(ДочернийОбъект,Св,ТекущийЭлементДокумента,ИмяПакета,ФабрикаОтчета);
							КонецЕсли;
						КонецЦикла;						
		        		Объект[Свойство.Имя].Добавить(ДочернийОбъект);
					КонецЦикла;
				Иначе 
					ДочернийОбъект = ФабрикаОтчета.Создать(ТипСвойства);
					ТекСвойства = ДочернийОбъект.Свойства();
					Для каждого Св Из ТекСвойства Цикл
						Если Св.Форма = ФормаXML.Атрибут  Тогда
							УстановкаАтрибутовИЭлементов(ДочернийОбъект,Св);							
						ИначеЕсли Св.Форма = ФормаXML.Элемент Тогда
							СоздатьОбъектXDTO(ДочернийОбъект,Св,ТекущийЭлементДокумента,ИмяПакета,ФабрикаОтчета)							
						КонецЕсли;
					КонецЦикла;					
		        	Объект[Свойство.Имя] = ДочернийОбъект;
				КонецЕсли;
			Иначе
				УстановкаАтрибутовИЭлементов(Объект,Свойство);				
			КонецЕсли;
			
		// если ТипСвойства - ТипЗначенияXDTO, то создаем значение	
		ИначеЕсли ТипЗнч(ТипСвойства) = Тип("ТипЗначенияXDTO") Тогда
			
			Если ТипСвойства.URIПространстваИмен = ИмяПакета Тогда
				Если ТипСвойства.Имя = "Флажок" Тогда
					Объект.Установить(Свойство,0);
				Иначе
					Сообщить("Неверный тип значения свойства");
				КонецЕсли;
			Иначе
				УстановкаАтрибутовИЭлементов(Объект,Свойство);				
			КонецЕсли;
			
		КонецЕсли;
	
	Исключение
	
		Сообщить("Невозможно добавить свойство """ + Свойство.Имя + """ в объект XDTO: " + ТекущийЭлементДокумента.Имя);
	
	КонецПопытки;
	
КонецПроцедуры

// Функция определяет количество элементов для записи
// в свойство типа СписокXDTO
//
Функция ПолучитьКоличествоЭлементовСписка(Свойство)
	
	Если Свойство.Имя = "sheet" Тогда 
		Возврат 1;
		
	ИначеЕсли Свойство.Имя = "row" Тогда
		Если Свойство.ВерхняяГраница = -1 ИЛИ Свойство.ВерхняяГраница = Неопределено Тогда
			Возврат 1;
		Иначе
			Возврат Свойство.ВерхняяГраница;
		КонецЕсли;		
						
	КонецЕсли;
					
КонецФункции // ПолучитьКоличествоЭлементовСписка()

//Процедура выгружает данные регламентированного отчета 
// в объект XDTO для его последующей выгрузки в файл XML.
//
// Параметры: Объект - текущий Объект XDTO для добавления свойств
//			  Свойство - добавляемое свойство
//            ТекущицЭлементДокумента - используется для идентификации объекта XDTO,
//                                      в который добавляются свойства (определенная форма отчета).
//			  Форма - строка общей структуры хранения данных регламентированного отчета,
//					  т.е строка дерева значений мСписокФормБезИерархии,
//                    в колонке "Значение" содержатся все данные формы рег.отчета
//            ИмяПакета - имя пакета для идентификации модели типов (имя пространства имен).
//            ФабрикаОтчета - программно созданная фабрика XDTO, которая содержит
//                            описание всех типов модели регламентированного отчета.
//            мТаблицаФорматов - Таблица форматов (тип: ТаблицаЗначений), содержащая все форматы
//                               тегов файла выгрузки XML. Данная таблица форматов заполнена на основании
//                               макета "Форматы" регламентированного отчета
//            ИмяСтраницы - содержит тег страницы XML (например, "page_100000100009"), используется для
//                          поиска строки форматов в мТаблицаФорматов для определенного значения, передаваемого
//                          в объектXDTO.
//            СтруктураДанных - служебная структура, использующаяся в процессе выгрузки данных
//                                                       
Процедура ВыгрузитьДанныеВОбъектXDTO(Объект, Свойство, ТекущийЭлементДокумента, Форма, ИмяПакета,
							ФабрикаОтчета, мТаблицаФорматов, ИмяСтраницы = Неопределено, СтруктураДанных)  
	
	Перем СтруктураГруппы;

	ТипСвойства = Свойство.Тип;
	
	Попытка
		// если ТипСвойства - ТипОбъектаXDTO, то создаем объект	
		Если ТипЗнч(ТипСвойства) = Тип("ТипОбъектаXDTO") Тогда
			
			Если ТипСвойства.URIПространстваИмен = ИмяПакета Тогда
				
				Если ТипЗнч(Объект[Свойство.Имя]) = Тип("СписокXDTO") Тогда //Свойство.Имя = "sheet" Или Свойство.Имя = "row" Тогда 
					ТаблицаДанных = Форма.Значение;
					МногСтруктура = ТаблицаДанных[0].Данные;
					Если Свойство.Имя = "sheet" Тогда
						МногСтруктура.Свойство("ЛистA",СтруктураГруппы);
						ТаблицаСтрокГруппы = СтруктураГруппы.Строки;          	 
						//вычисляем количество страниц
						КоличествоЗаписей = ТаблицаСтрокГруппы.Количество();
						мКоличествоНаЛисте = Форма.КоличествоНаЛисте;
						Стр =  Цел(КоличествоЗаписей/мКоличествоНаЛисте);
						Если Стр = КоличествоЗаписей/мКоличествоНаЛисте  Тогда
							ВсегоСтр = Стр;
						Иначе
							ВсегоСтр = Стр + 1;
						КонецЕсли;
                        КоличествоЭлементовСписка = ВсегоСтр; 
					Иначе
					    КоличествоЭлементовСписка = Форма.КоличествоНаЛисте;
					КонецЕсли;
					Если КоличествоЭлементовСписка = Неопределено ИЛИ КоличествоЭлементовСписка = 0 Тогда
						КоличествоЭлементовСписка = 1;
					КонецЕсли;
					Объект[Свойство.Имя].Очистить();
					Для Н = 1 По КоличествоЭлементовСписка Цикл
						ДочернийОбъект = ФабрикаОтчета.Создать(ТипСвойства);
					//	ДочернийОбъект = Объект.ПолучитьXDTO(Свойство.Имя);
						ТекСвойства = ДочернийОбъект.Свойства();
						 						
						// найдем в структуре нужную строку с данными
						Если ВРЕГ(Свойство.Имя) = ВРЕГ("row") Тогда
							СтруктураГруппы = Неопределено;
							СтруктураДанных.Свойство("Данные",СтруктураГруппы);
							ТаблицаСтрокГруппы = СтруктураГруппы.Строки;
							НомерСтраницы = Неопределено;
							СтруктураДанных.Свойство("НомерСтраницы", НомерСтраницы);							
							НомерСтроки = (НомерСтраницы - 1) * КоличествоЭлементовСписка + Н;
							Если ТаблицаСтрокГруппы.Количество() < НомерСтроки Тогда
								Строка = Неопределено;					  
							Иначе
								Строка = ТаблицаСтрокГруппы[НомерСтроки - 1];
							КонецЕсли;
							СтруктураДанных.Вставить("Строка",Строка);
						КонецЕсли;
						Для каждого Св Из ТекСвойства Цикл
							Если Св.Форма = ФормаXML.Атрибут  Тогда
								Если Не ДочернийОбъект.Установлено(Св) Тогда
									УстановкаАтрибутовИЭлементов(ДочернийОбъект,Св);
								КонецЕсли;
							ИначеЕсли Св.Форма = ФормаXML.Элемент Тогда
								Если Свойство.Имя = "sheet" Тогда
									СтруктураДанных = Новый Структура;
									СтруктураДанных.Вставить("НомерСтраницы", Н);
								//Иначе
								//	СтруктураДанных = Неопределено;
								КонецЕсли;   
								Если ВРЕГ(Лев(Св.Имя,4)) = ВРЕГ("Лист") Тогда
									МногСтруктура.Свойство(Св.Имя,СтруктураГруппы);
									СтруктураДанных.Вставить("Данные", СтруктураГруппы);									
								КонецЕсли;
								ВыгрузитьДанныеВОбъектXDTO(ДочернийОбъект,Св,ТекущийЭлементДокумента,Форма,
													ИмяПакета,ФабрикаОтчета,мТаблицаФорматов,ИмяСтраницы,СтруктураДанных);
							КонецЕсли;
						КонецЦикла;
						// после обработки данных для данной строки многострочной части
						// удаляем строку данных из структуры
						Если СтруктураДанных.Свойство("Строка") Тогда
							СтруктураДанных.Удалить("Строка");
						КонецЕсли;
						Объект[Свойство.Имя].Добавить(ДочернийОбъект);
					КонецЦикла;
				Иначе 
					Если Форма.Многострочность = 1 Тогда // значит форма многострочная
						ДочернийОбъект = ФабрикаОтчета.Создать(ТипСвойства);
					Иначе
						ДочернийОбъект = Объект.ПолучитьXDTO(Свойство);
					КонецЕсли;
					ТекСвойства = ДочернийОбъект.Свойства();
					Для каждого Св Из ТекСвойства Цикл
						Если Св.Форма = ФормаXML.Атрибут  Тогда
							Если Не ДочернийОбъект.Установлено(Св) Тогда 
								УстановкаАтрибутовИЭлементов(ДочернийОбъект,Св);
							КонецЕсли;
						ИначеЕсли Св.Форма = ФормаXML.Элемент Тогда
							Если Лев(Свойство.ЛокальноеИмя,4) = "page" Тогда
								Страница = Свойство.ЛокальноеИмя;
							Иначе
								Страница = ИмяСтраницы;
							КонецЕсли;
							ВыгрузитьДанныеВОбъектXDTO(ДочернийОбъект,Св,ТекущийЭлементДокумента,Форма,
												ИмяПакета,ФабрикаОтчета,мТаблицаФорматов,Страница,СтруктураДанных);
						КонецЕсли;
					КонецЦикла;
					Объект[Свойство.Имя] = ДочернийОбъект;    //строка не обязательна если используем ПолучитьXDTO()
				КонецЕсли;
			Иначе
				УстановкаАтрибутовИЭлементов(Объект,Свойство);				
			КонецЕсли;
			
		// если ТипСвойства - ТипЗначенияXDTO, то создаем значение	
		ИначеЕсли ТипЗнч(ТипСвойства) = Тип("ТипЗначенияXDTO") Тогда
			
			Отбор = Новый Структура;
			Отбор.Вставить("ИмяФормы",    Форма.ИмяФормы);
			Отбор.Вставить("ИмяСтраницы", ИмяСтраницы);
			Отбор.Вставить("Элемент",     Свойство.ЛокальноеИмя);
			СтрокаФорматов = мТаблицаФорматов.НайтиСтроки(Отбор);
			СтрокаФорматов = СтрокаФорматов[0];
			Если Форма.Многострочность = 1 Тогда
				Если Свойство.Имя = "НомерСтраницы" Тогда
					НомерСтраницы = Неопределено;
					СтруктураДанных.Свойство("НомерСтраницы",НомерСтраницы);
					Если НомерСтраницы = Неопределено Тогда
						Сообщить("Номер страницы неопределен.");
						Значение = "001";
					Иначе
						Значение = НомерСтраницы;
					    Значение = ПривестиЗначениеКФормату(Значение, Ложь, СтрокаФорматов);
					КонецЕсли;
				Иначе
					Если Не СтруктураДанных.Свойство("Строка") Тогда // работаем с показателями шапки и подвала
						ТекДанные = Неопределено;
						СтруктураДанных.Свойство("Данные", ТекДанные);
    					ОбщиеЭлементыГруппы = ТекДанные.ШапкаИПодвал;          	 
						Строка = ОбщиеЭлементыГруппы.Найти(Свойство.Имя,"ИмяОбласти");
						Если Строка <> Неопределено Тогда
							Значение = Строка.Значение;
							Если ТипСвойства.URIПространстваИмен = ИмяПакета И ТипСвойства.Имя = "Флажок" Тогда
								ПризнакФлажка = Истина;
							Иначе
								ПризнакФлажка = Ложь;							
							КонецЕсли;
							Значение = ПривестиЗначениеКФормату(Значение, ПризнакФлажка, СтрокаФорматов);
						Иначе
							//Сообщить("Не найден в структуре хранения данных показатель " + Свойство.Имя + " для формы " + ТекущийЭлементДокумента.Имя);	
							Значение = "";
						КонецЕсли;								
					Иначе // работаем с многострочной частью
						ТекДанные = Неопределено;
						СтруктураДанных.Свойство("Строка",ТекДанные);
						Если ТекДанные <> Неопределено Тогда
							Значение = ТекДанные[Свойство.Имя];
							Если ТипСвойства.URIПространстваИмен = ИмяПакета И ТипСвойства.Имя = "Флажок" Тогда
								ПризнакФлажка = Истина;
							Иначе
								ПризнакФлажка = Ложь;							
							КонецЕсли;					
							Значение = ПривестиЗначениеКФормату(Значение, ПризнакФлажка, СтрокаФорматов);
						Иначе
							Если ТипСвойства.URIПространстваИмен = ИмяПакета Тогда
								Если ТипСвойства.Имя = "Флажок" Тогда
									Значение = 0;
								Иначе 
									Сообщить("Неверный тип значения свойства");
								КонецЕсли;
							Иначе
								Значение = "";
							КонецЕсли;					
						КонецЕсли;						
                    КонецЕсли;
				КонецЕсли;
				Объект.Установить(Свойство,Значение);				
				
			Иначе
				 ТаблицаДанных = Форма.Значение;
				 ИмяОбласти = Свойство.Имя;
				 СтрокаОбласти = ТаблицаДанных.Найти(ИмяОбласти,"ИмяОбласти");
				 Если СтрокаОбласти <> Неопределено Тогда
					 Значение = СтрокаОбласти.Значение;
					 Если ТипСвойства.URIПространстваИмен = ИмяПакета И ТипСвойства.Имя = "Флажок" Тогда
						 ПризнакФлажка = Истина;
					 Иначе
						 ПризнакФлажка = Ложь;							
					 КонецЕсли;
					 Значение = ПривестиЗначениеКФормату(Значение, ПризнакФлажка, СтрокаФорматов);
					 Объект.Установить(Свойство,Значение);
				 Иначе
					 УстановкаАтрибутовИЭлементов(Объект,Свойство);					 
				 КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
	
	Исключение
	
		Сообщить("Невозможно добавить свойство """ + Свойство.Имя + """ в объект XDTO: " + ТекущийЭлементДокумента.Имя);
	
	КонецПопытки;
	
КонецПроцедуры

//Приводит значение к нужному формату для выгрузки в формате XML
//
//Параметры:
//	Значение - значение, которое нужно привести к нужному формату
//	ПризнакФлажка - признак значения, на проверку по типу "Булево"
//  СтрокаФорматов - строка, содержащая нужный формат
//
Функция ПривестиЗначениеКФормату(Значение, ПризнакФлажка, СтрокаФорматов)    
	
	Если СтрокаФорматов.Тип = "numeric" ИЛИ СтрокаФорматов.Тип = "currency" Тогда
		Если ТипЗнч(Значение) = Тип("Строка") Тогда
			// проверим возможность преобразования в число
			СтрокаПроверки = СокрЛП(Значение);
			ЗначНеЧисло = Ложь;
			Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
				КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
				Если НЕ ((КодСимвола >= 48 И КодСимвола <= 57) ИЛИ (КодСимвола = 44) ИЛИ (КодСимвола = 46)) Тогда
					ЗначНеЧисло = Истина;
				КонецЕсли; 
			КонецЦикла; 
			Если ЗначНеЧисло Тогда
				Сообщить("Формат ячейки """ + СтрокаФорматов.Элемент + """ формы """ + СтрокаФорматов.ИмяФормы + 
					""" не соответствует формату клиента. "+Символы.ПС+" Выгружено пустое значение данной ячейки."); 
				Значение = "";
			КонецЕсли;
	    КонецЕсли;		
	КонецЕсли;
	
	Если ПризнакФлажка Тогда
		Если Врег(Значение) = "Х" ИЛИ Врег(Значение) = "X" Тогда
			Значение = 1;
		Иначе
			Значение = 0;
		КонецЕсли;		
	//добавляем лидирующие нули
	ИначеЕсли СтрокаФорматов.Тип = "numeric" И СтрокаФорматов.ФиксированнаяДлина = "true" Тогда
	    ТекФормат = "ЧЦ=" + СтрокаФорматов.Длина + "; ЧВН=; ЧГ=";
		Значение = Формат(Значение, ТекФормат);
	ИначеЕсли Не ЗначениеЗаполнено(Значение) И ТипЗнч(Значение) = Тип("Число")  Тогда
		Значение = "";
	ИначеЕсли НЕ ЗначениеЗаполнено(Значение) И ТипЗнч(Значение) = Тип("Строка") Тогда
		Значение = "";						 
	ИначеЕсли ТипЗнч(Значение) = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Значение = "";
		Иначе
			Значение = Лев(Значение,10);
		КонецЕсли; 	
	ИначеЕсли Не ЗначениеЗаполнено(Значение) Тогда
		Значение = "";		
	КонецЕсли;	  	
	
	Возврат Значение;        
	
КонецФункции //ПривестиЗначениеКФормату()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ВЫГРУЗКИ ДАННЫХ ОТЧЕТА В XML

//Выгружает данные отчета в формат XML
// Параметры:
//   ИмяФайла - файл, куда будет идти запись текста XML.
//   Объект - объект регламентированного отчета.
//
Процедура ВыгрузитьОтчетВXMLДляСОНО(ИмяФайла, Объект, ВыдаватьСообщение = Истина, ПрефиксФормы = Неопределено) Экспорт

    Если ПрефиксФормы = Неопределено Тогда
		Префикс = Прав(Объект.мВыбраннаяФорма,7);
	Иначе
		Префикс = ПрефиксФормы;
	КонецЕсли;
	
	// запишем общие атрибуты (code, version) и создадим элемент form
	Запись = Новый ЗаписьXML;		
	Запись.ОткрытьФайл(ИмяФайла,"UTF-8");
	Запись.ЗаписатьОбъявлениеXML();
	
	// Запишем корневой элемент
	Запись.ЗаписатьНачалоЭлемента("fno");
	
	МакетВыгрузки = Объект.ПолучитьМакет("ВыгрузкаВXML");

	ТаблОбщиеРеквизиты = Новый ТаблицаЗначений;
	ТаблОбщиеРеквизиты.Колонки.Добавить("ИмяАтрибута");
	ТаблОбщиеРеквизиты.Колонки.Добавить("ЗначениеАтрибута");
	
	ОбластьОбщихРеквизитов = МакетВыгрузки.Область("ОбщиеРеквизиты" + Префикс);
	Для Ном = ОбластьОбщихРеквизитов.Верх По ОбластьОбщихРеквизитов.Низ Цикл
		Строка = ТаблОбщиеРеквизиты.Добавить();
		Строка.ИмяАтрибута 		  = СокрП(МакетВыгрузки.Область(Ном, 1).Текст);
		Строка.ЗначениеАтрибута   = СокрП(МакетВыгрузки.Область(Ном, 2).Текст);		
	КонецЦикла;                           	
	
	// Запишем атрибуты корневого элемента
	Для Каждого Строка Из ТаблОбщиеРеквизиты Цикл
		Запись.ЗаписатьАтрибут(Строка.ИмяАтрибута,Строка.ЗначениеАтрибута);			  
	КонецЦикла;
	
	// создадим таблицу для выгрузки
	ТаблицаВыгрузки = Новый ТаблицаЗначений;
	ТаблицаВыгрузки.Колонки.Добавить("Форма");
	ТаблицаВыгрузки.Колонки.Добавить("Страница");
	ТаблицаВыгрузки.Колонки.Добавить("ИмяАтрибута");
	ТаблицаВыгрузки.Колонки.Добавить("ИмяЯчейки");
	ТаблицаВыгрузки.Колонки.Добавить("КоличествоROW");
	ТаблицаВыгрузки.Колонки.Добавить("ИмяФормы");
	ТаблицаВыгрузки.Колонки.Добавить("ИмяЛиста");
	ТаблицаВыгрузки.Колонки.Добавить("Отображение");
	ТаблицаВыгрузки.Колонки.Добавить("ВыгружатьНулевыеЗначения");
    
	ТаблицаВыгрузки.Колонки.Добавить("КодФормы");
	ТаблицаВыгрузки.Колонки.Добавить("Выгружать");
	ТаблицаВыгрузки.Колонки.Добавить("Многострочность");
	ТаблицаВыгрузки.Колонки.Добавить("ЗаголовокФормы"); 
	ТаблицаВыгрузки.Колонки.Добавить("КоличествоНаЛисте");    
	ТаблицаВыгрузки.Колонки.Добавить("Значение");    
	
	ОбластьВыгрузки = МакетВыгрузки.Область("Выгрузка" + Префикс);
	ТекущееИмяФормы = Неопределено;
	Для Ном = ОбластьВыгрузки.Верх По ОбластьВыгрузки.Низ Цикл
		Строка = ТаблицаВыгрузки.Добавить();
		Строка.Форма 	       = СокрП(МакетВыгрузки.Область(Ном, 1).Текст);
		Строка.Страница        = СокрП(МакетВыгрузки.Область(Ном, 2).Текст);		
		Строка.ИмяАтрибута     = СокрП(МакетВыгрузки.Область(Ном, 3).Текст);		
		Строка.ИмяЯчейки       = СокрП(МакетВыгрузки.Область(Ном, 4).Текст);		
		Строка.КоличествоROW   = СокрП(МакетВыгрузки.Область(Ном, 5).Текст);		
		Строка.ИмяФормы        = СокрП(МакетВыгрузки.Область(Ном, 6).Текст);		
		Строка.ИмяЛиста        = СокрП(МакетВыгрузки.Область(Ном, 7).Текст);		
		Строка.Отображение     = СокрП(МакетВыгрузки.Область(Ном, 8).Текст);
   		Строка.ВыгружатьНулевыеЗначения = ?(СокрП(МакетВыгрузки.Область(Ном, 9).Текст) = "1", Истина, Ложь);
		НовоеИмяФормы = Строка.ИмяФормы;
		Если НовоеИмяФормы <> ТекущееИмяФормы Тогда
			Форма = Объект.мСписокФормБезИерархии.Строки.Найти(Строка.ИмяФормы, "ИмяФормы");
		КонецЕсли;
		Если Форма <> Неопределено Тогда
			Строка.КодФормы  		 = Форма.КодФормы;
			Строка.Выгружать  		 = Форма.Выгружать;
			Строка.Многострочность   = Форма.Многострочность;
			Строка.ЗаголовокФормы    = Форма.ЗаголовокФормы;
			Строка.КоличествоНаЛисте = Форма.КоличествоНаЛисте;
			Строка.Значение  		 = Форма.Значение;			
		КонецЕсли;
		ТекущееИмяФормы = Строка.ИмяФормы;
	КонецЦикла;                           	
	
	// выгрузка в XML 
	КоличествоСтрокВТаблице = ТаблицаВыгрузки.Количество();
	НомерСтроки = 0;
	
	ТекущаяФорма = Неопределено;
	ТекущаяСтраница = Неопределено;
	
	Пока Истина Цикл
		Если НомерСтроки >= КоличествоСтрокВТаблице Тогда
			Прервать;
		КонецЕсли; 
		ВыгрузитьСтрокуВXML(Запись, ТаблицаВыгрузки, КоличествоСтрокВТаблице, НомерСтроки, ТекущаяФорма, ТекущаяСтраница);			
		НомерСтроки = НомерСтроки + 1;                                                                                      		
	КонецЦикла;
	
	Запись.ЗаписатьКонецЭлемента();		// </sheet>
	Запись.ЗаписатьКонецЭлемента();		// </sheetGroup>
	Запись.ЗаписатьКонецЭлемента();		// </form> 
	
	Запись.ЗаписатьКонецЭлемента();  // fno
		
	Запись.Закрыть();
	
	// данный текст модуля добавлен для совместимости с СОНО (в СОНО для UTF-8 нет BOM поля)
	ТекстДок = Новый ТекстовыйДокумент;
	ТекстДок.Прочитать(ИмяФайла,"windows-1251");
	Строка = ТекстДок.ПолучитьСтроку(1);
	ТекстДок.ЗаменитьСтроку(1,Прав(Строка,СтрДлина(Строка)-3));
	ВыбФайл = Новый Файл(ИмяФайла);
	ТекстДок.Записать(ВыбФайл.Путь+ВыбФайл.ИмяБезРасширения+ВыбФайл.Расширение,"windows-1251");
	// СОНО
	
	Если ВыдаватьСообщение Тогда
		//выдаем пользователю сообщение о конце выгрузки
		ВыдатьОтветПриВыгрузке();
	КонецЕсли;
	
КонецПроцедуры // ВыгрузкаОтчетаВXMLДляСОНО()

// Формирует построчно структуру XML файла из макета "ВыгрузкаВXML"
//
Процедура ВыгрузитьСтрокуВXML(Запись, ТаблицаВыгрузки, КоличествоСтрокВТаблице, НомерСтроки, ТекущаяФорма = Неопределено, ТекущаяСтраница = Неопределено)
	
	СтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки);
	НоваяФорма = СтрокаВыгрузки.Форма; 
	НоваяСтраница = СтрокаВыгрузки.Страница; 
	
	Если ТекущаяФорма <> Неопределено И НоваяФорма <> ТекущаяФорма Тогда
	   Запись.ЗаписатьКонецЭлемента();			// </sheet>
	КонецЕсли;
	Если НЕ НоваяФорма = ТекущаяФорма Тогда		
		Если НЕ ТекущаяФорма = Неопределено Тогда
			Запись.ЗаписатьКонецЭлемента();			// </sheetGroup>
			Запись.ЗаписатьКонецЭлемента();			// </form>
		КонецЕсли;
		Запись.ЗаписатьНачалоЭлемента("form");
		Состояние("Выгружается форма " + НоваяФорма);
		Запись.ЗаписатьАтрибут("name",СтрокаВыгрузки.Форма);
		Запись.ЗаписатьНачалоЭлемента("sheetGroup");
	КонецЕсли;                                       	
	Если НЕ НоваяСтраница = ТекущаяСтраница Тогда
		Если ТекущаяФорма <> Неопределено И НоваяФорма <> ТекущаяФорма Тогда
			// ничего не делаем
	    ИначеЕсли НЕ ТекущаяСтраница = Неопределено Тогда		
			Запись.ЗаписатьКонецЭлемента();			// </sheet>
		КонецЕсли;
		Запись.ЗаписатьНачалоЭлемента("sheet");
		Запись.ЗаписатьАтрибут("name",СтрокаВыгрузки.Страница);
	КонецЕсли;
	
	Если СтрокаВыгрузки.Многострочность <> Неопределено И СтрокаВыгрузки.Многострочность = 1 Тогда 
		ВыгрузитьМногострочнуюФорму(Запись, ТаблицаВыгрузки, КоличествоСтрокВТаблице, НомерСтроки);
	// проверим многострочное ли значение
	ИначеЕсли ЗначениеЗаполнено(СтрокаВыгрузки.КоличествоROW) И СтрокаВыгрузки.КоличествоROW <> "0" Тогда  // для обычных форм
		// если в обычной форме встретилась многострочность 
		КоличествоПовторений = Число(СтрокаВыгрузки.КоличествоROW);
		Для Н = 1 По КоличествоПовторений Цикл 				
			Запись.ЗаписатьНачалоЭлемента("row");
			СтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки);
			Если Н = 1 Тогда
				ТаблицаМногострочныхТегов = ТаблицаВыгрузки.СкопироватьКолонки();
				НоваяСтрока = ТаблицаМногострочныхТегов.Добавить();			
				ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаВыгрузки);
				
				// Проверим многострочная ли следующая строка
				СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);
				Пока ЗначениеЗаполнено(СледСтрокаВыгрузки.КоличествоROW) И СледСтрокаВыгрузки.КоличествоROW <> "0" Цикл
					НомерСтроки = НомерСтроки+1;
					НоваяСтрока = ТаблицаМногострочныхТегов.Добавить();			
					ЗаполнитьЗначенияСвойств(НоваяСтрока, СледСтрокаВыгрузки);
					Если (ТаблицаВыгрузки.Количество()-1) > НомерСтроки  Тогда
						СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);
					Иначе
						Прервать;
					КонецЕсли;
				КонецЦикла;   				
			КонецЕсли;
			Для Каждого МногСтрока Из ТаблицаМногострочныхТегов Цикл
				ЗаписатьЗначениеЭлемента(Запись, МногСтрока);	
			КонецЦикла;    			
			Запись.ЗаписатьКонецЭлемента();			// </row>
		КонецЦикла;			
	Иначе
		ЗаписатьЗначениеЭлемента(Запись, СтрокаВыгрузки);
	КонецЕсли;	      	
	
	ТекущаяФорма = НоваяФорма;
	ТекущаяСтраница = НоваяСтраница;
		
КонецПроцедуры // ВыгрузитьСтрокуВXML()

// Выгружает многострочные формы в XML
//
Процедура ВыгрузитьМногострочнуюФорму(Запись, ТаблицаВыгрузки, КоличествоСтрокВТаблице, НомерСтроки)
	
	Перем СтруктураГруппы;
	
	СтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки);	
	
	Если СтрокаВыгрузки.КоличествоНаЛисте = 1 Тогда  // форма многостраничная
		
		// для многострочной = одностраничной
		
		НачальнаяСтрока = НомерСтроки;
		КонечнаяСтрока = 0;
		
		ТекущаяФорма = СтрокаВыгрузки.Форма;
		СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);
		НоваяФорма = СледСтрокаВыгрузки.Форма;
		Пока НоваяФорма = ТекущаяФорма Цикл
			НомерСтроки = НомерСтроки+1;
			
			ТекущаяФорма = СледСтрокаВыгрузки.Форма;
			Если НомерСтроки+1 < КоличествоСтрокВТаблице Тогда
				СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);						
				НоваяФорма = СледСтрокаВыгрузки.Форма;
				КонечнаяСтрока = НомерСтроки;
			Иначе
				НоваяФорма = Неопределено;
				КонечнаяСтрока = НомерСтроки;
			КонецЕсли;
		КонецЦикла;
        		
		МногСтруктура = СтрокаВыгрузки.Значение[0].Данные;
		
		КоличествоЗаписей = 0;
		
		Для Каждого КлючИЗначение Из МногСтруктура Цикл
			ТаблицаСтрокГруппы = КлючИЗначение.Значение.Строки;
			КоличествоЗаписей =  ТаблицаСтрокГруппы.Количество();
			Прервать;
		КонецЦикла;
		
		ВсегоСтр = 0;
		
		Если КоличествоЗаписей <= 1 Тогда 
			ВсегоСтр = 0;
		Иначе 
			ВсегоСтр = КоличествоЗаписей - 1;	
		КонецЕсли;
		
		ОдинШаг = Истина;
		НачальнаяСтрока = НачальнаяСтрока - 1;	
		
		Для ШагФорм = 0 По ВсегоСтр Цикл 
			
			Для Шаг = НачальнаяСтрока По КонечнаяСтрока Цикл  
				
				Если Шаг = КонечнаяСтрока Тогда 
					Прервать;
				КонецЕсли;
				
				СтрокаВыгрузкиТек = ТаблицаВыгрузки.Получить(Шаг);
				ТекущаяФорма 	  = СтрокаВыгрузкиТек.Форма; 
				ТекущаяСтраница   = СтрокаВыгрузкиТек.Страница;
				
				СтрокаВыгрузкиСлед = ТаблицаВыгрузки.Получить(Шаг + 1);
				
				НоваяФорма 		   = СтрокаВыгрузкиСлед.Форма; 
				НоваяСтраница      = СтрокаВыгрузкиСлед.Страница; 			
				
				Если ОдинШаг Тогда 
					НомерЛиста = Новый Структура;
					НомерЛиста.Вставить("НомерЛиста",ШагФорм);
					ЗаписатьЗначениеЭлемента(Запись, СтрокаВыгрузкиСлед, НомерЛиста);
                    ОдинШаг = Ложь;
					Продолжить;
				КонецЕсли;


				Если НоваяФорма <> ТекущаяФорма Тогда
					Запись.ЗаписатьКонецЭлемента();			// </sheet>
				КонецЕсли;
				Если НЕ НоваяФорма = ТекущаяФорма Тогда		
					Запись.ЗаписатьКонецЭлемента();			// </sheetGroup>
					Запись.ЗаписатьКонецЭлемента();			// </form>
					Запись.ЗаписатьНачалоЭлемента("form");
					Состояние("Выгружается форма " + НоваяФорма);
					Запись.ЗаписатьАтрибут("name",СтрокаВыгрузкиСлед.Форма);
					Запись.ЗаписатьНачалоЭлемента("sheetGroup");
				КонецЕсли;                                       	
				Если НЕ НоваяСтраница = ТекущаяСтраница Тогда
					Если НоваяФорма <> ТекущаяФорма Тогда
						// ничего не делаем
					Иначе
						Запись.ЗаписатьКонецЭлемента();			// </sheet>
					КонецЕсли;
					Запись.ЗаписатьНачалоЭлемента("sheet");
					Запись.ЗаписатьАтрибут("name",СтрокаВыгрузкиСлед.Страница);
				КонецЕсли;
				НомерЛиста = Новый Структура;
				НомерЛиста.Вставить("НомерЛиста",ШагФорм);
				ЗаписатьЗначениеЭлемента(Запись, СтрокаВыгрузкиСлед, НомерЛиста);
			КонецЦикла;
		КонецЦикла;
		
	Иначе // форма многострочная
		
		// Определяем одинаковое ли количество строк на всех страницах формы и создаем таблицу значений
		// например, в форме 300.07 и 300.08 одинаковое количество
		// а в других может быть неодинаковое - и там другой механизм выгрузки по строкам
		ОдинаковоеКоличествоСтрок = Истина;
		КоличествоСтрокНаЛисте = 0;
		
		ТаблицаМногострочнойФормы = ТаблицаВыгрузки.СкопироватьКолонки();
		НоваяСтрока = ТаблицаМногострочнойФормы.Добавить();			
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаВыгрузки);
		
		ТекущаяФорма = СтрокаВыгрузки.Форма;
		СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);
		НоваяФорма = СледСтрокаВыгрузки.Форма;
		Пока НоваяФорма = ТекущаяФорма Цикл
			НомерСтроки = НомерСтроки+1;
			НоваяСтрока = ТаблицаМногострочнойФормы.Добавить();			
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СледСтрокаВыгрузки);
			Если ЗначениеЗаполнено(СледСтрокаВыгрузки.КоличествоROW) И СледСтрокаВыгрузки.КоличествоROW <> "0" Тогда
				ТекКоличествоСтрокНаЛисте = Число(СледСтрокаВыгрузки.КоличествоROW);
				Если КоличествоСтрокНаЛисте <> 0 И КоличествоСтрокНаЛисте <> ТекКоличествоСтрокНаЛисте Тогда
					ОдинаковоеКоличествоСтрок = Ложь;
				КонецЕсли;
				КоличествоСтрокНаЛисте = Число(СледСтрокаВыгрузки.КоличествоROW);
			КонецЕсли;
			ТекущаяФорма = СледСтрокаВыгрузки.Форма;
			Если НомерСтроки+1 < КоличествоСтрокВТаблице Тогда
				Если (ТаблицаВыгрузки.Количество()-1) > НомерСтроки  Тогда
					СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);
				Иначе
					Прервать;
				КонецЕсли;					
				НоваяФорма = СледСтрокаВыгрузки.Форма;
			Иначе
				НоваяФорма = Неопределено;
			КонецЕсли;
		КонецЦикла;
		
		//Выгружаем многострочные данные, у которых одинаковое количество строк
		//Если ОдинаковоеКоличествоСтрок Тогда //как для 300.07, 300.08 и большинства других многострочных
			
			// Определим количество <sheetGroup>
			МногСтруктура = СтрокаВыгрузки.Значение[0].Данные;
			
			КоличествоЗаписей = 0;
			Для Каждого КлючИЗначение Из МногСтруктура Цикл
				ТаблицаСтрокГруппы = КлючИЗначение.Значение.Строки;
				КоличествоЗаписей =  ТаблицаСтрокГруппы.Количество();
				Прервать;
			КонецЦикла;
						
			мКоличествоНаЛисте = СтрокаВыгрузки.КоличествоНаЛисте; // из макета Показатели
			Стр =  Цел(КоличествоЗаписей/мКоличествоНаЛисте);
			Если Стр = КоличествоЗаписей/мКоличествоНаЛисте  Тогда
				ВсегоСтр = Стр;
			Иначе
				ВсегоСтр = Стр + 1;
			КонецЕсли;
			
			Если КоличествоЗаписей = 0 Тогда // форма не заполнена, то выгружаем пустые теги
				ВсегоСтр = 1;
			КонецЕсли;
			
			Для КолСтр = 1 По ВсегоСтр Цикл // sheetgroup
				Если КолСтр <> 1 Тогда
					Запись.ЗаписатьКонецЭлемента();		// </sheet>
					Запись.ЗаписатьКонецЭлемента();		// </sheetgroup>
					Запись.ЗаписатьНачалоЭлемента("sheetGroup");
					Запись.ЗаписатьНачалоЭлемента("sheet");
					Запись.ЗаписатьАтрибут("name", СтрокаВыгрузки.Страница);
				КонецЕсли;
				ТекущаяСтраница = СтрокаВыгрузки.Страница;
				Для Ном = 0 По ТаблицаМногострочнойФормы.Количество()-1 Цикл 
					СтрокаТаблицы = ТаблицаМногострочнойФормы[Ном];				
					НоваяСтраница = СтрокаТаблицы.Страница;
					// если перешли на новую страницу
					Если НоваяСтраница <> ТекущаяСтраница Тогда
						 Запись.ЗаписатьКонецЭлемента();		// </sheet>
						 Запись.ЗаписатьНачалоЭлемента("sheet");
						 Запись.ЗаписатьАтрибут("name", СтрокаТаблицы.Страница);
					КонецЕсли;		
					Если ЗначениеЗаполнено(СтрокаТаблицы.Отображение) И КолСтр <> Число(СтрокаТаблицы.Отображение) Тогда
						Продолжить;
					КонецЕсли;
					// проверим элемент это или нет
					Если Лев(СтрокаТаблицы.ИмяАтрибута,1) = "#" Тогда
						Атрибут = Сред(СтрокаТаблицы.ИмяАтрибута,2);
						// опеределим начальный или конечный элемент
						Если Лев(Атрибут,1) = "/" Тогда // это конечный элемент							
							Запись.ЗаписатьКонецЭлемента();
						Иначе // это начальный
							Запись.ЗаписатьНачалоЭлемента(Атрибут);
						КонецЕсли;						
					ИначеЕсли ЗначениеЗаполнено(СтрокаТаблицы.КоличествоROW) И СтрокаТаблицы.КоличествоROW <> "0" Тогда
						КоличествоПовторений = Число(СтрокаТаблицы.КоличествоROW);
						Если КолСтр = ВсегоСтр И КолСтр <> 1  Тогда // рассчитаем сколько должно быть строк на последней странице, при этом на 1 стр - должно быть количество строк как в макете
							КоличествоПовторений = КоличествоЗаписей - КоличествоПовторений*(КолСтр-1);
						КонецЕсли;
						Для Н = 1 По КоличествоПовторений Цикл 
							Запись.ЗаписатьНачалоЭлемента("row");							
							Если Н = 1 Тогда
								ТаблицаМногострочныхТегов = ТаблицаМногострочнойФормы.СкопироватьКолонки();
								НоваяСтрока = ТаблицаМногострочныхТегов.Добавить();			
								ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
								
								// Проверим многострочная ли следующая строка
								СледСтрокаВыгрузки = ТаблицаМногострочнойФормы.Получить(Ном+1);
								Пока ЗначениеЗаполнено(СледСтрокаВыгрузки.КоличествоROW) И СледСтрокаВыгрузки.КоличествоROW <> "0" Цикл
									Ном = Ном+1;
									НоваяСтрока = ТаблицаМногострочныхТегов.Добавить();			
									ЗаполнитьЗначенияСвойств(НоваяСтрока, СледСтрокаВыгрузки);
									Если Ном + 1 = ТаблицаМногострочнойФормы.Количество() Тогда
										Прервать;
									КонецЕсли;
									СледСтрокаВыгрузки = ТаблицаМногострочнойФормы.Получить(Ном+1);
								КонецЦикла;   				
							КонецЕсли;
							Для Каждого МногСтрока Из ТаблицаМногострочныхТегов Цикл
								СтруктураПараметров = Новый Структура;
								СтруктураПараметров.Вставить("КоличествоГруппСтраниц", КолСтр);
								СтруктураПараметров.Вставить("НомерЗаписи", Н);
								ЗаписатьЗначениеЭлемента(Запись, МногСтрока, СтруктураПараметров);	
							КонецЦикла;    			
												
							Запись.ЗаписатьКонецЭлемента();			// </row>
						КонецЦикла;	
					Иначе			
						СтруктураПараметров = Новый Структура;
						СтруктураПараметров.Вставить("КоличествоГруппСтраниц", КолСтр);
						ЗаписатьЗначениеЭлемента(Запись, СтрокаТаблицы, СтруктураПараметров);					
					КонецЕсли;				 
					СтрокаТаблицы = ТаблицаМногострочнойФормы[Ном];				
					ТекущаяСтраница = СтрокаТаблицы.Страница;
				КонецЦикла; 
			КонецЦикла; 				
					
		//Иначе //многострочных, у которых разное количество строк на страницах
		//	
		//КонецЕсли;
		
	КонецЕсли;	
	
КонецПроцедуры // ВыгрузитьМногострочнуюФорму()

// Записываем значение в поле field из структуры хранения данных
//
Процедура ЗаписатьЗначениеЭлемента(Запись, СтрокаВыгрузки, СтруктураПараметров = Неопределено)
	
	Запись.ЗаписатьНачалоЭлемента("field");
	Запись.ЗаписатьАтрибут("name",СтрокаВыгрузки.ИмяАтрибута);
	// Выгрузим значение ячейки, если оно есть в форме
	ИмяЯчейки = СтрокаВыгрузки.ИмяЯчейки;
	Если ЗначениеЗаполнено(ИмяЯчейки) Тогда
		//получаем и записываем значение из отчета		
		Если СтрокаВыгрузки.Выгружать = 1 Тогда
			Если СтрокаВыгрузки.Многострочность Тогда
				// определим имя Листа по имени страницы
				ИмяЛиста = СтрокаВыгрузки.ИмяЛиста;
				СтруктураГруппы = Неопределено;
				МногСтруктура = СтрокаВыгрузки.Значение[0].Данные;
				Если ЗначениеЗаполнено(ИмяЛиста) И МногСтруктура.Свойство(ИмяЛиста) Тогда            					
					МногСтруктура.Свойство(ИмяЛиста,СтруктураГруппы);				
				Иначе
					Сообщить("Не заполнено ""Имя листа"" или ""Имя листа"" указано неверно для ячейки """ + ИмяЯчейки + """ в макете для выгрузки значения в XML!", СтатусСообщения.Важное);	
				КонецЕсли;
					
				Если ИмяЯчейки = "НомерСтраницы" Тогда
					КолСтр = Неопределено;
					СтруктураПараметров.Свойство("КоличествоГруппСтраниц", КолСтр);
					Запись.ЗаписатьТекст(XMLСтрока(Формат(КолСтр,"ЧЦ=3; ЧВН=")));
				// заполнения многостроничных данных	
				ИначеЕсли СтрокаВыгрузки.КоличествоНаЛисте = 1 Тогда 
					Если СтруктураГруппы <> Неопределено Тогда
						 НомерЛиста = СтруктураПараметров.НомерЛиста;
						 СтрокаЗначений = СтруктураГруппы.Строки[НомерЛиста];
						 Попытка
							 Строка = СтрокаЗначений[ИмяЯчейки];
						 Исключение
							 Строка = Неопределено;
						 КонецПопытки;
						 Если Строка <> Неопределено Тогда
							 Значение = Строка;
							 Значение = ПривестиЗначениеКФорматуСОНО(Значение, СтрокаВыгрузки.ВыгружатьНулевыеЗначения); //СтрокаФорматов);
				    		 Запись.ЗаписатьТекст(XMLСтрока(Значение));
						 КонецЕсли;
					 КонецЕсли;
				ИначеЕсли ЗначениеЗаполнено(СтрокаВыгрузки.КоличествоROW) И СтрокаВыгрузки.КоличествоROW <> "0" Тогда  // многострочная часть row
					КоличествоНаЛисте = Число(СтрокаВыгрузки.КоличествоROW);
					НомерЗаписиНаЛисте = Неопределено;
					СтруктураПараметров.Свойство("НомерЗаписи", НомерЗаписиНаЛисте);
					КолСтр = Неопределено;
					СтруктураПараметров.Свойство("КоличествоГруппСтраниц", КолСтр);										
					Если СтруктураГруппы <> Неопределено Тогда
						 ТаблицаСтрокГруппы = СтруктураГруппы.Строки;						 					
						 // рассчитаем индекс строки и проверим есть ли такая строка в таблице данных
						 ИндексСтроки = НомерЗаписиНаЛисте + (КолСтр-1)* КоличествоНаЛисте - 1;
						 Если ИндексСтроки < ТаблицаСтрокГруппы.Количество() Тогда  // строк в таблице может быть меньше, чем выгружается в XML
							 Строка = ТаблицаСтрокГруппы.Получить(ИндексСтроки);
							 Если Строка <> Неопределено Тогда // найдена строка для выгрузки значения
								 Если ТаблицаСтрокГруппы.Колонки.Найти(ИмяЯчейки) <> Неопределено Тогда 
									 Значение = Строка[ИмяЯчейки];
							         Значение = ПривестиЗначениеКФорматуСОНО(Значение, СтрокаВыгрузки.ВыгружатьНулевыеЗначения); //СтрокаФорматов);
					    		 	 Запись.ЗаписатьТекст(XMLСтрока(Значение));
								 КонецЕсли;
							 КонецЕсли;
						 КонецЕсли;
					КонецЕсли;
				Иначе // шапка или подвал
					Если СтруктураГруппы <> Неопределено Тогда
						 ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
						 Строка = ОбщиеЭлементыГруппы.Найти(ИмяЯчейки,"ИмяОбласти");
						 Если Строка <> Неопределено Тогда
							 Значение = Строка.Значение;
							 Значение = ПривестиЗначениеКФорматуСОНО(Значение, СтрокаВыгрузки.ВыгружатьНулевыеЗначения); //СтрокаФорматов);
				    		 Запись.ЗаписатьТекст(XMLСтрока(Значение));
						 Иначе
							 Сообщить("Не найден в структуре хранения данных показатель " + ИмяЯчейки + " для формы " + СтрокаВыгрузки.Форма);	
							 Значение = "";
						 КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			Иначе
				ТаблицаДанных = СтрокаВыгрузки.Значение;
				СтрокаОбласти = ТаблицаДанных.Найти(ИмяЯчейки,"ИмяОбласти");
				Если СтрокаОбласти <> Неопределено Тогда
					Значение = СтрокаОбласти.Значение;
					Значение = ПривестиЗначениеКФорматуСОНО(Значение, СтрокаВыгрузки.ВыгружатьНулевыеЗначения); //СтрокаФорматов);
				    Запись.ЗаписатьТекст(XMLСтрока(Значение));
				Иначе
					Сообщить("Не найдена ячейка """ + ИмяЯчейки + """ для выгрузки значения в XML!", СтатусСообщения.Важное);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;		
	КонецЕсли;
	Запись.ЗаписатьКонецЭлемента();			// </field>

КонецПроцедуры // ЗаписатьЗначениеЭлемента()

//Приводит значение к нужному формату для выгрузки в формате XML
//
Функция ПривестиЗначениеКФорматуСОНО(Значение, ВыгружатьНулевыеЗначения = Ложь) 
	
	Если Врег(Значение) = "Х" ИЛИ Врег(Значение) = "X" Тогда
		Значение = Истина;
	ИначеЕсли ТипЗнч(Значение) = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Значение = "";
		Иначе
			Значение = Лев(Значение,10);
		КонецЕсли;
	ИначеЕсли ТипЗнч(Значение) = Тип("Число") И Значение = 0 И НЕ ВыгружатьНулевыеЗначения Тогда
		Значение = "";
   	ИначеЕсли ТипЗнч(Значение) = Тип("СписокЗначений") Тогда	
        МассивЗначение  = Значение.ВыгрузитьЗначения();
        Значение = "";
        Если МассивЗначение.Количество() > 0 Тогда
            Для каждого Строка Из МассивЗначение Цикл
                Значение = Строка + ";";
            КонецЦикла; 
        КонецЕсли; 
	ИначеЕсли Значение = Неопределено И ВыгружатьНулевыеЗначения Тогда	
		Значение = 0;
	КонецЕсли;
	
	Возврат Значение;	
	
КонецФункции // ПривестиЗначениеКФорматуСОНО()

#КонецЕсли